/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/api/v1/device/all/config': {
    get: operations['listDeviceConfigs'];
  };
  '/api/v1/resources': {
    post: operations['createResource'];
  };
  '/api/v1/resources/{*path}': {
    get: operations['getResource'];
  };
  '/api/v1/seedbank/accession': {
    post: operations['create'];
  };
  '/api/v1/seedbank/accession/{accessionNumber}': {
    get: operations['read'];
    put: operations['update'];
  };
  '/api/v1/seedbank/accession/{accessionNumber}/photo': {
    get: operations['listPhotos'];
  };
  '/api/v1/seedbank/accession/{accessionNumber}/photo/{photoFilename}': {
    get: operations['getPhoto'];
    post: operations['uploadPhoto'];
  };
  '/api/v1/seedbank/clock': {
    /** In test environments, the clock can be advanced artificially, which will cause it to differ from the real-world date and time. */
    get: operations['getCurrentTime'];
  };
  '/api/v1/seedbank/clock/advance': {
    /** Advancing the clock causes any scheduled processes to run. Subsequent GET requests to read the current time will take the advancement into account. Only supported in test and development environments. */
    post: operations['advanceClock'];
  };
  '/api/v1/seedbank/log/{tag}': {
    post: operations['recordLogMessage'];
  };
  '/api/v1/seedbank/notification': {
    get: operations['listAll'];
  };
  '/api/v1/seedbank/notification/all/markRead': {
    post: operations['markAllRead'];
  };
  '/api/v1/seedbank/notification/all/markUnread': {
    /** For development and testing of notifications. Not available in production. */
    post: operations['markAllUnread'];
  };
  '/api/v1/seedbank/notification/{id}/markRead': {
    post: operations['markRead'];
  };
  '/api/v1/seedbank/search': {
    post: operations['search'];
  };
  '/api/v1/seedbank/search/export': {
    post: operations['export'];
  };
  '/api/v1/seedbank/summary': {
    get: operations['getSummary'];
  };
  '/api/v1/seedbank/timeseries': {
    post: operations['reportNumericValue'];
  };
  '/api/v1/seedbank/values': {
    post: operations['listFieldValues'];
  };
  '/api/v1/seedbank/values/all': {
    post: operations['listAllFieldValues'];
  };
  '/api/v1/seedbank/values/species': {
    get: operations['listSpecies'];
    post: operations['createSpecies'];
  };
  '/api/v1/seedbank/values/species/{id}': {
    /** If the species is being renamed and the species name in the payload already exists, the existing species replaces the one in the request (thus merging the requested species into the one that already had the name) and its ID is returned. */
    post: operations['updateSpecies'];
  };
  '/api/v1/seedbank/values/storageLocation': {
    get: operations['getStorageLocations'];
  };
}

export interface components {
  schemas: {
    AccessionPayload: {
      /** Server-generated unique identifier for the accession. */
      accessionNumber?: string;
      /** Server-calculated active indicator. This is based on the accession's state. */
      active: 'Inactive' | 'Active';
      bagNumbers?: string[];
      collectedDate?: string;
      deviceInfo?: components['schemas']['DeviceInfoPayload'];
      cutTestSeedsCompromised?: number;
      cutTestSeedsEmpty?: number;
      cutTestSeedsFilled?: number;
      dryingEndDate?: string;
      dryingMoveDate?: string;
      dryingStartDate?: string;
      endangered?: 'No' | 'Yes' | 'Unsure';
      environmentalNotes?: string;
      estimatedSeedCount?: number;
      family?: string;
      fieldNotes?: string;
      founderId?: string;
      geolocations?: components['schemas']['Geolocation'][];
      germinationTests?: components['schemas']['GerminationTestPayload'][];
      germinationTestTypes?: ('Lab' | 'Nursery')[];
      /** Initial size of accession. The units of this value must match the measurement type in "processingMethod". */
      initialQuantity?: components['schemas']['SeedQuantityPayload'] & {
        [key: string]: any;
      };
      landowner?: string;
      latestGerminationTestDate?: string;
      latestViabilityPercent?: number;
      numberOfTrees?: number;
      nurseryStartDate?: string;
      photoFilenames?: string[];
      primaryCollector?: string;
      processingMethod?: 'Count' | 'Weight';
      processingNotes?: string;
      processingStaffResponsible?: string;
      processingStartDate?: string;
      rare?: 'No' | 'Yes' | 'Unsure';
      receivedDate?: string;
      /** Number or weight of seeds remaining for withdrawal and testing. Calculated by the server when the accession's total size is known. */
      remainingQuantity?: components['schemas']['SeedQuantityPayload'] & {
        [key: string]: any;
      };
      secondaryCollectors?: string[];
      siteLocation?: string;
      /** Which application this accession originally came from. This is currently based on the presence of the deviceInfo field. */
      source?: 'Web' | 'SeedCollectorApp';
      sourcePlantOrigin?: 'Wild' | 'Outplant';
      species?: string;
      /** Server-generated unique ID of the species. */
      speciesId?: number;
      /** Server-calculated accession state. Can change due to modifications to accession data or based on passage of time. */
      state:
        | 'Pending'
        | 'Processing'
        | 'Processed'
        | 'Drying'
        | 'Dried'
        | 'In Storage'
        | 'Withdrawn'
        | 'Nursery';
      storageCondition?: 'Refrigerator' | 'Freezer';
      storageLocation?: string;
      storagePackets?: number;
      storageNotes?: string;
      storageStaffResponsible?: string;
      storageStartDate?: string;
      subsetCount?: number;
      /** Weight of subset of seeds. Units must be a weight measurement, not "Seeds". */
      subsetWeight?: components['schemas']['SeedQuantityPayload'] & {
        [key: string]: any;
      };
      targetStorageCondition?: 'Refrigerator' | 'Freezer';
      /** Total quantity of all past withdrawals, including germination tests. */
      totalPastWithdrawalQuantity?: components['schemas']['SeedQuantityPayload'] & {
        [key: string]: any;
      };
      /** Total quantity of scheduled withdrawals, not counting germination tests. */
      totalScheduledNonTestQuantity?: components['schemas']['SeedQuantityPayload'] & {
        [key: string]: any;
      };
      /** Total quantity of scheduled withdrawals for germination tests. */
      totalScheduledTestQuantity?: components['schemas']['SeedQuantityPayload'] & {
        [key: string]: any;
      };
      /** Total quantity of scheduled withdrawals, including germination tests. */
      totalScheduledWithdrawalQuantity?: components['schemas']['SeedQuantityPayload'] & {
        [key: string]: any;
      };
      totalViabilityPercent?: number;
      /** Total quantity of all past and scheduled withdrawals, including germination tests. */
      totalWithdrawalQuantity?: components['schemas']['SeedQuantityPayload'] & {
        [key: string]: any;
      };
      withdrawals?: components['schemas']['WithdrawalPayload'][];
    } & { [key: string]: any };
    AdvanceClockRequestPayload: {
      days: number;
    } & { [key: string]: any };
    AllFieldValuesPayload: {
      /** All the values this field could possibly have, whether or not any accessions have them. For fields that allow the user to enter arbitrary values, this is equivalent to querying the list of values without any filter criteria, that is, it's a list of all the user-entered values. */
      values: string[];
      /** If true, the list of values is too long to return in its entirety and "values" is a partial list. */
      partial: boolean;
    } & { [key: string]: any };
    /** Search criterion that matches results that meet all of a set of other search criteria. That is, if the list of children is x, y, and z, this will require x AND y AND z. */
    AndNodePayload: components['schemas']['SearchNodePayload'] &
      ({
        children?: components['schemas']['SearchNodePayload'][];
      } & { [key: string]: any }) & { [key: string]: any };
    CreateAccessionRequestPayload: {
      bagNumbers?: string[];
      collectedDate?: string;
      deviceInfo?: components['schemas']['DeviceInfoPayload'];
      endangered?: 'No' | 'Yes' | 'Unsure';
      environmentalNotes?: string;
      family?: string;
      fieldNotes?: string;
      founderId?: string;
      geolocations?: components['schemas']['Geolocation'][];
      germinationTestTypes?: ('Lab' | 'Nursery')[];
      landowner?: string;
      numberOfTrees?: number;
      primaryCollector?: string;
      rare?: 'No' | 'Yes' | 'Unsure';
      receivedDate?: string;
      secondaryCollectors?: string[];
      siteLocation?: string;
      sourcePlantOrigin?: 'Wild' | 'Outplant';
      species?: string;
    } & { [key: string]: any };
    CreateAccessionResponsePayload: {
      accession: components['schemas']['AccessionPayload'];
      status: components['schemas']['SuccessOrError'];
    } & { [key: string]: any };
    CreateSpeciesRequestPayload: {
      name: string;
    } & { [key: string]: any };
    CreateSpeciesResponsePayload: {
      details: components['schemas']['SpeciesDetails'];
      status: components['schemas']['SuccessOrError'];
    } & { [key: string]: any };
    DeviceConfig: {
      /** Name of site module where this device is located. */
      siteModule: string;
      /** Name of this device. Should be unique within the site module. */
      name: string;
      /** High-level type of the device. Device manager may use this in conjunction with the make and model to determine which metrics to report. */
      type: string;
      /** Name of device manufacturer. */
      make: string;
      /** Model number or model name of the device. */
      model: string;
      /** Device manager protocol name. */
      protocol?: string;
      /** Protocol-specific address of device, e.g., an IP address or a Bluetooth device ID. */
      address?: string;
      /** Port number if relevant for the protocol. */
      port?: number;
      /** Protocol- and device-specific custom settings. Format is defined by the device manager. */
      settings?: string;
      pollingInterval?: number;
      /** Device's resource path on the server, minus organization and site names. Currently, this is always just the site module and device name. */
      serverPath: string;
    } & { [key: string]: any };
    /** Details about the device and the application that created the accession. All these values are optional and most of them are platform-dependent. */
    DeviceInfoPayload: {
      /** Build number of application that is submitting the accession, e.g., from React Native getBuildId() */
      appBuild?: string;
      /** Name of application */
      appName?: string;
      /** Brand of device, e.g., from React Native getBrand(). */
      brand?: string;
      /** Model of device hardware, e.g., from React Native getDeviceId(). */
      model?: string;
      /** Name the user has assigned to the device, e.g., from React Native getDeviceName(). */
      name?: string;
      /** Type of operating system, e.g., from React Native getSystemName(). */
      osType?: string;
      /** Version of operating system, e.g., from React Native getSystemVersion(). */
      osVersion?: string;
      /** Unique identifier of the hardware device, e.g., from React Native getUniqueId(). */
      uniqueId?: string;
    } & { [key: string]: any };
    ErrorDetails: {
      message: string;
    } & { [key: string]: any };
    ExportRequestPayload: {
      fields: components['schemas']['SearchField'][];
      sortOrder?: components['schemas']['SearchSortOrderElement'][];
      filters?: components['schemas']['SearchFilter'][];
      search?: (
        | components['schemas']['AndNodePayload']
        | components['schemas']['FieldNodePayload']
        | components['schemas']['NotNodePayload']
        | components['schemas']['OrNodePayload']
      ) & { [key: string]: any };
    } & { [key: string]: any };
    FieldNodePayload: components['schemas']['SearchNodePayload'] &
      ({
        field?: components['schemas']['SearchField'];
        /** List of values to match. For exact and fuzzy searches, a list of at least one value to search for; the list may include null to match accessions where the field does not have a value. For range searches, the list must contain exactly two values, the minimum and maximum; one of the values may be null to search for all values above a minimum or below a maximum. */
        values?: (string | null)[];
        type?: 'Exact' | 'Fuzzy' | 'Range';
      } & { [key: string]: any }) & { [key: string]: any };
    FieldValuesPayload: {
      /** List of values in the matching accessions. If there are accessions where the field has no value, this list will contain null (an actual null value, not the string "null"). */
      values: (string | null)[];
      /** If true, the list of values is too long to return in its entirety and "values" is a partial list. */
      partial: boolean;
    } & { [key: string]: any };
    Geolocation: {
      latitude: number;
      longitude: number;
      accuracy?: number;
    } & { [key: string]: any };
    GerminationPayload: {
      recordingDate: string;
      seedsGerminated: number;
    } & { [key: string]: any };
    GerminationTestPayload: {
      /** Server-assigned unique ID of this germination test. Null when creating a new test. */
      id?: string;
      /** Which type of test is described. At most one of each test type is allowed. */
      testType: 'Lab' | 'Nursery';
      startDate?: string;
      endDate?: string;
      seedType?: 'Fresh' | 'Stored';
      substrate?:
        | 'Nursery Media'
        | 'Agar Petri Dish'
        | 'Paper Petri Dish'
        | 'Other';
      treatment?: 'Soak' | 'Scarify' | 'GA3' | 'Stratification' | 'Other';
      notes?: string;
      /** Quantity of seeds remaining. For weight-based accessions, this is user input and is required. For count-based accessions, it is calculated by the server and ignored on input. */
      remainingQuantity?: components['schemas']['SeedQuantityPayload'] & {
        [key: string]: any;
      };
      staffResponsible?: string;
      seedsSown?: number;
      totalPercentGerminated?: number;
      totalSeedsGerminated?: number;
      germinations?: components['schemas']['GerminationPayload'][];
    } & { [key: string]: any };
    GetAccessionResponsePayload: {
      accession: components['schemas']['AccessionPayload'];
      status: components['schemas']['SuccessOrError'];
    } & { [key: string]: any };
    GetCurrentTimeResponsePayload: {
      currentTime: string;
      status: components['schemas']['SuccessOrError'];
    } & { [key: string]: any };
    ListAllFieldValuesRequestPayload: {
      fields: components['schemas']['SearchField'][];
    } & { [key: string]: any };
    ListAllFieldValuesResponsePayload: {
      results: {
        [key: string]: components['schemas']['AllFieldValuesPayload'];
      };
      status: components['schemas']['SuccessOrError'];
    } & { [key: string]: any };
    ListDeviceConfigsResponse: {
      devices: components['schemas']['DeviceConfig'][];
      status: components['schemas']['SuccessOrError'];
    } & { [key: string]: any };
    ListFieldValuesRequestPayload: {
      fields: components['schemas']['SearchField'][];
      filters?: components['schemas']['SearchFilter'][];
      search?: (
        | components['schemas']['AndNodePayload']
        | components['schemas']['FieldNodePayload']
        | components['schemas']['NotNodePayload']
        | components['schemas']['OrNodePayload']
      ) & { [key: string]: any };
    } & { [key: string]: any };
    ListFieldValuesResponsePayload: {
      results: { [key: string]: components['schemas']['FieldValuesPayload'] };
      status: components['schemas']['SuccessOrError'];
    } & { [key: string]: any };
    ListPhotosResponseElement: {
      filename: string;
      size: number;
      capturedTime: string;
      latitude?: number;
      longitude?: number;
      /** GPS accuracy in meters. */
      gpsAccuracy?: number;
    } & { [key: string]: any };
    ListPhotosResponsePayload: {
      photos: components['schemas']['ListPhotosResponseElement'][];
      status: components['schemas']['SuccessOrError'];
    } & { [key: string]: any };
    ListSpeciesResponsePayload: {
      values: components['schemas']['SpeciesDetails'][];
      status: components['schemas']['SuccessOrError'];
    } & { [key: string]: any };
    /** Search criterion that matches results that do not match a set of search criteria. */
    NotNodePayload: components['schemas']['SearchNodePayload'] &
      ({
        child?: components['schemas']['SearchNodePayload'];
      } & { [key: string]: any }) & { [key: string]: any };
    NotificationListResponse: {
      notifications: components['schemas']['NotificationPayload'][];
      status: components['schemas']['SuccessOrError'];
    } & { [key: string]: any };
    NotificationPayload: {
      /** Unique identifier for this notification. Clients should treat it as opaque. */
      id: string;
      timestamp: string;
      type: 'Alert' | 'State' | 'Date';
      /** If true, this notification has been marked as read. */
      read: boolean;
      /** Plain-text body of notification. */
      text: string;
      /** For accession notifications, which accession caused the notification. */
      accessionNumber?: string;
      /** For state notifications, which state is being summarized. */
      state?:
        | 'Pending'
        | 'Processing'
        | 'Processed'
        | 'Drying'
        | 'Dried'
        | 'In Storage'
        | 'Withdrawn'
        | 'Nursery';
    } & { [key: string]: any };
    /** Search criterion that matches results that meet any of a set of other search criteria. That is, if the list of children is x, y, and z, this will require x OR y OR z. */
    OrNodePayload: components['schemas']['SearchNodePayload'] & {
      [key: string]: any;
    };
    SearchField:
      | 'accessionNumber'
      | 'active'
      | 'bagNumber'
      | 'collectedDate'
      | 'collectionNotes'
      | 'cutTestSeedsCompromised'
      | 'cutTestSeedsEmpty'
      | 'cutTestSeedsFilled'
      | 'dryingEndDate'
      | 'dryingMoveDate'
      | 'dryingStartDate'
      | 'endangered'
      | 'estimatedSeedsIncoming'
      | 'family'
      | 'geolocation'
      | 'germinationEndDate'
      | 'germinationPercentGerminated'
      | 'germinationSeedType'
      | 'germinationSeedsGerminated'
      | 'germinationSeedsSown'
      | 'germinationStartDate'
      | 'germinationSubstrate'
      | 'germinationTestNotes'
      | 'germinationTestType'
      | 'germinationTreatment'
      | 'landowner'
      | 'latestGerminationTestDate'
      | 'latestViabilityPercent'
      | 'nurseryStartDate'
      | 'primaryCollector'
      | 'processingMethod'
      | 'processingNotes'
      | 'processingStartDate'
      | 'rare'
      | 'receivedDate'
      | 'remainingGrams'
      | 'remainingQuantity'
      | 'remainingUnits'
      | 'siteLocation'
      | 'sourcePlantOrigin'
      | 'species'
      | 'state'
      | 'storageCondition'
      | 'storageLocation'
      | 'storageNotes'
      | 'storagePackets'
      | 'storageStartDate'
      | 'targetStorageCondition'
      | 'totalGrams'
      | 'totalQuantity'
      | 'totalUnits'
      | 'totalViabilityPercent'
      | 'treesCollectedFrom'
      | 'viabilityTestType'
      | 'withdrawalDate'
      | 'withdrawalDestination'
      | 'withdrawalGrams'
      | 'withdrawalNotes'
      | 'withdrawalPurpose'
      | 'withdrawalQuantity'
      | 'withdrawalRemainingGrams'
      | 'withdrawalRemainingQuantity'
      | 'withdrawalRemainingUnits'
      | 'withdrawalUnits';
    SearchFilter: {
      field: components['schemas']['SearchField'];
      /** List of values to match. For exact and fuzzy searches, a list of at least one value to search for; the list may include null to match accessions where the field does not have a value. For range searches, the list must contain exactly two values, the minimum and maximum; one of the values may be null to search for all values above a minimum or below a maximum. */
      values: (string | null)[];
      type: 'Exact' | 'Fuzzy' | 'Range';
    } & { [key: string]: any };
    /** A search criterion. The search will return results that match this criterion. The criterion can be composed of other search criteria to form arbitrary Boolean search expressions. */
    SearchNodePayload: {
      operation: string;
    } & { [key: string]: any };
    SearchRequestPayload: {
      fields: components['schemas']['SearchField'][];
      sortOrder?: components['schemas']['SearchSortOrderElement'][];
      filters?: components['schemas']['SearchFilter'][];
      search?: (
        | components['schemas']['AndNodePayload']
        | components['schemas']['FieldNodePayload']
        | components['schemas']['NotNodePayload']
        | components['schemas']['OrNodePayload']
      ) & { [key: string]: any };
      cursor?: string;
      count: number;
    } & { [key: string]: any };
    SearchResponsePayload: {
      results: { [key: string]: string }[];
      cursor?: string;
    } & { [key: string]: any };
    SearchSortOrderElement: {
      field: components['schemas']['SearchField'];
      direction?: 'Ascending' | 'Descending';
    } & { [key: string]: any };
    /** Represents a quantity of seeds, measured either in individual seeds or by weight. */
    SeedQuantityPayload: {
      /** Number of units of seeds. If "units" is "Seeds", this is the number of seeds and must be an integer. Otherwise it is a measurement in the weight units specified in the "units" field, and may have a fractional part. */
      quantity: number;
      units:
        | 'Seeds'
        | 'Grams'
        | 'Milligrams'
        | 'Kilograms'
        | 'Ounces'
        | 'Pounds';
      /** If this quantity is a weight measurement, the weight in grams. This is not set if the "units" field is "Seeds". This is always calculated on the server side and is ignored on input. */
      grams?: number;
    } & { [key: string]: any };
    SimpleErrorResponsePayload: {
      error: components['schemas']['ErrorDetails'];
      status: components['schemas']['SuccessOrError'];
    } & { [key: string]: any };
    SimpleSuccessResponsePayload: {
      status: components['schemas']['SuccessOrError'];
    } & { [key: string]: any };
    SpeciesDetails: {
      id: number;
      name: string;
    } & { [key: string]: any };
    StorageLocationDetails: {
      storageLocation: string;
      storageCondition: 'Refrigerator' | 'Freezer';
    } & { [key: string]: any };
    StorageLocationsResponsePayload: {
      locations: components['schemas']['StorageLocationDetails'][];
      status: components['schemas']['SuccessOrError'];
    } & { [key: string]: any };
    /** Indicates of success or failure of the requested operation. */
    SuccessOrError: 'ok' | 'error';
    /** Summary of important statistics about the seed bank for the Summary page. */
    SummaryResponse: {
      activeAccessions: components['schemas']['SummaryStatistic'];
      species: components['schemas']['SummaryStatistic'];
      families: components['schemas']['SummaryStatistic'];
      /** Number of accessions in Pending state overdue for processing */
      overduePendingAccessions: number;
      /** Number of accessions in Processed state overdue for drying */
      overdueProcessedAccessions: number;
      /** Number of accessions in Dried state overdue for storage */
      overdueDriedAccessions: number;
      /** Number of accessions withdrawn so far this week */
      recentlyWithdrawnAccessions: number;
    } & { [key: string]: any };
    /** The current value and value as of last week for a summary statistic */
    SummaryStatistic: {
      current: number;
      lastWeek: number;
    } & { [key: string]: any };
    UpdateAccessionRequestPayload: {
      bagNumbers?: string[];
      collectedDate?: string;
      cutTestSeedsCompromised?: number;
      cutTestSeedsEmpty?: number;
      cutTestSeedsFilled?: number;
      dryingEndDate?: string;
      dryingMoveDate?: string;
      dryingStartDate?: string;
      endangered?: 'No' | 'Yes' | 'Unsure';
      environmentalNotes?: string;
      family?: string;
      fieldNotes?: string;
      founderId?: string;
      geolocations?: components['schemas']['Geolocation'][];
      germinationTestTypes?: ('Lab' | 'Nursery')[];
      germinationTests?: components['schemas']['GerminationTestPayload'][];
      /** Initial size of accession. The units of this value must match the measurement type in "processingMethod". */
      initialQuantity?: components['schemas']['SeedQuantityPayload'] & {
        [key: string]: any;
      };
      landowner?: string;
      numberOfTrees?: number;
      nurseryStartDate?: string;
      primaryCollector?: string;
      processingMethod?: 'Count' | 'Weight';
      processingNotes?: string;
      processingStaffResponsible?: string;
      processingStartDate?: string;
      rare?: 'No' | 'Yes' | 'Unsure';
      receivedDate?: string;
      secondaryCollectors?: string[];
      siteLocation?: string;
      sourcePlantOrigin?: 'Wild' | 'Outplant';
      species?: string;
      storageLocation?: string;
      storageNotes?: string;
      storagePackets?: number;
      storageStaffResponsible?: string;
      storageStartDate?: string;
      subsetCount?: number;
      /** Weight of subset of seeds. Units must be a weight measurement, not "Seeds". */
      subsetWeight?: components['schemas']['SeedQuantityPayload'] & {
        [key: string]: any;
      };
      targetStorageCondition?: 'Refrigerator' | 'Freezer';
      withdrawals?: components['schemas']['WithdrawalPayload'][];
    } & { [key: string]: any };
    UpdateAccessionResponsePayload: {
      accession: components['schemas']['AccessionPayload'];
      status: components['schemas']['SuccessOrError'];
    } & { [key: string]: any };
    UpdateSpeciesResponsePayload: {
      /** If the requested species name already existed, the ID of the existing species. Will not be present if the requested species name did not already exist. */
      mergedWithSpeciesId?: number;
      status: components['schemas']['SuccessOrError'];
    } & { [key: string]: any };
    UploadPhotoMetadataPayload: {
      capturedTime: string;
      latitude?: number;
      longitude?: number;
      /** GPS accuracy in meters. */
      gpsAccuracy?: number;
    } & { [key: string]: any };
    WithdrawalPayload: {
      /** Server-assigned unique ID of this withdrawal, its ID. Omit when creating a new withdrawal. */
      id?: number;
      date: string;
      purpose:
        | 'Propagation'
        | 'Outreach or Education'
        | 'Research'
        | 'Broadcast'
        | 'Share with Another Site'
        | 'Other'
        | 'Germination Testing';
      destination?: string;
      notes?: string;
      /** Quantity of seeds remaining. For weight-based accessions, this is user input and is required. For count-based accessions, it is calculated by the server and ignored on input. */
      remainingQuantity?: components['schemas']['SeedQuantityPayload'] & {
        [key: string]: any;
      };
      staffResponsible?: string;
      /** If this withdrawal is of type "Germination Testing", the ID of the test it is associated with. This is always set by the server and cannot be modified. */
      germinationTestId?: number;
      /** For weight-based accessions, the difference between the weight remaining before this withdrawal and the weight remaining after it. This is a server-calculated value and is ignored on input. */
      weightDifference?: components['schemas']['SeedQuantityPayload'] & {
        [key: string]: any;
      };
      /** Quantity of seeds withdrawn. For germination testing withdrawals, this is always the same as the test's "seedsSown" value, if that value is present. Otherwise, it is a user-supplied value. For count-based accessions, the units must always be "Seeds". For weight-based accessions, the units may either be a weight measurement or "Seeds". */
      withdrawnQuantity?: components['schemas']['SeedQuantityPayload'] & {
        [key: string]: any;
      };
      /** The best estimate of the number of seeds withdrawn. This is the same as "withdrawnQuantity" if that is present, or else the same as "weightDifference" if this is a weight-based accession. If this is a count-based accession and "withdrawnQuantity" does not have a value, this field will not be present. This is a server-calculated value and is ignored on input. */
      estimatedQuantity?: components['schemas']['SeedQuantityPayload'] & {
        [key: string]: any;
      };
    } & { [key: string]: any };
  };
}

export interface operations {
  listDeviceConfigs: {
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['ListDeviceConfigsResponse'];
        };
      };
    };
  };
  createResource: {
    parameters: {
      query: {
        path: string;
        name: string;
        type: number;
        data_type: number;
        min_storage_interval?: number;
        decimal_places?: number;
        units?: string;
        max_history?: number;
      };
    };
    responses: {
      /** The timeseries was successfully created, or it already existed so no action was needed. */
      200: {
        content: {
          'text/plain': string;
        };
      };
      /** No device with the given path was defined. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  getResource: {
    parameters: {
      path: {
        path: string;
      };
    };
    responses: {
      /** The resource exists. The response body is just the string "Found". */
      200: {
        content: {
          'text/plain': string;
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  create: {
    responses: {
      /** The accession was created successfully. Response includes fields populated by the server, including the accession number. */
      200: {
        content: {
          'application/json': components['schemas']['CreateAccessionResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateAccessionRequestPayload'];
      };
    };
  };
  read: {
    parameters: {
      path: {
        accessionNumber: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['GetAccessionResponsePayload'];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  update: {
    parameters: {
      path: {
        accessionNumber: string;
      };
      query: {
        simulate?: boolean;
      };
    };
    responses: {
      /** The accession was updated successfully. Response includes fields populated or modified by the server as a result of the update. */
      200: {
        content: {
          'application/json': components['schemas']['UpdateAccessionResponsePayload'];
        };
      };
      /** The specified accession doesn't exist. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateAccessionRequestPayload'];
      };
    };
  };
  listPhotos: {
    parameters: {
      path: {
        accessionNumber: string;
      };
    };
    responses: {
      /** The accession's photos are listed in the response. */
      200: {
        content: {
          'application/json': components['schemas']['ListPhotosResponsePayload'];
        };
      };
      /** The accession does not exist. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  getPhoto: {
    parameters: {
      path: {
        accessionNumber: string;
        photoFilename: string;
      };
    };
    responses: {
      /** The photo was successfully retrieved. */
      200: {
        content: {
          'image/jpeg': string;
        };
      };
      /** The accession does not exist, or does not have a photo with the requested filename. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  uploadPhoto: {
    parameters: {
      path: {
        accessionNumber: string;
        photoFilename: string;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['SimpleSuccessResponsePayload'];
        };
      };
      /** The specified accession does not exist. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
      /** The requested photo already exists on the accession. */
      409: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'multipart/form-data': {
          file?: string;
          metadata?: components['schemas']['UploadPhotoMetadataPayload'];
        } & { [key: string]: any };
      };
    };
  };
  /** In test environments, the clock can be advanced artificially, which will cause it to differ from the real-world date and time. */
  getCurrentTime: {
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['GetCurrentTimeResponsePayload'];
        };
      };
    };
  };
  /** Advancing the clock causes any scheduled processes to run. Subsequent GET requests to read the current time will take the advancement into account. Only supported in test and development environments. */
  advanceClock: {
    responses: {
      /** The clock has been advanced. The response includes the newly-adjusted time. */
      200: {
        content: {
          'application/json': components['schemas']['GetCurrentTimeResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AdvanceClockRequestPayload'];
      };
    };
  };
  recordLogMessage: {
    parameters: {
      path: {
        tag: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
    };
    requestBody: {
      content: {
        'application/json': { [key: string]: { [key: string]: any } };
      };
    };
  };
  listAll: {
    parameters: {
      query: {
        /** Don't return notifications older than this; default is 1 month ago */
        since?: string;
        /** Return at most this many notifications; default is no limit */
        limit?: number;
      };
    };
    responses: {
      /** Notifications in reverse time order (newest first). */
      200: {
        content: {
          'application/json': components['schemas']['NotificationListResponse'];
        };
      };
    };
  };
  markAllRead: {
    responses: {
      /** All notifications have been marked as read. */
      200: {
        content: {
          'application/json': components['schemas']['SimpleSuccessResponsePayload'];
        };
      };
    };
  };
  /** For development and testing of notifications. Not available in production. */
  markAllUnread: {
    responses: {
      /** All notifications have been marked as unread. */
      200: {
        content: {
          'application/json': components['schemas']['SimpleSuccessResponsePayload'];
        };
      };
    };
  };
  markRead: {
    parameters: {
      path: {
        /** ID of notification to mark as read */
        id: string;
      };
    };
    responses: {
      /** Notification has been marked as read. */
      200: {
        content: {
          'application/json': components['schemas']['SimpleSuccessResponsePayload'];
        };
      };
      /** The requested notification ID was not valid. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  search: {
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['SearchResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SearchRequestPayload'];
      };
    };
  };
  export: {
    responses: {
      /** Export succeeded. */
      200: {
        content: {
          'text/csv': string;
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExportRequestPayload'];
      };
    };
  };
  getSummary: {
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['SummaryResponse'];
        };
      };
    };
  };
  reportNumericValue: {
    parameters: {
      query: {
        device: string;
        timeseries: string;
        value: number;
        units?: string;
        decimalPlaces?: number;
        siteModuleId?: number;
      };
    };
    responses: {
      /** Timeseries value recorded successfully. */
      200: {
        content: {
          'application/json': components['schemas']['SimpleSuccessResponsePayload'];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  listFieldValues: {
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['ListFieldValuesResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListFieldValuesRequestPayload'];
      };
    };
  };
  listAllFieldValues: {
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['ListAllFieldValuesResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListAllFieldValuesRequestPayload'];
      };
    };
  };
  listSpecies: {
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['ListSpeciesResponsePayload'];
        };
      };
    };
  };
  createSpecies: {
    responses: {
      /** Species created. */
      200: {
        content: {
          'application/json': components['schemas']['CreateSpeciesResponsePayload'];
        };
      };
      /** A species with the requested name already exists. */
      409: {
        content: {
          'application/json': components['schemas']['CreateSpeciesResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateSpeciesRequestPayload'];
      };
    };
  };
  /** If the species is being renamed and the species name in the payload already exists, the existing species replaces the one in the request (thus merging the requested species into the one that already had the name) and its ID is returned. */
  updateSpecies: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** Species updated or merged with an existing species. */
      200: {
        content: {
          'application/json': components['schemas']['UpdateSpeciesResponsePayload'];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateSpeciesRequestPayload'];
      };
    };
  };
  getStorageLocations: {
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['StorageLocationsResponsePayload'];
        };
      };
    };
  };
}
