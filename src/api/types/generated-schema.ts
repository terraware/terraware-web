/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


/** WithRequired type helpers */
type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };

export interface paths {
  "/api/v1/accelerator/cohorts": {
    /** Gets the list of cohorts. */
    get: operations["listCohorts"];
    /** Creates a new cohort. */
    post: operations["createCohort"];
  };
  "/api/v1/accelerator/cohorts/{cohortId}": {
    /** Gets information about a single cohort. */
    get: operations["getCohort"];
    /** Updates the information within a single cohort. */
    put: operations["updateCohort"];
    /** Deletes a single cohort. */
    delete: operations["deleteCohort"];
  };
  "/api/v1/accelerator/deliverables": {
    /**
     * Lists the deliverables for accelerator projects
     * @description The list may optionally be filtered based on certain criteria as specified in the query string. If no filter parameters are supplied, lists all the deliverables in all the participants and projects that are visible to the user. For users with accelerator admin privileges, this will be the full list of all deliverables for all accelerator projects.
     */
    get: operations["listDeliverables"];
  };
  "/api/v1/accelerator/deliverables/{deliverableId}/documents": {
    /** Uploads a new document to satisfy a deliverable. */
    post: operations["uploadDeliverableDocument"];
  };
  "/api/v1/accelerator/deliverables/{deliverableId}/documents/{documentId}": {
    /** Gets a single submission document from a deliverable. */
    get: operations["getDeliverableDocument"];
  };
  "/api/v1/accelerator/deliverables/{deliverableId}/submissions/{projectId}": {
    /** Gets the details of a single deliverable and its submission documents, if any. */
    get: operations["getDeliverable"];
    /**
     * Updates the state of a submission from a project.
     * @description Only permitted for users with accelerator admin privileges.
     */
    put: operations["updateSubmission"];
  };
  "/api/v1/accelerator/organizations": {
    /**
     * Lists organizations with the Accelerator internal tag and their projects.
     * @description By default, only lists tagged organizations that have projects that have not been assigned to participants yet.
     */
    get: operations["listAcceleratorOrganizations"];
  };
  "/api/v1/accelerator/participants": {
    /** Creates a new participant. */
    post: operations["createParticipant"];
  };
  "/api/v1/accelerator/participants/{participantId}": {
    /** Gets information about a participant and its assigned projects. */
    get: operations["getParticipant"];
    /** Updates a participant's information. */
    put: operations["updateParticipant"];
    /** Deletes a participant that has no projects. */
    delete: operations["deleteParticipant"];
  };
  "/api/v1/accelerator/projects/{projectId}": {
    /**
     * Gets the accelerator-related details for a project.
     * @description Does not include information such as project name that's available via the non-accelerator projects API.
     */
    get: operations["getProjectAcceleratorDetails"];
    /** Updates the accelerator-related details for a project. */
    put: operations["updateProjectAcceleratorDetails"];
  };
  "/api/v1/accelerator/projects/{projectId}/scores": {
    /** Gets score selections for a single project. */
    get: operations["getProjectScores"];
    /**
     * Upserts score selections for a single project.
     * @description Update the scores for the project phase. If the (project, phase, category) does not exist, a new entry is created. Setting a `score` to `null` removes the score.
     */
    put: operations["upsertProjectScores"];
  };
  "/api/v1/accelerator/projects/{projectId}/votes": {
    /**
     * Gets vote selections for a single project.
     * @description List every vote selection for this project, organized by phases. Each phase will contain a list of eligible voters and their selections.
     */
    get: operations["getProjectVotes"];
    /**
     * Upserts vote selections for a single project.
     * @description Update the user's vote for the project phase. If the (user, project, phase) does not exist, a new entry is created. Setting a `voteOption` to `null` removes the vote.
     */
    put: operations["upsertProjectVotes"];
    /**
     * Remove one or more voters from the project/phase.
     * @description Remove the voters from the project phase, making them ineligible from voting. This is different from undoing a vote (by setting the `voteOption` to `null`). To remove voters from the entire project phase, set `userId` to `null`, and set `phaseDelete` to `true`
     */
    delete: operations["deleteProjectVotes"];
  };
  "/api/v1/automations": {
    /** Gets a list of automations for a device or facility. */
    get: operations["listAutomations"];
    /** Creates a new automation for a device or facility. */
    post: operations["createAutomation"];
  };
  "/api/v1/automations/{automationId}": {
    /** Gets the details of a single automation for a device or facility. */
    get: operations["getAutomation"];
    /** Updates an existing automation for a device or facility. */
    put: operations["updateAutomation"];
    /** Deletes an existing automation from a device or facility. */
    delete: operations["deleteAutomation"];
  };
  "/api/v1/automations/{automationId}/trigger": {
    /** Reports that an automation has been triggered. */
    post: operations["postAutomationTrigger"];
  };
  "/api/v1/devices": {
    /** Registers a new device a facility's device manager. */
    post: operations["createDevice"];
  };
  "/api/v1/devices/managers": {
    /** Searches for device managers matching a set of criteria. */
    get: operations["getDeviceManagers"];
  };
  "/api/v1/devices/managers/{deviceManagerId}": {
    /** Gets information about a specific device manager. */
    get: operations["getDeviceManager"];
  };
  "/api/v1/devices/managers/{deviceManagerId}/connect": {
    /** Connects a device manager to a facility. */
    post: operations["connectDeviceManager"];
  };
  "/api/v1/devices/templates": {
    /** Lists the available templates for new devices. */
    get: operations["listDeviceTemplates"];
  };
  "/api/v1/devices/{id}": {
    /** Gets the configuration of a single device. */
    get: operations["getDevice"];
    /** Updates the configuration of an existing device. */
    put: operations["updateDevice"];
  };
  "/api/v1/devices/{id}/unresponsive": {
    /**
     * Marks a device as unresponsive.
     * @description Notifies the appropriate users so they can troubleshoot the problem.
     */
    post: operations["deviceUnresponsive"];
  };
  "/api/v1/facilities": {
    /** Lists all accessible facilities. */
    get: operations["listAllFacilities"];
    /** Creates a new facility. */
    post: operations["createFacility"];
  };
  "/api/v1/facilities/{facilityId}": {
    /** Gets information about a single facility. */
    get: operations["getFacility"];
    /** Updates information about a facility. */
    put: operations["updateFacility"];
  };
  "/api/v1/facilities/{facilityId}/alert/send": {
    /** Sends an alert to the facility's configured alert recipients. */
    post: operations["sendFacilityAlert"];
  };
  "/api/v1/facilities/{facilityId}/configured": {
    /**
     * Marks a facility as fully configured.
     * @description After connecting a device manager and finishing any necessary configuration of the facility's devices, send this request to enable processing of timeseries values and alerts from the device manager. Only valid if the facility's connection state is `Connected`.
     */
    post: operations["postConfigured"];
  };
  "/api/v1/facilities/{facilityId}/devices": {
    /** Lists the configurations of all the devices at a facility. */
    get: operations["listFacilityDevices"];
  };
  "/api/v1/facilities/{facilityId}/subLocations": {
    /** Gets a list of sub-locations at a facility. */
    get: operations["listSubLocations"];
    /** Creates a new sub-location at a facility. */
    post: operations["createSubLocation"];
  };
  "/api/v1/facilities/{facilityId}/subLocations/{subLocationId}": {
    /** Gets information about a specific sub-location at a facility. */
    get: operations["getSubLocation"];
    /** Updates the name of a sub-location at a facility. */
    put: operations["updateSubLocation"];
    /**
     * Deletes a sub-location from a facility.
     * @description The sub-location must not be in use.
     */
    delete: operations["deleteSubLocation"];
  };
  "/api/v1/facility/{facilityId}/devices": {
    /** Lists the configurations of all the devices at a facility. */
    get: operations["listFacilityDevices_1"];
  };
  "/api/v1/globalRoles/users": {
    /** Gets the list of users that have global roles. */
    get: operations["listGlobalRoles"];
    /** Remove global roles from the supplied users. */
    delete: operations["deleteGlobalRoles"];
  };
  "/api/v1/i18n/timeZones": {
    /** Gets a list of supported time zones and their names. */
    get: operations["listTimeZoneNames"];
  };
  "/api/v1/login": {
    /**
     * Redirects to a login page.
     * @description For interactive web applications, this can be used to redirect the user to a login page to allow the application to make other API requests. The login process will set a cookie that will authenticate to the API, and will then redirect back to the application. One approach is to use this in error response handlers: if an API request returns HTTP 401 Unauthorized, set location.href to this endpoint and set "redirect" to the URL of the page the user was on so they'll return there after logging in.
     */
    get: operations["login"];
  };
  "/api/v1/notifications": {
    /** Retrieve all notifications for current user scoped to an organization. */
    get: operations["readAll"];
    /** Update notifications as read or unread */
    put: operations["markAllRead"];
  };
  "/api/v1/notifications/count": {
    /** Retrieve notifications count by organization for current user. */
    get: operations["count"];
  };
  "/api/v1/notifications/{id}": {
    /** Retrieve a notification by its id. */
    get: operations["read"];
    /** Update a single notification as read or unread */
    put: operations["markRead"];
  };
  "/api/v1/nursery/batches": {
    /** Creates a new seedling batch at a nursery. */
    post: operations["createBatch"];
  };
  "/api/v1/nursery/batches/uploads": {
    /**
     * Uploads a list of seedling batches to add to the nursery.
     * @description The uploaded file must be in CSV format. A template with the correct headers may be downloaded from the `/api/v1/nursery/batches/uploads/template` endpoint.
     */
    post: operations["uploadSeedlingBatchesList"];
  };
  "/api/v1/nursery/batches/uploads/template": {
    /** Gets a template file that contains the required header row for seedling batch uploads. */
    get: operations["getSeedlingBatchesUploadTemplate"];
  };
  "/api/v1/nursery/batches/uploads/{uploadId}": {
    /**
     * Gets the status of a seedling batches list uploaded previously.
     * @description Clients may poll this endpoint to monitor the progress of the file.
     */
    get: operations["getSeedlingBatchesListUploadStatus"];
  };
  "/api/v1/nursery/batches/{batchId}/history": {
    /**
     * Gets the history of changes to a seedling batch.
     * @description Each event includes a version number. For events such as details edits that are snapshots of the values at a particular time, clients can compare against the event with the previous version number to see what has changed, e.g., to show a delta or a diff view.
     */
    get: operations["getBatchHistory"];
  };
  "/api/v1/nursery/batches/{batchId}/photos": {
    /** Lists all the photos of a seedling batch. */
    get: operations["listBatchPhotos"];
    /** Creates a new photo of a seedling batch. */
    post: operations["createBatchPhoto"];
  };
  "/api/v1/nursery/batches/{batchId}/photos/{photoId}": {
    /**
     * Retrieves a specific photo from a seedling batch.
     * @description Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio.
     */
    get: operations["getBatchPhoto"];
    /** Deletes a photo from a seedling batch. */
    delete: operations["deleteBatchPhoto"];
  };
  "/api/v1/nursery/batches/{id}": {
    /** Gets information about a single seedling batch. */
    get: operations["getBatch"];
    /** Updates non-quantity-related details about a batch. */
    put: operations["updateBatch"];
    /** Deletes an existing seedling batch from a nursery. */
    delete: operations["deleteBatch"];
  };
  "/api/v1/nursery/batches/{id}/changeStatuses": {
    /**
     * Changes the statuses of seedlings in a batch.
     * @description There must be enough seedlings available to move to the next status.
     */
    post: operations["changeBatchStatuses"];
  };
  "/api/v1/nursery/batches/{id}/quantities": {
    /**
     * Updates the remaining quantities in a seedling batch.
     * @description This should not be used to record withdrawals; use the withdrawal API for that.
     */
    put: operations["updateBatchQuantities"];
  };
  "/api/v1/nursery/facilities/{facilityId}/summary": {
    /** Gets a summary of the numbers of plants in a nursery. */
    get: operations["getNurserySummary"];
  };
  "/api/v1/nursery/species/{speciesId}/summary": {
    /** Gets a summary of the numbers of plants of each species in all nurseries. */
    get: operations["getSpeciesSummary"];
  };
  "/api/v1/nursery/withdrawals": {
    /** Withdraws seedlings from one or more seedling batches at a nursery. */
    post: operations["createBatchWithdrawal"];
  };
  "/api/v1/nursery/withdrawals/{withdrawalId}": {
    /** Gets information about a specific nursery withdrawal. */
    get: operations["getNurseryWithdrawal"];
  };
  "/api/v1/nursery/withdrawals/{withdrawalId}/photos": {
    /** Lists all the photos of a withdrawal. */
    get: operations["listWithdrawalPhotos"];
    /** Creates a new photo of a seedling batch withdrawal. */
    post: operations["uploadWithdrawalPhoto"];
  };
  "/api/v1/nursery/withdrawals/{withdrawalId}/photos/{photoId}": {
    /**
     * Retrieves a specific photo from a withdrawal.
     * @description Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio.
     */
    get: operations["getWithdrawalPhoto"];
  };
  "/api/v1/organizations": {
    /**
     * Lists all organizations.
     * @description Lists all organizations the user can access.
     */
    get: operations["listOrganizations"];
    /** Creates a new organization. */
    post: operations["createOrganization"];
  };
  "/api/v1/organizations/{organizationId}": {
    /** Gets information about an organization. */
    get: operations["getOrganization"];
    /** Updates an existing organization. */
    put: operations["updateOrganization"];
    /**
     * Deletes an existing organization.
     * @description Organizations can only be deleted if they have no members other than the current user.
     */
    delete: operations["deleteOrganization"];
  };
  "/api/v1/organizations/{organizationId}/roles": {
    /** Lists the roles in an organization. */
    get: operations["listOrganizationRoles"];
  };
  "/api/v1/organizations/{organizationId}/users": {
    /** Lists the users in an organization. */
    get: operations["listOrganizationUsers"];
    /** Adds a user to an organization. */
    post: operations["addOrganizationUser"];
  };
  "/api/v1/organizations/{organizationId}/users/{userId}": {
    /** Gets information about a user's membership in an organization. */
    get: operations["getOrganizationUser"];
    /**
     * Updates the user's organization information.
     * @description Only includes organization-level information that can be modified by organization administrators.
     */
    put: operations["updateOrganizationUser"];
    /**
     * Removes a user from an organization.
     * @description Does not remove any data created by the user.
     */
    delete: operations["deleteOrganizationUser"];
  };
  "/api/v1/projects": {
    /** Lists accessible projects. */
    get: operations["listProjects"];
    /** Creates a new project. */
    post: operations["createProject"];
  };
  "/api/v1/projects/{id}": {
    /** Gets information about a specific project. */
    get: operations["getProject"];
    /** Updates information about an existing project. */
    put: operations["updateProject"];
    /**
     * Deletes an existing project.
     * @description Any accessions, seedling batches, or planting sites that were assigned to the project will no longer be assigned to any project.
     */
    delete: operations["deleteProject"];
  };
  "/api/v1/projects/{id}/assign": {
    /**
     * Assigns multiple entities to a project.
     * @description Overwrites any existing project assignments.
     */
    post: operations["assignProject"];
  };
  "/api/v1/reports": {
    /** Lists an organization's reports. */
    get: operations["listReports"];
  };
  "/api/v1/reports/settings": {
    /** Gets the report settings for an organization. */
    get: operations["getReportSettings"];
    /** Updates the report settings for an organization. */
    put: operations["updateReportSettings"];
  };
  "/api/v1/reports/{id}": {
    /** Retrieves the contents of a report. */
    get: operations["getReport"];
    /**
     * Updates a report.
     * @description The report must be locked by the current user.
     */
    put: operations["updateReport"];
  };
  "/api/v1/reports/{id}/files": {
    /** Lists the files associated with a report. */
    get: operations["listReportFiles"];
  };
  "/api/v1/reports/{id}/lock": {
    /**
     * Locks a report.
     * @description Only succeeds if the report is not currently locked or if it is locked by the current user.
     */
    post: operations["lockReport"];
  };
  "/api/v1/reports/{id}/lock/force": {
    /** Locks a report even if it is locked by another user already. */
    post: operations["forceLockReport"];
  };
  "/api/v1/reports/{id}/photos": {
    /** Lists the photos associated with a report. */
    get: operations["listReportPhotos"];
  };
  "/api/v1/reports/{id}/submit": {
    /**
     * Submits a report.
     * @description The report must be locked by the current user. Submitting a report releases the lock. Once a report is submitted, it may no longer be locked or updated.
     */
    post: operations["submitReport"];
  };
  "/api/v1/reports/{id}/unlock": {
    /** Releases the lock on a report. */
    post: operations["unlockReport"];
  };
  "/api/v1/reports/{reportId}/files": {
    /** Uploads a file to associate with a report. */
    post: operations["uploadReportFile"];
  };
  "/api/v1/reports/{reportId}/files/{fileId}": {
    /** Downloads a file associated with a report. */
    get: operations["downloadReportFile"];
    /** Deletes a file from a report. */
    delete: operations["deleteReportFile"];
  };
  "/api/v1/reports/{reportId}/photos": {
    /** Uploads a photo to include with a report. */
    post: operations["uploadReportPhoto"];
  };
  "/api/v1/reports/{reportId}/photos/{photoId}": {
    /**
     * Gets the contents of a photo.
     * @description Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio.
     */
    get: operations["getReportPhoto"];
    /** Updates a photo's caption. */
    put: operations["updateReportPhoto"];
    /** Deletes a photo from a report. */
    delete: operations["deleteReportPhoto"];
  };
  "/api/v1/search": {
    /**
     * Exports selected fields from data matching a set of search criteria.
     * @description If a sublist field has multiple values, they are separated with line breaks in the exported file.
     */
    post: operations["search_1"];
  };
  "/api/v1/search/values": {
    /** Search for distinct values from data matching a set of search criteria. */
    post: operations["searchDistinctValues"];
  };
  "/api/v1/seedbank/accessions/{id}": {
    /** Deletes an existing accession. */
    delete: operations["delete"];
  };
  "/api/v1/seedbank/accessions/{id}/checkIn": {
    /** Marks an accession as checked in. */
    post: operations["checkIn"];
  };
  "/api/v1/seedbank/accessions/{id}/history": {
    /** Gets the history of changes to an accession. */
    get: operations["getAccessionHistory"];
  };
  "/api/v1/seedbank/accessions/{id}/photos": {
    /** List all the available photos for an accession. */
    get: operations["listPhotos"];
  };
  "/api/v1/seedbank/accessions/{id}/photos/{photoFilename}": {
    /**
     * Retrieve a specific photo from an accession.
     * @description Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio.
     */
    get: operations["getPhoto"];
    /**
     * Upload a new photo for an accession.
     * @description If there was already a photo with the specified filename, replaces it.
     */
    post: operations["uploadPhoto"];
  };
  "/api/v1/seedbank/clock": {
    /**
     * Get the server's current date and time.
     * @description In test environments, the clock can be advanced artificially, which will cause it to differ from the real-world date and time.
     */
    get: operations["getCurrentTime"];
  };
  "/api/v1/seedbank/log/{tag}": {
    /** Records a log message from a device at a seed bank. */
    post: operations["recordLogMessage"];
  };
  "/api/v1/seedbank/summary": {
    /** Get summary statistics about a specific seed bank or all seed banks within an organization. */
    get: operations["getSeedBankSummary"];
    /** Get summary statistics about accessions that match a specified set of search criteria. */
    post: operations["summarizeAccessionSearch"];
  };
  "/api/v1/seedbank/values": {
    /** List the values of a set of search fields for a set of accessions matching certain filter criteria. */
    post: operations["listFieldValues"];
  };
  "/api/v1/seedbank/values/all": {
    /** List the possible values of a set of search fields. */
    post: operations["listAllFieldValues"];
  };
  "/api/v1/species": {
    /** Lists all the species available in an organization. */
    get: operations["listSpecies"];
    /** Creates a new species. */
    post: operations["createSpecies"];
  };
  "/api/v1/species/lookup/details": {
    /** Gets more information about a species with a particular scientific name. */
    get: operations["getSpeciesDetails"];
  };
  "/api/v1/species/lookup/names": {
    /** @description Gets a list of known scientific names whose words begin with particular letters. */
    get: operations["listSpeciesNames"];
  };
  "/api/v1/species/problems/{problemId}": {
    /** @description Returns details about a problem with a species. */
    get: operations["getSpeciesProblem"];
    /**
     * Applies suggested changes to fix a problem with a species.
     * @description Only valid for problems that include suggested changes.
     */
    post: operations["acceptProblemSuggestion"];
    /** Deletes information about a problem with a species without applying any suggested changes. */
    delete: operations["deleteProblem"];
  };
  "/api/v1/species/uploads": {
    /**
     * Uploads a list of species to add to the organization.
     * @description The uploaded file must be in CSV format. A template with the correct headers may be downloaded from the `/api/v1/species/uploads/template` endpoint.
     */
    post: operations["uploadSpeciesList"];
  };
  "/api/v1/species/uploads/template": {
    /** Gets a template file that contains the required header row for species list uploads. */
    get: operations["getSpeciesListUploadTemplate"];
  };
  "/api/v1/species/uploads/{uploadId}": {
    /**
     * Gets the status of a species list uploaded previously.
     * @description Clients may poll this endpoint to monitor the progress of the file.
     */
    get: operations["getSpeciesListUploadStatus"];
    /**
     * Deletes a species list upload that is awaiting user action.
     * @description This may only be called if the status of the upload is "Awaiting User Action".
     */
    delete: operations["deleteSpeciesListUpload"];
  };
  "/api/v1/species/uploads/{uploadId}/resolve": {
    /**
     * Resolves the problems with a species list that is awaiting user action.
     * @description This may only be called if the status of the upload is "Awaiting User Action".
     */
    post: operations["resolveSpeciesListUpload"];
  };
  "/api/v1/species/{speciesId}": {
    /** Gets information about a single species. */
    get: operations["getSpecies"];
    /** Updates an existing species. */
    put: operations["updateSpecies"];
    /**
     * Deletes an existing species.
     * @description The species will no longer appear in the organization's list of species, but existing data (plants, seeds, etc.) that refer to the species will still refer to it.
     */
    delete: operations["deleteSpecies"];
  };
  "/api/v1/timeseries": {
    /** Lists the timeseries for one or more devices. */
    get: operations["listTimeseries"];
  };
  "/api/v1/timeseries/create": {
    /**
     * Defines a list of timeseries for one or more devices.
     * @description If there are existing timeseries with the same names, the old definitions will be overwritten.
     */
    post: operations["createMultipleTimeseries"];
  };
  "/api/v1/timeseries/history": {
    /** Returns historical values of timeseries. */
    post: operations["getTimeseriesHistory"];
  };
  "/api/v1/timeseries/values": {
    /** Records new values for one or more timeseries. */
    post: operations["recordTimeseriesValues"];
  };
  "/api/v1/tracking/deliveries/{id}": {
    /** Gets information about a specific delivery of seedlings to a planting site. */
    get: operations["getDelivery"];
  };
  "/api/v1/tracking/deliveries/{id}/reassign": {
    /** Reassigns some of the seedlings from a delivery to a different planting subzone. */
    post: operations["reassignDelivery"];
  };
  "/api/v1/tracking/draftSites": {
    /** Saves a draft of an in-progress planting site. */
    post: operations["createDraftPlantingSite"];
  };
  "/api/v1/tracking/draftSites/{id}": {
    /** Gets the details of a saved draft of a planting site. */
    get: operations["getDraftPlantingSite"];
    /** Updates an existing draft of an in-progress planting site. */
    put: operations["updateDraftPlantingSite"];
    /** Deletes an existing draft of an in-progress planting site. */
    delete: operations["deleteDraftPlantingSite"];
  };
  "/api/v1/tracking/mapbox/token": {
    /**
     * Gets an API token to use for displaying Mapbox maps.
     * @description Mapbox API tokens are short-lived; when a token expires, request a new one.
     */
    get: operations["getMapboxToken"];
  };
  "/api/v1/tracking/observations": {
    /** Gets a list of observations of planting sites. */
    get: operations["listObservations"];
    /** Schedules a new observation. */
    post: operations["scheduleObservation"];
  };
  "/api/v1/tracking/observations/results": {
    /** Gets a list of the results of observations. */
    get: operations["listObservationResults"];
  };
  "/api/v1/tracking/observations/{observationId}": {
    /** Gets information about a single observation. */
    get: operations["getObservation"];
    /** Reschedules an existing observation. */
    put: operations["rescheduleObservation"];
  };
  "/api/v1/tracking/observations/{observationId}/plots": {
    /** Gets a list of monitoring plots assigned to an observation. */
    get: operations["listAssignedPlots"];
  };
  "/api/v1/tracking/observations/{observationId}/plots/{plotId}": {
    /** Updates information about the observation of a plot. */
    put: operations["updatePlotObservation"];
    /** Stores the results of a completed observation of a plot. */
    post: operations["completePlotObservation"];
  };
  "/api/v1/tracking/observations/{observationId}/plots/{plotId}/claim": {
    /**
     * Claims a monitoring plot.
     * @description A plot may only be claimed by one user at a time.
     */
    post: operations["claimMonitoringPlot"];
  };
  "/api/v1/tracking/observations/{observationId}/plots/{plotId}/photos": {
    /** Uploads a photo of a monitoring plot. */
    post: operations["uploadPlotPhoto"];
  };
  "/api/v1/tracking/observations/{observationId}/plots/{plotId}/photos/{fileId}": {
    /**
     * Retrieves a specific photo from an observation of a monitoring plot.
     * @description Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio.
     */
    get: operations["getPlotPhoto"];
  };
  "/api/v1/tracking/observations/{observationId}/plots/{plotId}/release": {
    /** Releases the claim on a monitoring plot. */
    post: operations["releaseMonitoringPlot"];
  };
  "/api/v1/tracking/observations/{observationId}/plots/{plotId}/replace": {
    /**
     * Requests that a monitoring plot be replaced with a new one.
     * @description Additional monitoring plots may be replaced as well, e.g., if the requested plot is part of a permanent cluster. In some cases, the requested plot will be removed from the observation but not replaced with a different one.
     */
    post: operations["replaceObservationPlot"];
  };
  "/api/v1/tracking/observations/{observationId}/results": {
    /**
     * Gets the results of an observation of a planting site.
     * @description Some information is only available once all plots have been completed.
     */
    get: operations["getObservationResults"];
  };
  "/api/v1/tracking/sites": {
    /**
     * Gets a list of an organization's planting sites.
     * @description The list can optionally contain information about planting zones and subzones.
     */
    get: operations["listPlantingSites"];
    /** Creates a new planting site. */
    post: operations["createPlantingSite"];
  };
  "/api/v1/tracking/sites/{id}": {
    /**
     * Gets information about a specific planting site.
     * @description Includes information about the site's planting zones and subzones.
     */
    get: operations["getPlantingSite"];
    /** Updates information about an existing planting site. */
    put: operations["updatePlantingSite"];
    /**
     * Deletes a planting site.
     * @description Planting site should not have any plantings.
     */
    delete: operations["deletePlantingSite"];
  };
  "/api/v1/tracking/sites/{id}/reportedPlants": {
    /**
     * Gets the total number of plants planted at a planting site and in each planting zone.
     * @description The totals are based on nursery withdrawals.
     */
    get: operations["getPlantingSiteReportedPlants"];
  };
  "/api/v1/tracking/subzones/{id}": {
    /** Updates information about a planting subzone. */
    put: operations["updatePlantingSubzone"];
  };
  "/api/v1/tracking/subzones/{id}/species": {
    /**
     * Gets a list of the species that have been planted in a specific planting subzone.
     * @description The list is based on nursery withdrawals.
     */
    get: operations["listPlantingSubzoneSpecies"];
  };
  "/api/v1/users": {
    /** Gets a user by some criteria, for now only email is available */
    get: operations["searchUsers"];
  };
  "/api/v1/users/me": {
    /** Gets information about the current user. */
    get: operations["getMyself"];
    /** Updates information about the current user. */
    put: operations["updateMyself"];
    /**
     * Deletes the current user's account.
     * @description WARNING! This operation is not reversible.
     */
    delete: operations["deleteMyself"];
  };
  "/api/v1/users/me/preferences": {
    /** Gets the current user's preferences. */
    get: operations["getUserPreferences"];
    /** Updates the current user's preferences. */
    put: operations["updateUserPreferences"];
  };
  "/api/v1/users/{userId}": {
    /** Get a user by ID, if they exist, only ordinary users are supported. */
    get: operations["getUser"];
  };
  "/api/v1/users/{userId}/globalRoles": {
    /** Apply the supplied global roles to the user. */
    post: operations["updateGlobalRoles"];
  };
  "/api/v1/versions": {
    /** Gets the minimum and recommended versions for Terraware's client applications. */
    get: operations["getVersions"];
  };
  "/api/v2/seedbank/accessions": {
    /** Creates a new accession. */
    post: operations["createAccession"];
  };
  "/api/v2/seedbank/accessions/uploads": {
    /**
     * Uploads a list of accessions to add to the facility.
     * @description The uploaded file must be in CSV format. A template with the correct headers may be downloaded from the `/api/v2/seedbank/accessions/uploads/template` endpoint.
     */
    post: operations["uploadAccessionsList"];
  };
  "/api/v2/seedbank/accessions/uploads/template": {
    /** Gets a template file that contains the required header row for accessions list uploads. */
    get: operations["getAccessionsListUploadTemplate"];
  };
  "/api/v2/seedbank/accessions/uploads/{uploadId}": {
    /**
     * Gets the status of an accessions list uploaded previously.
     * @description Clients may poll this endpoint to monitor the progress of the file.
     */
    get: operations["getAccessionsListUploadStatus"];
    /**
     * Deletes an accessions list upload that is awaiting user action.
     * @description This may only be called if the status of the upload is "Awaiting User Action".
     */
    delete: operations["deleteAccessionsListUpload"];
  };
  "/api/v2/seedbank/accessions/uploads/{uploadId}/resolve": {
    /**
     * Resolves the problems with an accessions list that is awaiting user action.
     * @description This may only be called if the status of the upload is "Awaiting User Action".
     */
    post: operations["resolveAccessionsListUpload"];
  };
  "/api/v2/seedbank/accessions/{accessionId}/transfers/nursery": {
    /** Transfers seeds to a nursery. */
    post: operations["createNurseryTransferWithdrawal"];
  };
  "/api/v2/seedbank/accessions/{accessionId}/viabilityTests": {
    /** List all of the accession's viability tests. */
    get: operations["listViabilityTests"];
    /**
     * Create a new viability test on an existing accession.
     * @description May cause the accession's remaining quantity to change.
     */
    post: operations["createViabilityTest"];
  };
  "/api/v2/seedbank/accessions/{accessionId}/viabilityTests/{viabilityTestId}": {
    /** Get a single viability test. */
    get: operations["getViabilityTest"];
    /**
     * Update the details of an existing viability test.
     * @description May cause the accession's remaining quantity to change.
     */
    put: operations["updateViabilityTest"];
    /**
     * Delete an existing viability test.
     * @description May cause the accession's remaining quantity to change.
     */
    delete: operations["deleteViabilityTest"];
  };
  "/api/v2/seedbank/accessions/{accessionId}/withdrawals": {
    /** List all the withdrawals from an accession. */
    get: operations["listWithdrawals"];
    /**
     * Create a new withdrawal on an existing accession.
     * @description May cause the accession's remaining quantity to change.
     */
    post: operations["createWithdrawal"];
  };
  "/api/v2/seedbank/accessions/{accessionId}/withdrawals/{withdrawalId}": {
    /** Get a single withdrawal. */
    get: operations["getWithdrawal"];
    /**
     * Update the details of an existing withdrawal.
     * @description May cause the accession's remaining quantity to change.
     */
    put: operations["updateWithdrawal"];
    /**
     * Delete an existing withdrawal.
     * @description May cause the accession's remaining quantity to change.
     */
    delete: operations["deleteWithdrawal"];
  };
  "/api/v2/seedbank/accessions/{id}": {
    /** Retrieve an existing accession. */
    get: operations["getAccession"];
    /** Update an existing accession. */
    put: operations["updateAccession"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    AcceleratorOrganizationPayload: {
      /** Format: int64 */
      id: number;
      name: string;
      projects: components["schemas"]["AcceleratorProjectPayload"][];
    };
    AcceleratorProjectPayload: {
      /** Format: int64 */
      id: number;
      name: string;
      /** Format: int64 */
      participantId?: number;
    };
    AccessionHistoryEntryPayload: {
      /** Format: int64 */
      batchId?: number;
      /** Format: date */
      date: string;
      /**
       * @description Human-readable description of the event. Does not include date or userName.
       * @example updated the status to Drying
       */
      description: string;
      /** @description Full name of the person responsible for the event, if known. */
      fullName?: string;
      /** @description User-entered notes about the event, if any. */
      notes?: string;
      /** @enum {string} */
      type: "Created" | "QuantityUpdated" | "StateChanged" | "ViabilityTesting" | "Withdrawal";
    };
    AccessionPayloadV2: {
      /** @description Server-generated human-readable identifier for the accession. This is unique within a single seed bank, but different seed banks may have accessions with the same number. */
      accessionNumber: string;
      /**
       * @description Server-calculated active indicator. This is based on the accession's state.
       * @enum {string}
       */
      active: "Inactive" | "Active";
      bagNumbers?: string[];
      /** Format: date */
      collectedDate?: string;
      collectionSiteCity?: string;
      collectionSiteCoordinates?: components["schemas"]["Geolocation"][];
      collectionSiteCountryCode?: string;
      collectionSiteCountrySubdivision?: string;
      collectionSiteLandowner?: string;
      collectionSiteName?: string;
      collectionSiteNotes?: string;
      /** @enum {string} */
      collectionSource?: "Wild" | "Reintroduced" | "Cultivated" | "Other";
      /** @description Names of the people who collected the seeds. */
      collectors?: string[];
      /** Format: date */
      dryingEndDate?: string;
      /**
       * Format: int32
       * @description Estimated number of seeds remaining. Absent if there isn't enough information to calculate an estimate.
       */
      estimatedCount?: number;
      /** @description Estimated weight of seeds remaining. Absent if there isn't enough information to calculate an estimate. */
      estimatedWeight?: components["schemas"]["SeedQuantityPayload"];
      /** Format: int64 */
      facilityId: number;
      /** @description If true, plants from this accession's seeds were delivered to a planting site. */
      hasDeliveries: boolean;
      /**
       * Format: int64
       * @description Server-generated unique identifier for the accession. This is unique across all seed banks, but is not suitable for display to end users.
       */
      id: number;
      /** @description Most recent user observation of seeds remaining in the accession. This is not directly editable; it is updated by the server whenever the "remainingQuantity" field is edited. */
      latestObservedQuantity?: components["schemas"]["SeedQuantityPayload"];
      /**
       * Format: date-time
       * @description Time of most recent user observation of seeds remaining in the accession. This is updated by the server whenever the "remainingQuantity" field is edited.
       */
      latestObservedTime?: string;
      notes?: string;
      photoFilenames?: string[];
      plantId?: string;
      /**
       * Format: int32
       * @description Estimated number of plants the seeds were collected from.
       */
      plantsCollectedFrom?: number;
      /** Format: int64 */
      projectId?: number;
      /** Format: date */
      receivedDate?: string;
      /** @description Number or weight of seeds remaining for withdrawal and testing. May be calculated by the server after withdrawals. */
      remainingQuantity?: components["schemas"]["SeedQuantityPayload"];
      /**
       * @description Which source of data this accession originally came from.
       * @enum {string}
       */
      source?: "Web" | "Seed Collector App" | "File Import";
      /** @description Common name of the species, if defined. */
      speciesCommonName?: string;
      /**
       * Format: int64
       * @description Server-generated unique ID of the species.
       */
      speciesId?: number;
      /** @description Scientific name of the species. */
      speciesScientificName?: string;
      /** @enum {string} */
      state: "Awaiting Check-In" | "Awaiting Processing" | "Processing" | "Drying" | "In Storage" | "Used Up";
      subLocation?: string;
      /** Format: int32 */
      subsetCount?: number;
      /** @description Weight of subset of seeds. Units must be a weight measurement, not "Seeds". */
      subsetWeight?: components["schemas"]["SeedQuantityPayload"];
      /**
       * Format: int32
       * @description Total number of seeds withdrawn. If withdrawals are measured by weight, this is an estimate based on the accession's subset count and weight.
       */
      totalWithdrawnCount?: number;
      /** @description Total weight of seeds withdrawn. If withdrawals are measured by seed count, this is an estimate based on the accession's subset count and weight. */
      totalWithdrawnWeight?: components["schemas"]["SeedQuantityPayload"];
      /** Format: int32 */
      viabilityPercent?: number;
      viabilityTests?: components["schemas"]["GetViabilityTestPayload"][];
      withdrawals?: components["schemas"]["GetWithdrawalPayload"][];
    };
    AddOrganizationUserRequestPayload: {
      email: string;
      /** @enum {string} */
      role: "Contributor" | "Manager" | "Admin" | "Owner" | "Terraformation Contact";
    };
    AllFieldValuesPayload: {
      /** @description If true, the list of values is too long to return in its entirety and "values" is a partial list. */
      partial: boolean;
      /** @description All the values this field could possibly have, whether or not any accessions have them. For fields that allow the user to enter arbitrary values, this is equivalent to querying the list of values without any filter criteria, that is, it's a list of all the user-entered values. */
      values: string[];
    };
    /** @description Search criterion that matches results that meet all of a set of other search criteria. That is, if the list of children is x, y, and z, this will require x AND y AND z. */
    AndNodePayload: WithRequired<{
      operation: "and";
    } & Omit<components["schemas"]["SearchNodePayload"], "operation"> & {
      /** @description List of criteria all of which must be satisfied */
      children?: components["schemas"]["SearchNodePayload"][];
    }, "children">;
    AnnualDetailsPayloadV1: {
      bestMonthsForObservation: number[];
      budgetNarrativeSummary?: string;
      catalyticDetail?: string;
      challenges?: string;
      isCatalytic: boolean;
      keyLessons?: string;
      nextSteps?: string;
      opportunities?: string;
      projectImpact?: string;
      projectSummary?: string;
      socialImpact?: string;
      successStories?: string;
      sustainableDevelopmentGoals: components["schemas"]["GoalProgressPayloadV1"][];
    };
    AssignProjectRequestPayload: {
      accessionIds?: number[];
      batchIds?: number[];
      plantingSiteIds?: number[];
    };
    AssignedPlotPayload: {
      boundary: components["schemas"]["Geometry"];
      claimedByName?: string;
      /** Format: int64 */
      claimedByUserId?: number;
      completedByName?: string;
      /** Format: int64 */
      completedByUserId?: number;
      /** Format: date-time */
      completedTime?: string;
      /** @description True if this is the first observation to include the monitoring plot. */
      isFirstObservation: boolean;
      isPermanent: boolean;
      /** Format: int64 */
      observationId: number;
      /** Format: int64 */
      plantingSubzoneId: number;
      plantingSubzoneName: string;
      /** Format: int64 */
      plotId: number;
      plotName: string;
    };
    AutomationPayload: {
      /** @description Human-readable description of this automation. */
      description?: string;
      /** Format: int64 */
      deviceId?: number;
      /** Format: int64 */
      facilityId: number;
      /** Format: int64 */
      id: number;
      /** Format: double */
      lowerThreshold?: number;
      /** @description Short human-readable name of this automation. */
      name: string;
      /** @description Client-defined configuration data for this automation. */
      settings?: {
        [key: string]: unknown;
      };
      timeseriesName?: string;
      type: string;
      /** Format: double */
      upperThreshold?: number;
      /** Format: int32 */
      verbosity: number;
    };
    AutomationTriggerRequestPayload: {
      /** @description Default message to publish if the automation type isn't yet supported by the server. */
      message?: string;
      /**
       * Format: double
       * @description For automations that are triggered by changes to timeseries values, the value that triggered the automation.
       */
      timeseriesValue?: number;
    };
    /** @description A change to the non-quantity-related details of a batch. */
    BatchHistoryDetailsEditedPayload: WithRequired<components["schemas"]["BatchHistoryPayloadCommonProps"] & ({
      notes?: string;
      /**
       * Format: int64
       * @description The ID of the batch's project if the project still exists. If the project was subsequently deleted, this will be null but the project name will still be set.
       */
      projectId?: number;
      /** @description The name of the project at the time the details were edited. If the project was subsequently renamed or deleted, this name remains the same. */
      projectName?: string;
      /** Format: date */
      readyByDate?: string;
      subLocations?: components["schemas"]["BatchHistorySubLocationPayload"][];
      /** @enum {string} */
      substrate?: "MediaMix" | "Soil" | "Sand" | "Moss" | "PerliteVermiculite" | "Other";
      substrateNotes?: string;
      /** @enum {string} */
      treatment?: "Soak" | "Scarify" | "Chemical" | "Stratification" | "Other" | "Light";
      treatmentNotes?: string;
      /** @enum {string} */
      type?: "DetailsEdited";
    }), "createdBy" | "createdTime" | "subLocations" | "type" | "version">;
    /** @description A nursery transfer withdrawal from another batch that added seedlings to this batch. */
    BatchHistoryIncomingWithdrawalPayload: WithRequired<components["schemas"]["BatchHistoryPayloadCommonProps"] & {
      /** Format: int64 */
      fromBatchId?: number;
      /** Format: int32 */
      germinatingQuantityAdded?: number;
      /** Format: int32 */
      notReadyQuantityAdded?: number;
      /** Format: int32 */
      readyQuantityAdded?: number;
      /** @enum {string} */
      type?: "IncomingWithdrawal";
      /** Format: int64 */
      withdrawalId?: number;
      /** Format: date */
      withdrawnDate?: string;
    }, "createdBy" | "createdTime" | "fromBatchId" | "germinatingQuantityAdded" | "notReadyQuantityAdded" | "readyQuantityAdded" | "type" | "version" | "withdrawalId" | "withdrawnDate">;
    /** @description A withdrawal that removed seedlings from this batch. This does not include the full details of the withdrawal; they can be retrieved using the withdrawal ID. */
    BatchHistoryOutgoingWithdrawalPayload: WithRequired<components["schemas"]["BatchHistoryPayloadCommonProps"] & ({
      /** Format: int32 */
      germinatingQuantityWithdrawn?: number;
      /** Format: int32 */
      notReadyQuantityWithdrawn?: number;
      /** @enum {string} */
      purpose?: "Nursery Transfer" | "Dead" | "Out Plant" | "Other";
      /** Format: int32 */
      readyQuantityWithdrawn?: number;
      /** @enum {string} */
      type?: "OutgoingWithdrawal";
      /** Format: int64 */
      withdrawalId?: number;
      /** Format: date */
      withdrawnDate?: string;
    }), "createdBy" | "createdTime" | "germinatingQuantityWithdrawn" | "notReadyQuantityWithdrawn" | "purpose" | "readyQuantityWithdrawn" | "type" | "version" | "withdrawalId" | "withdrawnDate">;
    BatchHistoryPayload: components["schemas"]["BatchHistoryDetailsEditedPayload"] | components["schemas"]["BatchHistoryIncomingWithdrawalPayload"] | components["schemas"]["BatchHistoryOutgoingWithdrawalPayload"] | components["schemas"]["BatchHistoryPhotoCreatedPayload"] | components["schemas"]["BatchHistoryPhotoDeletedPayload"] | components["schemas"]["BatchHistoryQuantityEditedPayload"] | components["schemas"]["BatchHistoryStatusChangedPayload"];
    BatchHistoryPayloadCommonProps: {
      /** Format: int64 */
      createdBy: number;
      /** Format: date-time */
      createdTime: string;
      /** Format: int32 */
      version?: number;
    };
    BatchHistoryPhotoCreatedPayload: WithRequired<components["schemas"]["BatchHistoryPayloadCommonProps"] & {
      /**
       * Format: int64
       * @description ID of the photo if it exists. Null if the photo has been deleted.
       */
      fileId?: number;
      /** @enum {string} */
      type?: "PhotoCreated";
    }, "createdBy" | "createdTime" | "type">;
    BatchHistoryPhotoDeletedPayload: WithRequired<components["schemas"]["BatchHistoryPayloadCommonProps"] & {
      /** @enum {string} */
      type?: "PhotoDeleted";
    }, "createdBy" | "createdTime" | "type">;
    /** @description A manual edit of a batch's remaining quantities. */
    BatchHistoryQuantityEditedPayload: WithRequired<components["schemas"]["BatchHistoryPayloadCommonProps"] & {
      /** Format: int32 */
      germinatingQuantity?: number;
      /** Format: int32 */
      notReadyQuantity?: number;
      /** Format: int32 */
      readyQuantity?: number;
      /** @enum {string} */
      type?: "QuantityEdited";
    }, "createdBy" | "createdTime" | "germinatingQuantity" | "notReadyQuantity" | "readyQuantity" | "type" | "version">;
    /** @description The new quantities resulting from changing the statuses of seedlings in a batch. The values here are the total quantities remaining after the status change, not the number of seedlings whose statuses were changed. */
    BatchHistoryStatusChangedPayload: WithRequired<components["schemas"]["BatchHistoryPayloadCommonProps"] & {
      /** Format: int32 */
      germinatingQuantity?: number;
      /** Format: int32 */
      notReadyQuantity?: number;
      /** Format: int32 */
      readyQuantity?: number;
      /** @enum {string} */
      type?: "StatusChanged";
    }, "createdBy" | "createdTime" | "germinatingQuantity" | "notReadyQuantity" | "readyQuantity" | "type" | "version">;
    BatchHistorySubLocationPayload: {
      /**
       * Format: int64
       * @description The ID of the sub-location if it still exists. If it was subsequently deleted, this will be null but the name will still be present.
       */
      id?: number;
      /** @description The name of the sub-location at the time the details were edited. If the sub-location was subsequently renamed or deleted, this name remains the same. */
      name: string;
    };
    BatchPayload: {
      /**
       * Format: int64
       * @description If this batch was created via a seed withdrawal, the ID of the seed accession it came from.
       */
      accessionId?: number;
      /** @description If this batch was created via a seed withdrawal, the accession number associated to the seed accession it came from. */
      accessionNumber?: string;
      /** Format: date */
      addedDate: string;
      batchNumber: string;
      /** Format: int64 */
      facilityId: number;
      /** Format: int32 */
      germinatingQuantity: number;
      /** Format: int32 */
      germinationRate?: number;
      /** Format: int64 */
      id: number;
      /**
       * Format: int64
       * @description If this batch was created via a nursery transfer from another batch, the ID of the batch it came from.
       */
      initialBatchId?: number;
      /** Format: date-time */
      latestObservedTime: string;
      /** Format: int32 */
      lossRate?: number;
      /** Format: int32 */
      notReadyQuantity: number;
      notes?: string;
      /** Format: int64 */
      projectId?: number;
      /** Format: date */
      readyByDate?: string;
      /** Format: int32 */
      readyQuantity: number;
      /** Format: int64 */
      speciesId: number;
      subLocationIds: number[];
      /** @enum {string} */
      substrate?: "MediaMix" | "Soil" | "Sand" | "Moss" | "PerliteVermiculite" | "Other";
      substrateNotes?: string;
      /** Format: int32 */
      totalWithdrawn: number;
      /** @enum {string} */
      treatment?: "Soak" | "Scarify" | "Chemical" | "Stratification" | "Other" | "Light";
      treatmentNotes?: string;
      /**
       * Format: int32
       * @description Increases every time a batch is updated. Must be passed as a parameter for certain kinds of write operations to detect when a batch has changed since the client last retrieved it.
       */
      version: number;
    };
    BatchPhotoPayload: {
      /** Format: int64 */
      id: number;
    };
    BatchResponsePayload: {
      batch: components["schemas"]["BatchPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    BatchWithdrawalPayload: {
      /** Format: int64 */
      batchId: number;
      /**
       * Format: int32
       * @default 0
       */
      germinatingQuantityWithdrawn?: number;
      /** Format: int32 */
      notReadyQuantityWithdrawn: number;
      /** Format: int32 */
      readyQuantityWithdrawn: number;
    };
    /** @description Coordinate reference system used for X and Y coordinates in this geometry. By default, coordinates are in WGS 84, with longitude and latitude in degrees. In that case, this element is not present. Otherwise, it specifies which coordinate system to use. */
    CRS: {
      properties: components["schemas"]["CRSProperties"];
      /** @enum {string} */
      type: "name";
    };
    CRSProperties: {
      /**
       * @description Name of the coordinate reference system. This must be in the form EPSG:nnnn where nnnn is the numeric identifier of a coordinate system in the EPSG dataset. The default is Longitude/Latitude EPSG:4326, which is the coordinate system +for GeoJSON.
       * @example EPSG:4326
       */
      name: string;
    };
    ChangeBatchStatusRequestPayload: {
      /**
       * @description Which status change to apply.
       * @enum {string}
       */
      operation: "GerminatingToNotReady" | "NotReadyToReady";
      /**
       * Format: int32
       * @description Number of seedlings to move from one status to the next.
       */
      quantity: number;
    };
    CohortListResponsePayload: {
      cohorts: components["schemas"]["CohortPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    CohortPayload: {
      /** Format: int64 */
      id: number;
      name: string;
      participantIds?: number[];
      /** @enum {string} */
      phase: "Phase 0 - Due Diligence" | "Phase 1 - Feasibility Study" | "Phase 2 - Plan and Scale" | "Phase 3 - Implement and Monitor";
    };
    CohortResponsePayload: {
      cohort: components["schemas"]["CohortPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    CompletePlotObservationRequestPayload: {
      conditions: ("AnimalDamage" | "FastGrowth" | "FavorableWeather" | "Fungus" | "Pests" | "SeedProduction" | "UnfavorableWeather")[];
      notes?: string;
      /**
       * Format: date-time
       * @description Date and time the observation was performed in the field.
       */
      observedTime: string;
      plants: components["schemas"]["RecordedPlantPayload"][];
    };
    ConnectDeviceManagerRequestPayload: {
      /** Format: int64 */
      facilityId: number;
    };
    CreateAccessionRequestPayloadV2: {
      bagNumbers?: string[];
      /** Format: date */
      collectedDate?: string;
      collectionSiteCity?: string;
      collectionSiteCoordinates?: components["schemas"]["Geolocation"][];
      collectionSiteCountryCode?: string;
      collectionSiteCountrySubdivision?: string;
      collectionSiteLandowner?: string;
      collectionSiteName?: string;
      collectionSiteNotes?: string;
      /** @enum {string} */
      collectionSource?: "Wild" | "Reintroduced" | "Cultivated" | "Other";
      collectors?: string[];
      /** Format: int64 */
      facilityId?: number;
      notes?: string;
      plantId?: string;
      /**
       * Format: int32
       * @description Estimated number of plants the seeds were collected from.
       */
      plantsCollectedFrom?: number;
      /** Format: int64 */
      projectId?: number;
      /** Format: date */
      receivedDate?: string;
      /** @enum {string} */
      source?: "Web" | "Seed Collector App" | "File Import";
      /** Format: int64 */
      speciesId?: number;
      /** @enum {string} */
      state?: "Awaiting Check-In" | "Awaiting Processing" | "Processing" | "Drying" | "In Storage" | "Used Up";
      subLocation?: string;
    };
    CreateAccessionResponsePayloadV2: {
      accession: components["schemas"]["AccessionPayloadV2"];
      status: components["schemas"]["SuccessOrError"];
    };
    CreateAutomationRequestPayload: {
      description?: string;
      /** Format: int64 */
      deviceId?: number;
      /** Format: int64 */
      facilityId: number;
      /** Format: double */
      lowerThreshold?: number;
      name: string;
      settings?: {
        [key: string]: unknown;
      };
      timeseriesName?: string;
      type: string;
      /** Format: double */
      upperThreshold?: number;
      /** Format: int32 */
      verbosity?: number;
    };
    CreateAutomationResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateBatchPhotoResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateBatchRequestPayload: {
      /** Format: date */
      addedDate: string;
      /** Format: int64 */
      facilityId: number;
      /** Format: int32 */
      germinatingQuantity: number;
      /** Format: int32 */
      notReadyQuantity: number;
      notes?: string;
      /** Format: int64 */
      projectId?: number;
      /** Format: date */
      readyByDate?: string;
      /** Format: int32 */
      readyQuantity: number;
      /** Format: int64 */
      speciesId: number;
      subLocationIds?: number[];
      /** @enum {string} */
      substrate?: "MediaMix" | "Soil" | "Sand" | "Moss" | "PerliteVermiculite" | "Other";
      substrateNotes?: string;
      /** @enum {string} */
      treatment?: "Soak" | "Scarify" | "Chemical" | "Stratification" | "Other" | "Light";
      treatmentNotes?: string;
    };
    CreateCohortRequestPayload: {
      name: string;
      /** @enum {string} */
      phase: "Phase 0 - Due Diligence" | "Phase 1 - Feasibility Study" | "Phase 2 - Plan and Scale" | "Phase 3 - Implement and Monitor";
    };
    CreateDeviceRequestPayload: {
      /**
       * @description Protocol-specific address of device, e.g., an IP address or a Bluetooth device ID.
       * @example 192.168.1.100
       */
      address?: string;
      /**
       * Format: int64
       * @description Identifier of facility where this device is located.
       */
      facilityId: number;
      /**
       * @description Name of device manufacturer.
       * @example InHand Networks
       */
      make: string;
      /**
       * @description Model number or model name of the device.
       * @example IR915L
       */
      model: string;
      /**
       * @description Name of this device.
       * @example BMU-1
       */
      name: string;
      /**
       * Format: int64
       * @description ID of parent device such as a hub or gateway, if any. The parent device must exist.
       */
      parentId?: number;
      /**
       * Format: int32
       * @description Port number if relevant for the protocol.
       * @example 50000
       */
      port?: number;
      /**
       * @description Device manager protocol name.
       * @example modbus
       */
      protocol?: string;
      /** @description Protocol- and device-specific custom settings. This is an arbitrary JSON object; the exact settings depend on the device type. */
      settings?: {
        [key: string]: unknown;
      };
      /**
       * @description High-level type of the device. Device manager may use this in conjunction with the make and model to determine which metrics to report.
       * @example inverter
       */
      type: string;
      /**
       * Format: int32
       * @description Level of diagnostic information to log.
       */
      verbosity?: number;
    };
    CreateDraftPlantingSiteRequestPayload: {
      /** @description In-progress state of the draft. This includes map data and other information needed by the client. It is treated as opaque data by the server. */
      data: {
        [key: string]: unknown;
      };
      description?: string;
      name: string;
      /**
       * Format: int32
       * @description If the user has started defining planting subzones, the number of subzones defined so far.
       */
      numPlantingSubzones?: number;
      /**
       * Format: int32
       * @description If the user has started defining planting zones, the number of zones defined so far.
       */
      numPlantingZones?: number;
      /** Format: int64 */
      organizationId: number;
      /**
       * Format: int64
       * @description If the draft is associated with a project, its ID.
       */
      projectId?: number;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    CreateDraftPlantingSiteResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateFacilityRequestPayload: {
      /** Format: date */
      buildCompletedDate?: string;
      /** Format: date */
      buildStartedDate?: string;
      /**
       * Format: int32
       * @description For nursery facilities, the number of plants this nursery is capable of holding.
       */
      capacity?: number;
      description?: string;
      name: string;
      /** Format: date */
      operationStartedDate?: string;
      /**
       * Format: int64
       * @description Which organization this facility belongs to.
       */
      organizationId: number;
      subLocationNames?: string[];
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
      /** @enum {string} */
      type: "Seed Bank" | "Desalination" | "Reverse Osmosis" | "Nursery";
    };
    CreateFacilityResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateNurseryTransferRequestPayload: {
      /** Format: date */
      date: string;
      /** Format: int64 */
      destinationFacilityId: number;
      /** Format: int32 */
      germinatingQuantity: number;
      /** Format: int32 */
      notReadyQuantity: number;
      notes?: string;
      /** Format: date */
      readyByDate?: string;
      /** Format: int32 */
      readyQuantity: number;
      /**
       * Format: int64
       * @description ID of the user who withdrew the seeds. Default is the current user's ID. If non-null, the current user must have permission to read the referenced user's membership details in the organization.
       */
      withdrawnByUserId?: number;
    };
    CreateNurseryTransferResponsePayload: {
      /** @description Updated accession that includes a withdrawal for the nursery transfer. */
      accession: components["schemas"]["AccessionPayloadV2"];
      /** @description Details of newly-created seedling batch. */
      batch: components["schemas"]["BatchPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    CreateNurseryWithdrawalPhotoResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateNurseryWithdrawalRequestPayload: {
      batchWithdrawals: components["schemas"]["BatchWithdrawalPayload"][];
      /**
       * Format: int64
       * @description If purpose is "Nursery Transfer", the ID of the facility to transfer to. Must be in the same organization as the originating facility. Not allowed for purposes other than "Nursery Transfer".
       */
      destinationFacilityId?: number;
      /** Format: int64 */
      facilityId: number;
      notes?: string;
      /**
       * Format: int64
       * @description If purpose is "Out Plant", the ID of the planting site to which the seedlings were delivered.
       */
      plantingSiteId?: number;
      /**
       * Format: int64
       * @description If purpose is "Out Plant", the ID of the planting subzone to which the seedlings were delivered. Must be specified if the planting site has planting subzones, but must be omitted or set to null if the planting site has no planting subzones.
       */
      plantingSubzoneId?: number;
      /** @enum {string} */
      purpose: "Nursery Transfer" | "Dead" | "Out Plant" | "Other";
      /**
       * Format: date
       * @description If purpose is "Nursery Transfer", the estimated ready-by date to use for the batches that are created at the other nursery.
       */
      readyByDate?: string;
      /** Format: date */
      withdrawnDate: string;
    };
    CreateOrganizationRequestPayload: {
      /**
       * @description ISO 3166 alpha-2 code of organization's country.
       * @example AU
       */
      countryCode?: string;
      /**
       * @description ISO 3166-2 code of organization's country subdivision (state, province, region, etc.) This is the full ISO 3166-2 code including the country prefix. If this is set, countryCode must also be set.
       * @example US-HI
       */
      countrySubdivisionCode?: string;
      description?: string;
      managedLocationTypes?: ("SeedBank" | "Nursery" | "PlantingSite")[];
      name: string;
      /** @enum {string} */
      organizationType?: "Government" | "NGO" | "Arboreta" | "Academia" | "ForProfit" | "Other";
      /** @description Non-empty additional description of organization when type is Other. */
      organizationTypeDetails?: string;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
      /** @description Website of organization, no restrictions on format. */
      website?: string;
    };
    CreateOrganizationUserResponsePayload: {
      /**
       * Format: int64
       * @description The ID of the newly-added user.
       */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateParticipantRequestPayload: {
      /**
       * Format: int64
       * @description Assign the participant to this cohort. If null, the participant will not be assigned to any cohort initially.
       */
      cohortId?: number;
      name: string;
      /** @description Assign these projects to the new participant. If projects are already assigned to other participants, they will be reassigned to the new one. */
      projectIds?: number[];
    };
    CreatePlantingSiteRequestPayload: {
      boundary?: components["schemas"]["MultiPolygon"] | components["schemas"]["Polygon"];
      description?: string;
      name: string;
      /** Format: int64 */
      organizationId: number;
      plantingSeasons?: components["schemas"]["NewPlantingSeasonPayload"][];
      /** Format: int64 */
      projectId?: number;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    CreatePlantingSiteResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateProjectRequestPayload: {
      description?: string;
      name: string;
      /** Format: int64 */
      organizationId: number;
    };
    CreateProjectResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateSpeciesResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateSubLocationRequestPayload: {
      name: string;
    };
    CreateTimeseriesEntry: {
      /**
       * Format: int32
       * @description Number of significant fractional digits (after the decimal point), if this is a timeseries with non-integer numeric values.
       */
      decimalPlaces?: number;
      /**
       * Format: int64
       * @description ID of device that produces this timeseries.
       */
      deviceId: number;
      /** @description Name of this timeseries. Duplicate timeseries names for the same device aren't allowed, but different devices can have timeseries with the same name. */
      timeseriesName: string;
      /** @enum {string} */
      type: "Numeric" | "Text";
      /**
       * @description Units of measure for values in this timeseries.
       * @example volts
       */
      units?: string;
    };
    CreateTimeseriesRequestPayload: {
      timeseries: components["schemas"]["CreateTimeseriesEntry"][];
    };
    CreateViabilityTestRequestPayload: {
      /** Format: date */
      endDate?: string;
      notes?: string;
      /** @enum {string} */
      seedType?: "Fresh" | "Stored";
      /** Format: int32 */
      seedsCompromised?: number;
      /** Format: int32 */
      seedsEmpty?: number;
      /** Format: int32 */
      seedsFilled?: number;
      /** Format: int32 */
      seedsTested: number;
      /** Format: date */
      startDate?: string;
      /** @enum {string} */
      substrate?: "Nursery Media" | "Agar" | "Paper" | "Other" | "Sand" | "Media Mix" | "Soil" | "Moss" | "Perlite/Vermiculite" | "None";
      testResults?: components["schemas"]["ViabilityTestResultPayload"][];
      /** @enum {string} */
      testType: "Lab" | "Nursery" | "Cut";
      /** @enum {string} */
      treatment?: "Soak" | "Scarify" | "Chemical" | "Stratification" | "Other" | "Light";
      /**
       * Format: int64
       * @description ID of user who withdrew seeds to perform the test. Defaults to the current user. If non-null, the current user must have permission to see the referenced user's membership details in the organization.
       */
      withdrawnByUserId?: number;
    };
    CreateWithdrawalRequestPayload: {
      /** Format: date */
      date?: string;
      notes?: string;
      /** @enum {string} */
      purpose?: "Other" | "Viability Testing" | "Out-planting" | "Nursery";
      /**
       * Format: int64
       * @description ID of the user who withdrew the seeds. Default is the current user's ID. If non-null, the current user must have permission to read the referenced user's membership details in the organization.
       */
      withdrawnByUserId?: number;
      /** @description Quantity of seeds withdrawn. If this quantity is in weight and the remaining quantity of the accession is in seeds or vice versa, the accession must have a subset weight and count. */
      withdrawnQuantity?: components["schemas"]["SeedQuantityPayload"];
    };
    DeleteGlobalRolesRequestPayload: {
      userIds: number[];
    };
    DeleteProjectVotesRequestPayload: {
      /** @enum {string} */
      phase: "Phase 0 - Due Diligence" | "Phase 1 - Feasibility Study" | "Phase 2 - Plan and Scale" | "Phase 3 - Implement and Monitor";
      /** @description A safeguard flag that must be set to `true` for deleting all voters in a project phase. */
      phaseDelete?: boolean;
      /**
       * Format: int64
       * @description If set to `null`, all voters in the phase will be removed.
       */
      userId?: number;
    };
    DeliverablePayload: {
      /** @enum {string} */
      category: "Compliance" | "Financial Viability" | "GIS" | "Carbon Eligibility" | "Stakeholders and Community Impact" | "Proposed Restoration Activities" | "Verra Non-Permanence Risk Tool (NPRT)" | "Supplemental Files";
      /** @description Optional description of the deliverable in HTML form. */
      descriptionHtml?: string;
      documents: components["schemas"]["SubmissionDocumentPayload"][];
      /** @description If the deliverable has been reviewed, the user-visible feedback from the review. */
      feedback?: string;
      /** Format: int64 */
      id: number;
      /** @description Internal-only comment on the submission. Only present if the current user has accelerator admin privileges. */
      internalComment?: string;
      name: string;
      /** Format: int64 */
      organizationId: number;
      organizationName: string;
      /** Format: int64 */
      participantId: number;
      participantName: string;
      /** Format: int64 */
      projectId: number;
      projectName: string;
      /** @enum {string} */
      status: "Not Submitted" | "In Review" | "Needs Translation" | "Approved" | "Rejected" | "Not Needed";
      /** Format: uri */
      templateUrl?: string;
      /** @enum {string} */
      type: "Document";
    };
    /** @description If the withdrawal was an outplanting to a planting site, the delivery that was created. Not present for other withdrawal purposes. */
    DeliveryPayload: {
      /** Format: int64 */
      id: number;
      /** Format: int64 */
      plantingSiteId: number;
      plantings: components["schemas"]["PlantingPayload"][];
      /** Format: int64 */
      withdrawalId: number;
    };
    DeviceConfig: {
      /**
       * @description Protocol-specific address of device, e.g., an IP address or a Bluetooth device ID.
       * @example 192.168.1.100
       */
      address?: string;
      /**
       * Format: int64
       * @description Identifier of facility where this device is located.
       */
      facilityId: number;
      /**
       * Format: int64
       * @description Unique identifier of this device.
       */
      id: number;
      /**
       * @description Name of device manufacturer.
       * @example InHand Networks
       */
      make: string;
      /**
       * @description Model number or model name of the device.
       * @example IR915L
       */
      model: string;
      /**
       * @description Name of this device.
       * @example BMU-1
       */
      name: string;
      /**
       * Format: int64
       * @description ID of parent device such as a hub or gateway, if any.
       */
      parentId?: number;
      /**
       * Format: int32
       * @description Port number if relevant for the protocol.
       * @example 50000
       */
      port?: number;
      /**
       * @description Device manager protocol name.
       * @example modbus
       */
      protocol?: string;
      settings?: Record<string, never>;
      /**
       * @description High-level type of the device. Device manager may use this in conjunction with the make and model to determine which metrics to report.
       * @example inverter
       */
      type: string;
      /**
       * Format: int32
       * @description Level of diagnostic information to log.
       */
      verbosity?: number;
    };
    DeviceManagerPayload: {
      /** @description If true, this device manager is available to connect to a facility. */
      available: boolean;
      /**
       * Format: int64
       * @description The facility this device manager is connected to, or null if it is not connected.
       */
      facilityId?: number;
      /** Format: int64 */
      id: number;
      /** @description If true, this device manager is currently online. */
      isOnline: boolean;
      /**
       * Format: date-time
       * @description When the device manager's isOnline value changed most recently. In other words, if isOnline is true, the device manager has been online since this time; if isOnline is false, the device manager has been offline since this time. This may be null if the device manager has not come online for the first time yet.
       */
      onlineChangedTime?: string;
      sensorKitId: string;
      /**
       * Format: int32
       * @description If an update is being downloaded or installed, its progress as a percentage. Not present if no update is in progress.
       */
      updateProgress?: number;
    };
    DeviceTemplatePayload: {
      address?: string;
      /** @enum {string} */
      category: "PV" | "Seed Bank Default";
      /** Format: int64 */
      id: number;
      make: string;
      model: string;
      name: string;
      /** Format: int32 */
      port?: number;
      protocol?: string;
      settings?: {
        [key: string]: unknown;
      };
      type: string;
      /** Format: int32 */
      verbosity?: number;
    };
    DeviceUnresponsiveRequestPayload: {
      /**
       * Format: int32
       * @description The expected amount of time between updates from the device. Null or absent if there is no fixed update interval.
       */
      expectedIntervalSecs?: number;
      /**
       * Format: date-time
       * @description When the device most recently responded. Null or absent if the device has never responded.
       */
      lastRespondedTime?: string;
    };
    DraftPlantingSitePayload: {
      /**
       * Format: int64
       * @description ID of the user who created this draft. Only that user is allowed to modify or delete the draft.
       */
      createdBy: number;
      /** Format: date-time */
      createdTime: string;
      /** @description In-progress state of the draft. This includes map data and other information needed by the client. It is treated as opaque data by the server. */
      data: {
        [key: string]: unknown;
      };
      description?: string;
      /** Format: int64 */
      id: number;
      /** Format: date-time */
      modifiedTime: string;
      name: string;
      /**
       * Format: int32
       * @description If the user has started defining planting subzones, the number of subzones defined so far.
       */
      numPlantingSubzones?: number;
      /**
       * Format: int32
       * @description If the user has started defining planting zones, the number of zones defined so far.
       */
      numPlantingZones?: number;
      /** Format: int64 */
      organizationId: number;
      /**
       * Format: int64
       * @description If the draft is associated with a project, its ID.
       */
      projectId?: number;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    ErrorDetails: {
      message: string;
    };
    FacilityPayload: {
      /** Format: date */
      buildCompletedDate?: string;
      /** Format: date */
      buildStartedDate?: string;
      /**
       * Format: int32
       * @description For nursery facilities, the number of plants this nursery is capable of holding.
       */
      capacity?: number;
      /** @enum {string} */
      connectionState: "Not Connected" | "Connected" | "Configured";
      /** Format: date-time */
      createdTime: string;
      description?: string;
      /**
       * Format: int32
       * @description Short numeric identifier for this facility. Facility numbers start at 1 for each facility type in an organization.
       */
      facilityNumber: number;
      /** Format: int64 */
      id: number;
      name: string;
      /** Format: date */
      operationStartedDate?: string;
      /** Format: int64 */
      organizationId: number;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
      /** @enum {string} */
      type: "Seed Bank" | "Desalination" | "Reverse Osmosis" | "Nursery";
    };
    FieldNodePayload: WithRequired<{
      operation: "field";
    } & Omit<components["schemas"]["SearchNodePayload"], "operation"> & ({
      field?: string;
      /** @enum {string} */
      type?: "Exact" | "ExactOrFuzzy" | "Fuzzy" | "Range";
      /** @description List of values to match. For exact and fuzzy searches, a list of at least one value to search for; the list may include null to match accessions where the field does not have a value. For range searches, the list must contain exactly two values, the minimum and maximum; one of the values may be null to search for all values above a minimum or below a maximum. */
      values?: (string | null)[];
    }), "field" | "type" | "values">;
    FieldValuesPayload: {
      /** @description If true, the list of values is too long to return in its entirety and "values" is a partial list. */
      partial: boolean;
      /** @description List of values in the matching accessions. If there are accessions where the field has no value, this list will contain null (an actual null value, not the string "null"). */
      values: (string | null)[];
    };
    Geolocation: {
      accuracy?: number;
      latitude: number;
      longitude: number;
    };
    /** @description GEOMETRY-FIX-TYPE-ON-CLIENT-SIDE */
    Geometry: {
      crs?: components["schemas"]["CRS"];
      /** @enum {string} */
      type: "Point" | "LineString" | "Polygon" | "MultiPoint" | "MultiLineString" | "MultiPolygon" | "GeometryCollection";
    };
    GeometryCollection: WithRequired<{
      type: "GeometryCollection";
    } & Omit<components["schemas"]["Geometry"], "type"> & {
      geometries?: components["schemas"]["Geometry"][];
      /** @enum {string} */
      type?: "GeometryCollection";
    }, "geometries" | "type">;
    GetAccessionHistoryResponsePayload: {
      /** @description History of changes in descending time order (newest first.) */
      history: components["schemas"]["AccessionHistoryEntryPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetAccessionResponsePayloadV2: {
      accession: components["schemas"]["AccessionPayloadV2"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetAutomationResponsePayload: {
      automation: components["schemas"]["AutomationPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetBatchHistoryResponsePayload: {
      history: components["schemas"]["BatchHistoryPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetCurrentTimeResponsePayload: {
      /** Format: date-time */
      currentTime: string;
      status: components["schemas"]["SuccessOrError"];
    };
    GetDeliverableResponsePayload: {
      deliverable: components["schemas"]["DeliverablePayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetDeliveryResponsePayload: {
      delivery: components["schemas"]["DeliveryPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetDeviceManagerResponsePayload: {
      manager: components["schemas"]["DeviceManagerPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetDeviceManagersResponsePayload: {
      /** @description List of device managers that match the conditions in the request. Empty if there were no matches, e.g., the requested short code didn't exist. */
      managers: components["schemas"]["DeviceManagerPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetDeviceResponsePayload: {
      device: components["schemas"]["DeviceConfig"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetDraftPlantingSiteResponsePayload: {
      site: components["schemas"]["DraftPlantingSitePayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetFacilityResponse: {
      facility: components["schemas"]["FacilityPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetMapboxTokenResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      token: string;
    };
    GetNotificationResponsePayload: {
      notification: components["schemas"]["NotificationPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetNotificationsCountResponsePayload: {
      notifications: components["schemas"]["NotificationCountPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetNotificationsResponsePayload: {
      notifications: components["schemas"]["NotificationPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetNurserySummaryResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      summary: components["schemas"]["NurserySummaryPayload"];
    };
    GetNurseryV1: {
      /** Format: date */
      buildCompletedDate?: string;
      buildCompletedDateEditable: boolean;
      /** Format: date */
      buildStartedDate?: string;
      buildStartedDateEditable: boolean;
      /** Format: int32 */
      capacity?: number;
      /** Format: int64 */
      id: number;
      /** Format: int32 */
      mortalityRate: number;
      name: string;
      notes?: string;
      /** Format: date */
      operationStartedDate?: string;
      operationStartedDateEditable: boolean;
      selected: boolean;
      /** Format: int64 */
      totalPlantsPropagated: number;
      /** Format: int64 */
      totalPlantsPropagatedForProject?: number;
      workers: components["schemas"]["WorkersPayloadV1"];
    };
    GetNurseryWithdrawalResponsePayload: {
      batches: components["schemas"]["BatchPayload"][];
      /** @description If the withdrawal was an outplanting to a planting site, the delivery that was created. Not present for other withdrawal purposes. */
      delivery?: components["schemas"]["DeliveryPayload"];
      status: components["schemas"]["SuccessOrError"];
      withdrawal: components["schemas"]["NurseryWithdrawalPayload"];
    };
    GetObservationResponsePayload: {
      observation: components["schemas"]["ObservationPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetObservationResultsResponsePayload: {
      observation: components["schemas"]["ObservationResultsPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetOrganizationResponsePayload: {
      organization: components["schemas"]["OrganizationPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetOrganizationUserResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      user: components["schemas"]["OrganizationUserPayload"];
    };
    GetParticipantResponsePayload: {
      participant: components["schemas"]["ParticipantPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetPlantingSiteReportedPlantsResponsePayload: {
      site: components["schemas"]["PlantingSiteReportedPlantsPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetPlantingSiteResponsePayload: {
      site: components["schemas"]["PlantingSitePayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetPlantingSiteSpeciesV1: {
      /** Format: int64 */
      id: number;
      /** Format: int32 */
      mortalityRateInField?: number;
      /** Format: int32 */
      totalPlanted?: number;
    };
    GetPlantingSiteV1: {
      /** Format: int64 */
      id: number;
      /** Format: int32 */
      mortalityRate?: number;
      name: string;
      notes?: string;
      selected: boolean;
      species: components["schemas"]["GetPlantingSiteSpeciesV1"][];
      /** Format: int32 */
      totalPlantedArea?: number;
      /** Format: int32 */
      totalPlantingSiteArea?: number;
      /** Format: int32 */
      totalPlantsPlanted?: number;
      /** Format: int32 */
      totalTreesPlanted?: number;
      workers: components["schemas"]["WorkersPayloadV1"];
    };
    GetProjectAcceleratorDetailsResponsePayload: {
      details: components["schemas"]["ProjectAcceleratorDetailsPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetProjectResponsePayload: {
      project: components["schemas"]["ProjectPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetProjectScoresResponsePayload: {
      phases: components["schemas"]["PhaseScores"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetProjectVotesResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      votes: components["schemas"]["ProjectVotesPayload"];
    };
    GetReportPayload: {
      /** Format: int64 */
      id: number;
      lockedByName?: string;
      /** Format: int64 */
      lockedByUserId?: number;
      /** Format: date-time */
      lockedTime?: string;
      modifiedByName?: string;
      /** Format: int64 */
      modifiedByUserId?: number;
      /** Format: date-time */
      modifiedTime?: string;
      /** Format: int64 */
      projectId?: number;
      projectName?: string;
      /** Format: int32 */
      quarter: number;
      /** @enum {string} */
      status: "New" | "In Progress" | "Locked" | "Submitted";
      submittedByName?: string;
      /** Format: int64 */
      submittedByUserId?: number;
      /** Format: date-time */
      submittedTime?: string;
      version: string;
      /** Format: int32 */
      year: number;
    };
    GetReportPayloadV1: WithRequired<{
      version: "1";
    } & Omit<components["schemas"]["GetReportPayload"], "version"> & {
      annualDetails?: components["schemas"]["AnnualDetailsPayloadV1"];
      isAnnual?: boolean;
      notes?: string;
      nurseries?: components["schemas"]["GetNurseryV1"][];
      organizationName?: string;
      plantingSites?: components["schemas"]["GetPlantingSiteV1"][];
      seedBanks?: components["schemas"]["GetSeedBankV1"][];
      summaryOfProgress?: string;
      /** Format: int32 */
      totalNurseries?: number;
      /** Format: int32 */
      totalPlantingSites?: number;
      /** Format: int32 */
      totalSeedBanks?: number;
    }, "id" | "isAnnual" | "nurseries" | "organizationName" | "plantingSites" | "quarter" | "seedBanks" | "status" | "totalNurseries" | "totalPlantingSites" | "totalSeedBanks" | "year">;
    GetReportResponsePayload: {
      report: components["schemas"]["GetReportPayloadV1"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetReportSettingsResponsePayload: {
      /** @description If false, settings have not been configured yet and the values in the rest of the payload are the defaults. */
      isConfigured: boolean;
      /** @description If true, organization-level reports are enabled. */
      organizationEnabled: boolean;
      /** @description Per-project report settings. */
      projects: components["schemas"]["ProjectReportSettingsPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetSeedBankV1: {
      /** Format: date */
      buildCompletedDate?: string;
      buildCompletedDateEditable: boolean;
      /** Format: date */
      buildStartedDate?: string;
      buildStartedDateEditable: boolean;
      /** Format: int64 */
      id: number;
      name: string;
      notes?: string;
      /** Format: date */
      operationStartedDate?: string;
      operationStartedDateEditable: boolean;
      selected: boolean;
      /** Format: int64 */
      totalSeedsStored: number;
      /** Format: int64 */
      totalSeedsStoredForProject?: number;
      workers: components["schemas"]["WorkersPayloadV1"];
    };
    GetSpeciesProblemResponsePayload: {
      problem: components["schemas"]["SpeciesProblemElement"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetSpeciesResponsePayload: {
      species: components["schemas"]["SpeciesResponseElement"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetSpeciesSummaryResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      summary: components["schemas"]["SpeciesSummaryPayload"];
    };
    GetSubLocationResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      subLocation: components["schemas"]["SubLocationPayload"];
    };
    GetTimeseriesHistoryRequestPayload: {
      /**
       * Format: int32
       * @description Number of values to return. The time range is divided into this many equal intervals, and a value is returned from each interval if available.
       */
      count: number;
      /**
       * Format: date-time
       * @description End of time range to query. If this is non-null, startTime must also be specified, and seconds must be null or absent.
       */
      endTime?: string;
      /**
       * Format: int64
       * @description Number of seconds in the past to start the time range. If this is non-null, startTime and endTime must be null or absent.
       */
      seconds?: number;
      /**
       * Format: date-time
       * @description Start of time range to query. If this is non-null, endTime must also be specified, and seconds must be null or absent.
       */
      startTime?: string;
      /** @description Timeseries to query. May be from different devices. */
      timeseries: components["schemas"]["TimeseriesIdPayload"][];
    };
    GetTimeseriesHistoryResponsePayload: {
      values: components["schemas"]["TimeseriesValuesPayload"][];
    };
    GetUploadStatusDetailsPayload: {
      errors?: components["schemas"]["UploadProblemPayload"][];
      /** @description True if the server is finished processing the file, either successfully or not. */
      finished: boolean;
      /** Format: int64 */
      id: number;
      /** @enum {string} */
      status: "Receiving" | "Validating" | "Processing" | "Completed" | "Processing Failed" | "Invalid" | "Receiving Failed" | "Awaiting Validation" | "Awaiting User Action" | "Awaiting Processing";
      warnings?: components["schemas"]["UploadProblemPayload"][];
    };
    GetUploadStatusResponsePayload: {
      details: components["schemas"]["GetUploadStatusDetailsPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetUserPreferencesResponsePayload: {
      /** @description The user's preferences, or null if no preferences have been stored yet. */
      preferences?: {
        [key: string]: unknown;
      };
      status: components["schemas"]["SuccessOrError"];
    };
    GetUserResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      user: components["schemas"]["UserProfilePayload"];
    };
    GetViabilityTestPayload: {
      /** Format: int64 */
      accessionId: number;
      /** Format: date */
      endDate?: string;
      /** Format: int64 */
      id: number;
      notes?: string;
      /** @enum {string} */
      seedType?: "Fresh" | "Stored";
      /** Format: int32 */
      seedsCompromised?: number;
      /** Format: int32 */
      seedsEmpty?: number;
      /** Format: int32 */
      seedsFilled?: number;
      /** Format: int32 */
      seedsTested: number;
      /** Format: date */
      startDate?: string;
      /** @enum {string} */
      substrate?: "Nursery Media" | "Agar" | "Paper" | "Other" | "Sand" | "Media Mix" | "Soil" | "Moss" | "Perlite/Vermiculite" | "None";
      testResults?: components["schemas"]["ViabilityTestResultPayload"][];
      /** @enum {string} */
      testType: "Lab" | "Nursery" | "Cut";
      /** Format: int32 */
      totalSeedsGerminated?: number;
      /** @enum {string} */
      treatment?: "Soak" | "Scarify" | "Chemical" | "Stratification" | "Other" | "Light";
      /**
       * Format: int32
       * @description Server-calculated viability percent for this test. For lab and nursery tests, this is based on the total seeds germinated across all test results. For cut tests, it is based on the number of seeds filled.
       */
      viabilityPercent?: number;
      /** @description Full name of user who withdrew seeds to perform the test. */
      withdrawnByName?: string;
      /**
       * Format: int64
       * @description ID of user who withdrew seeds to perform the test.
       */
      withdrawnByUserId?: number;
    };
    GetViabilityTestResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      viabilityTest: components["schemas"]["GetViabilityTestPayload"];
    };
    GetWithdrawalPayload: {
      /** Format: date */
      date: string;
      /**
       * Format: int32
       * @description Number of seeds withdrawn. Calculated by server. This is an estimate if "withdrawnQuantity" is a weight quantity and the accession has subset weight and count data. Absent if "withdrawnQuantity" is a weight quantity and the accession has no subset weight and count.
       */
      estimatedCount?: number;
      /** @description Weight of seeds withdrawn. Calculated by server. This is an estimate if "withdrawnQuantity" is a seed count and the accession has subset weight and count data. Absent if "withdrawnQuantity" is a seed count and the accession has no subset weight and count. */
      estimatedWeight?: components["schemas"]["SeedQuantityPayload"];
      /**
       * Format: int64
       * @description Server-assigned unique ID of this withdrawal.
       */
      id?: number;
      notes?: string;
      /** @enum {string} */
      purpose?: "Other" | "Viability Testing" | "Out-planting" | "Nursery";
      /**
       * Format: int64
       * @description If this withdrawal is of purpose "Viability Testing", the ID of the test it is associated with.
       */
      viabilityTestId?: number;
      /** @description Full name of the person who withdrew the seeds. V1 COMPATIBILITY: This is the "staffResponsible" v1 field, which may not be the name of an organization user. */
      withdrawnByName?: string;
      /**
       * Format: int64
       * @description ID of the user who withdrew the seeds. Only present if the current user has permission to list the users in the organization. V1 COMPATIBILITY: Also absent if the withdrawal was written with the v1 API and we haven't yet written the code to figure out which user ID to assign.
       */
      withdrawnByUserId?: number;
      /** @description Quantity of seeds withdrawn. For viability testing withdrawals, this is always the same as the test's "seedsTested" value. */
      withdrawnQuantity?: components["schemas"]["SeedQuantityPayload"];
    };
    GetWithdrawalResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      withdrawal: components["schemas"]["GetWithdrawalPayload"];
    };
    GetWithdrawalsResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      withdrawals: components["schemas"]["GetWithdrawalPayload"][];
    };
    GlobalRoleUsersListResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      users: components["schemas"]["UserWithGlobalRolesPayload"][];
    };
    GoalProgressPayloadV1: {
      /** @enum {string} */
      goal: "NoPoverty" | "ZeroHunger" | "GoodHealth" | "QualityEducation" | "GenderEquality" | "CleanWater" | "AffordableEnergy" | "DecentWork" | "Industry" | "ReducedInequalities" | "SustainableCities" | "ResponsibleConsumption" | "ClimateAction" | "LifeBelowWater" | "LifeOnLand" | "Peace" | "Partnerships";
      progress?: string;
    };
    LineString: WithRequired<{
      type: "LineString";
    } & Omit<components["schemas"]["Geometry"], "type"> & {
      coordinates?: number[][];
      /** @enum {string} */
      type?: "LineString";
    }, "coordinates" | "type">;
    ListAcceleratorOrganizationsResponsePayload: {
      organizations: components["schemas"]["AcceleratorOrganizationPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListAllFieldValuesRequestPayload: {
      fields: string[];
      /** Format: int64 */
      organizationId: number;
    };
    ListAllFieldValuesResponsePayload: {
      results: {
        [key: string]: components["schemas"]["AllFieldValuesPayload"];
      };
      status: components["schemas"]["SuccessOrError"];
    };
    ListAssignedPlotsResponsePayload: {
      plots: components["schemas"]["AssignedPlotPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListAutomationsResponsePayload: {
      automations: components["schemas"]["AutomationPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListBatchPhotosResponsePayload: {
      photos: components["schemas"]["BatchPhotoPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListDeliverablesElement: {
      /** @enum {string} */
      category: "Compliance" | "Financial Viability" | "GIS" | "Carbon Eligibility" | "Stakeholders and Community Impact" | "Proposed Restoration Activities" | "Verra Non-Permanence Risk Tool (NPRT)" | "Supplemental Files";
      /** @description Optional description of the deliverable in HTML form. */
      descriptionHtml?: string;
      /** Format: int64 */
      id: number;
      name: string;
      /**
       * Format: int32
       * @description Number of documents submitted for this deliverable. Only valid for deliverables of type Document.
       */
      numDocuments?: number;
      /** Format: int64 */
      organizationId: number;
      organizationName: string;
      /** Format: int64 */
      participantId: number;
      participantName: string;
      /** Format: int64 */
      projectId: number;
      projectName: string;
      /** @enum {string} */
      status: "Not Submitted" | "In Review" | "Needs Translation" | "Approved" | "Rejected" | "Not Needed";
      /** @enum {string} */
      type: "Document";
    };
    ListDeliverablesResponsePayload: {
      deliverables: components["schemas"]["ListDeliverablesElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListDeviceConfigsResponse: {
      devices: components["schemas"]["DeviceConfig"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListDeviceTemplatesResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      templates: components["schemas"]["DeviceTemplatePayload"][];
    };
    ListFacilitiesResponse: {
      facilities: components["schemas"]["FacilityPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListFieldValuesRequestPayload: {
      /** Format: int64 */
      facilityId?: number;
      fields: string[];
      /** Format: int64 */
      organizationId?: number;
      search?: components["schemas"]["AndNodePayload"] | components["schemas"]["FieldNodePayload"] | components["schemas"]["NotNodePayload"] | components["schemas"]["OrNodePayload"];
    };
    ListFieldValuesResponsePayload: {
      results: {
        [key: string]: components["schemas"]["FieldValuesPayload"];
      };
      status: components["schemas"]["SuccessOrError"];
    };
    ListObservationResultsResponsePayload: {
      observations: components["schemas"]["ObservationResultsPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListObservationsResponsePayload: {
      observations: components["schemas"]["ObservationPayload"][];
      status: components["schemas"]["SuccessOrError"];
      /**
       * Format: int32
       * @description Total number of monitoring plots that haven't been completed yet across all current observations.
       */
      totalIncompletePlots: number;
      /**
       * Format: int32
       * @description Total number of monitoring plots that haven't been claimed yet across all current observations.
       */
      totalUnclaimedPlots: number;
    };
    ListOrganizationRolesResponsePayload: {
      roles: components["schemas"]["OrganizationRolePayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListOrganizationUsersResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      users: components["schemas"]["OrganizationUserPayload"][];
    };
    ListOrganizationsResponsePayload: {
      organizations: components["schemas"]["OrganizationPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListPhotosResponseElement: {
      filename: string;
      /** Format: int64 */
      size: number;
    };
    ListPhotosResponsePayload: {
      photos: components["schemas"]["ListPhotosResponseElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListPlantingSitesResponsePayload: {
      sites: components["schemas"]["PlantingSitePayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListPlantingSubzoneSpeciesResponsePayload: {
      species: components["schemas"]["PlantingSubzoneSpeciesPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListProjectsResponsePayload: {
      projects: components["schemas"]["ProjectPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListReportFilesResponseElement: {
      filename: string;
      /** Format: int64 */
      id: number;
    };
    ListReportFilesResponsePayload: {
      files: components["schemas"]["ListReportFilesResponseElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListReportPhotosResponseElement: {
      caption?: string;
      filename: string;
      /** Format: int64 */
      id: number;
    };
    ListReportPhotosResponsePayload: {
      photos: components["schemas"]["ListReportPhotosResponseElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListReportsResponseElement: {
      /** Format: int64 */
      id: number;
      lockedByName?: string;
      /** Format: int64 */
      lockedByUserId?: number;
      /** Format: date-time */
      lockedTime?: string;
      modifiedByName?: string;
      /** Format: int64 */
      modifiedByUserId?: number;
      /** Format: date-time */
      modifiedTime?: string;
      /** Format: int64 */
      projectId?: number;
      projectName?: string;
      /** Format: int32 */
      quarter: number;
      /** @enum {string} */
      status: "New" | "In Progress" | "Locked" | "Submitted";
      submittedByName?: string;
      /** Format: int64 */
      submittedByUserId?: number;
      /** Format: date-time */
      submittedTime?: string;
      /** Format: int32 */
      year: number;
    };
    ListReportsResponsePayload: {
      reports: components["schemas"]["ListReportsResponseElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListSpeciesResponsePayload: {
      species: components["schemas"]["SpeciesResponseElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListSubLocationsResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      subLocations: components["schemas"]["SubLocationPayload"][];
    };
    ListTimeZoneNamesResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      timeZones: components["schemas"]["TimeZonePayload"][];
    };
    ListTimeseriesResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      timeseries: components["schemas"]["TimeseriesPayload"][];
    };
    ListViabilityTestsResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      viabilityTests: components["schemas"]["GetViabilityTestPayload"][];
    };
    ListWithdrawalPhotosResponsePayload: {
      photos: components["schemas"]["NurseryWithdrawalPhotoPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    MultiLineString: WithRequired<{
      type: "MultiLineString";
    } & Omit<components["schemas"]["Geometry"], "type"> & {
      coordinates?: number[][][];
      /** @enum {string} */
      type?: "MultiLineString";
    }, "coordinates" | "type">;
    MultiPoint: WithRequired<{
      type: "MultiPoint";
    } & Omit<components["schemas"]["Geometry"], "type"> & {
      coordinates?: number[][];
      /** @enum {string} */
      type?: "MultiPoint";
    }, "coordinates" | "type">;
    MultiPolygon: WithRequired<{
      type: "MultiPolygon";
    } & Omit<components["schemas"]["Geometry"], "type"> & {
      coordinates?: number[][][][];
      /** @enum {string} */
      type?: "MultiPolygon";
    }, "coordinates" | "type">;
    NewPlantingSeasonPayload: {
      /** Format: date */
      endDate: string;
      /** Format: date */
      startDate: string;
    };
    /** @description Search criterion that matches results that do not match a set of search criteria. */
    NotNodePayload: WithRequired<{
      operation: "not";
    } & Omit<components["schemas"]["SearchNodePayload"], "operation"> & {
      child?: components["schemas"]["SearchNodePayload"];
    }, "child">;
    NotificationCountPayload: {
      /** Format: int64 */
      organizationId?: number;
      /** Format: int32 */
      unread: number;
    };
    NotificationPayload: {
      body: string;
      /** Format: date-time */
      createdTime: string;
      /** Format: int64 */
      id: number;
      isRead: boolean;
      /** Format: uri */
      localUrl: string;
      /** @enum {string} */
      notificationCriticality: "Info" | "Warning" | "Error" | "Success";
      /** Format: int64 */
      organizationId?: number;
      title: string;
    };
    NurserySummaryPayload: {
      /** Format: int64 */
      germinatingQuantity: number;
      /** Format: int32 */
      germinationRate?: number;
      /**
       * Format: int32
       * @description Percentage of current and past inventory that was withdrawn due to death.
       */
      lossRate?: number;
      /** Format: int64 */
      notReadyQuantity: number;
      /** Format: int64 */
      readyQuantity: number;
      /** @description Species currently present in the nursery. */
      species: components["schemas"]["NurserySummarySpeciesPayload"][];
      /**
       * Format: int64
       * @description Total number of plants that have been withdrawn due to death.
       */
      totalDead: number;
      /**
       * Format: int64
       * @description Total number of germinated plants currently in inventory.
       */
      totalQuantity: number;
      /**
       * Format: int64
       * @description Total number of plants that have been withdrawn in the past.
       */
      totalWithdrawn: number;
    };
    NurserySummarySpeciesPayload: {
      /** Format: int64 */
      id: number;
      scientificName: string;
    };
    NurseryWithdrawalPayload: {
      batchWithdrawals: components["schemas"]["BatchWithdrawalPayload"][];
      /**
       * Format: int64
       * @description If purpose is "Nursery Transfer", the ID of the facility to which the seedlings were transferred.
       */
      destinationFacilityId?: number;
      /** Format: int64 */
      facilityId: number;
      /** Format: int64 */
      id: number;
      notes?: string;
      /** @enum {string} */
      purpose: "Nursery Transfer" | "Dead" | "Out Plant" | "Other";
      /** Format: date */
      withdrawnDate: string;
    };
    NurseryWithdrawalPhotoPayload: {
      /** Format: int64 */
      id: number;
    };
    ObservationMonitoringPlotCoordinatesPayload: {
      gpsCoordinates: components["schemas"]["Point"];
      /** @enum {string} */
      position: "SouthwestCorner" | "SoutheastCorner" | "NortheastCorner" | "NorthwestCorner";
    };
    ObservationMonitoringPlotPhotoPayload: {
      /** Format: int64 */
      fileId: number;
      gpsCoordinates: components["schemas"]["Point"];
      /** @enum {string} */
      position: "SouthwestCorner" | "SoutheastCorner" | "NortheastCorner" | "NorthwestCorner";
    };
    ObservationMonitoringPlotResultsPayload: {
      boundary: components["schemas"]["Polygon"];
      claimedByName?: string;
      /** Format: int64 */
      claimedByUserId?: number;
      /** Format: date-time */
      completedTime?: string;
      /** @description Observed coordinates, if any, up to one per position. */
      coordinates: components["schemas"]["ObservationMonitoringPlotCoordinatesPayload"][];
      /** @description True if this was a permanent monitoring plot in this observation. Clients should not assume that the set of permanent monitoring plots is the same in all observations; the number of permanent monitoring plots can be adjusted over time based on observation results. */
      isPermanent: boolean;
      /** Format: int64 */
      monitoringPlotId: number;
      /** @description Full name of this monitoring plot, including zone and subzone prefixes. */
      monitoringPlotName: string;
      /**
       * Format: int32
       * @description If this is a permanent monitoring plot in this observation, percentage of plants of all species that were dead.
       */
      mortalityRate?: number;
      notes?: string;
      photos: components["schemas"]["ObservationMonitoringPlotPhotoPayload"][];
      /**
       * Format: int32
       * @description Number of live plants per hectare.
       */
      plantingDensity: number;
      species: components["schemas"]["ObservationSpeciesResultsPayload"][];
      /** @enum {string} */
      status: "Outstanding" | "InProgress" | "Completed";
      /**
       * Format: int32
       * @description Total number of plants recorded. Includes all plants, regardless of live/dead status or species.
       */
      totalPlants: number;
      /**
       * Format: int32
       * @description Total number of species observed, not counting dead plants. Includes plants with Known and Other certainties. In the case of Other, each distinct user-supplied species name is counted as a separate species for purposes of this total.
       */
      totalSpecies: number;
    };
    ObservationPayload: {
      /**
       * Format: date
       * @description Date this observation is scheduled to end.
       */
      endDate: string;
      /** Format: int64 */
      id: number;
      /**
       * Format: int32
       * @description Total number of monitoring plots that haven't been completed yet. Includes both claimed and unclaimed plots.
       */
      numIncompletePlots: number;
      /**
       * Format: int32
       * @description Total number of monitoring plots in observation, regardless of status.
       */
      numPlots: number;
      /**
       * Format: int32
       * @description Total number of monitoring plots that haven't been claimed yet.
       */
      numUnclaimedPlots: number;
      /** Format: int64 */
      plantingSiteId: number;
      plantingSiteName: string;
      /**
       * Format: date
       * @description Date this observation started.
       */
      startDate: string;
      /** @enum {string} */
      state: "Upcoming" | "InProgress" | "Completed" | "Overdue";
    };
    ObservationPlantingSubzoneResultsPayload: {
      monitoringPlots: components["schemas"]["ObservationMonitoringPlotResultsPayload"][];
      /** Format: int64 */
      plantingSubzoneId: number;
    };
    ObservationPlantingZoneResultsPayload: {
      /** @description Area of this planting zone in hectares. */
      areaHa: number;
      /** Format: date-time */
      completedTime?: string;
      /**
       * Format: int32
       * @description Estimated number of plants in planting zone based on estimated planting density and planting zone area. Only present if all the subzones in the zone have been marked as having completed planting.
       */
      estimatedPlants?: number;
      /**
       * Format: int32
       * @description Percentage of plants of all species that were dead in this zone's permanent monitoring plots.
       */
      mortalityRate: number;
      /**
       * Format: int32
       * @description Estimated planting density for the zone based on the observed planting densities of monitoring plots. Only present if all the subzones in the zone have been marked as having completed planting.
       */
      plantingDensity?: number;
      plantingSubzones: components["schemas"]["ObservationPlantingSubzoneResultsPayload"][];
      /** Format: int64 */
      plantingZoneId: number;
      species: components["schemas"]["ObservationSpeciesResultsPayload"][];
      /**
       * Format: int32
       * @description Total number of plants recorded. Includes all plants, regardless of live/dead status or species.
       */
      totalPlants: number;
      /**
       * Format: int32
       * @description Total number of species observed, not counting dead plants. Includes plants with Known and Other certainties. In the case of Other, each distinct user-supplied species name is counted as a separate species for purposes of this total.
       */
      totalSpecies: number;
    };
    ObservationResultsPayload: {
      /** Format: date-time */
      completedTime?: string;
      /**
       * Format: int32
       * @description Estimated total number of live plants at the site, based on the estimated planting density and site size. Only present if all the subzones in the site have been marked as having completed planting.
       */
      estimatedPlants?: number;
      /**
       * Format: int32
       * @description Percentage of plants of all species that were dead in this site's permanent monitoring plots.
       */
      mortalityRate: number;
      /** Format: int64 */
      observationId: number;
      /**
       * Format: int32
       * @description Estimated planting density for the site, based on the observed planting densities of monitoring plots. Only present if all the subzones in the site have been marked as having completed planting.
       */
      plantingDensity?: number;
      /** Format: int64 */
      plantingSiteId: number;
      plantingZones: components["schemas"]["ObservationPlantingZoneResultsPayload"][];
      species: components["schemas"]["ObservationSpeciesResultsPayload"][];
      /** Format: date */
      startDate: string;
      /** @enum {string} */
      state: "Upcoming" | "InProgress" | "Completed" | "Overdue";
      /** Format: int32 */
      totalSpecies: number;
    };
    ObservationSpeciesResultsPayload: {
      /** @enum {string} */
      certainty: "Known" | "Other" | "Unknown";
      /**
       * Format: int32
       * @description Number of dead plants observed in permanent monitoring plots in all observations including this one. 0 if this is a plot-level result for a temporary monitoring plot.
       */
      cumulativeDead: number;
      /**
       * Format: int32
       * @description Percentage of plants in permanent monitoring plots that are dead. If there are no permanent monitoring plots (or if this is a plot-level result for a temporary monitoring plot) this will be null.
       */
      mortalityRate?: number;
      /**
       * Format: int32
       * @description Number of live plants observed in permanent plots in this observation, not including existing plants. 0 if ths is a plot-level result for a temporary monitoring plot.
       */
      permanentLive: number;
      /**
       * Format: int64
       * @description If certainty is Known, the ID of the species. Null if certainty is Other or Unknown.
       */
      speciesId?: number;
      /** @description If certainty is Other, the user-supplied name of the species. Null if certainty is Known or Unknown. */
      speciesName?: string;
      /**
       * Format: int32
       * @description Total number of live and existing plants of this species.
       */
      totalPlants: number;
    };
    /** @description Search criterion that matches results that meet any of a set of other search criteria. That is, if the list of children is x, y, and z, this will require x OR y OR z. */
    OrNodePayload: WithRequired<{
      operation: "or";
    } & Omit<components["schemas"]["SearchNodePayload"], "operation"> & {
      /** @description List of criteria at least one of which must be satisfied */
      children?: components["schemas"]["SearchNodePayload"][];
    }, "children">;
    OrganizationPayload: {
      /** @description Whether this organization can submit reports to Terraformation. */
      canSubmitReports: boolean;
      /**
       * @description ISO 3166 alpha-2 code of organization's country.
       * @example AU
       */
      countryCode?: string;
      /**
       * @description ISO 3166-2 code of organization's country subdivision (state, province, region, etc.) This is the full ISO 3166-2 code including the country prefix. If this is set, countryCode will also be set.
       * @example US-HI
       */
      countrySubdivisionCode?: string;
      /** Format: date-time */
      createdTime: string;
      description?: string;
      /** @description This organization's facilities. Only included if depth is "Facility". */
      facilities?: components["schemas"]["FacilityPayload"][];
      /** Format: int64 */
      id: number;
      name: string;
      /** @enum {string} */
      organizationType?: "Government" | "NGO" | "Arboreta" | "Academia" | "ForProfit" | "Other";
      organizationTypeDetails?: string;
      /**
       * @description The current user's role in the organization. Absent if the current user is not a member of the organization but is able to read it thanks to a global role.
       * @enum {string}
       */
      role?: "Contributor" | "Manager" | "Admin" | "Owner" | "Terraformation Contact";
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
      /**
       * Format: int32
       * @description The total number of users in the organization, including the current user.
       */
      totalUsers: number;
      website?: string;
    };
    OrganizationRolePayload: {
      /** @enum {string} */
      role: "Contributor" | "Manager" | "Admin" | "Owner" | "Terraformation Contact";
      /**
       * Format: int32
       * @description Total number of users in the organization with this role.
       */
      totalUsers: number;
    };
    OrganizationUserPayload: {
      /**
       * Format: date-time
       * @description Date and time the user was added to the organization.
       */
      addedTime: string;
      email: string;
      /** @description The user's first name. Not present if the user has been added to the organization but has not signed up for an account yet. */
      firstName?: string;
      /** Format: int64 */
      id: number;
      /** @description The user's last name. Not present if the user has been added to the organization but has not signed up for an account yet. */
      lastName?: string;
      /** @enum {string} */
      role: "Contributor" | "Manager" | "Admin" | "Owner" | "Terraformation Contact";
    };
    ParticipantPayload: {
      /** Format: int64 */
      cohortId?: number;
      cohortName?: string;
      /** @enum {string} */
      cohortPhase?: "Phase 0 - Due Diligence" | "Phase 1 - Feasibility Study" | "Phase 2 - Plan and Scale" | "Phase 3 - Implement and Monitor";
      /** Format: int64 */
      id: number;
      name: string;
      projects: components["schemas"]["ParticipantProjectPayload"][];
    };
    ParticipantProjectPayload: {
      /** Format: int64 */
      organizationId: number;
      organizationName: string;
      /** Format: int64 */
      projectId: number;
      projectName: string;
    };
    PhaseScores: {
      /** @enum {string} */
      phase: "Phase 0 - Due Diligence" | "Phase 1 - Feasibility Study" | "Phase 2 - Plan and Scale" | "Phase 3 - Implement and Monitor";
      scores: components["schemas"]["Score"][];
      totalScore?: number;
    };
    PhaseVotes: {
      /** @enum {string} */
      decision?: "No" | "Conditional" | "Yes";
      /** @enum {string} */
      phase: "Phase 0 - Due Diligence" | "Phase 1 - Feasibility Study" | "Phase 2 - Plan and Scale" | "Phase 3 - Implement and Monitor";
      votes: components["schemas"]["VoteSelection"][];
    };
    PlantingPayload: {
      /** Format: int64 */
      id: number;
      /** @description If type is "Reassignment To", the reassignment notes, if any. */
      notes?: string;
      /**
       * Format: int32
       * @description Number of plants planted or reassigned. If type is "Reassignment From", this will be negative.
       */
      numPlants: number;
      /** Format: int64 */
      plantingSubzoneId?: number;
      /** Format: int64 */
      speciesId: number;
      /** @enum {string} */
      type: "Delivery" | "Reassignment From" | "Reassignment To";
    };
    PlantingSeasonPayload: {
      /** Format: date */
      endDate: string;
      /** Format: int64 */
      id: number;
      /** Format: date */
      startDate: string;
    };
    PlantingSitePayload: {
      /** @description Area of planting site in hectares. Only present if the site has planting zones. */
      areaHa?: number;
      boundary?: components["schemas"]["MultiPolygon"];
      description?: string;
      exclusion?: components["schemas"]["MultiPolygon"];
      /** Format: int64 */
      id: number;
      name: string;
      /** Format: int64 */
      organizationId: number;
      plantingSeasons: components["schemas"]["PlantingSeasonPayload"][];
      plantingZones?: components["schemas"]["PlantingZonePayload"][];
      /** Format: int64 */
      projectId?: number;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    PlantingSiteReportedPlantsPayload: {
      /** Format: int64 */
      id: number;
      plantingZones: components["schemas"]["PlantingZoneReportedPlantsPayload"][];
      /** Format: int32 */
      plantsSinceLastObservation: number;
      /** Format: int32 */
      progressPercent?: number;
      /** Format: int32 */
      totalPlants: number;
    };
    PlantingSubzonePayload: {
      /** @description Area of planting subzone in hectares. */
      areaHa: number;
      boundary: components["schemas"]["MultiPolygon"];
      fullName: string;
      /** Format: int64 */
      id: number;
      name: string;
      plantingCompleted: boolean;
      /**
       * Format: date-time
       * @description When planting of the planting subzone was marked as completed.
       */
      plantingCompletedTime?: string;
    };
    PlantingSubzoneSpeciesPayload: {
      commonName?: string;
      /** Format: int64 */
      id: number;
      scientificName: string;
    };
    PlantingZonePayload: {
      /** @description Area of planting zone in hectares. */
      areaHa: number;
      boundary: components["schemas"]["MultiPolygon"];
      /** Format: int64 */
      id: number;
      name: string;
      plantingSubzones: components["schemas"]["PlantingSubzonePayload"][];
      targetPlantingDensity: number;
    };
    PlantingZoneReportedPlantsPayload: {
      /** Format: int64 */
      id: number;
      /** Format: int32 */
      plantsSinceLastObservation: number;
      /** Format: int32 */
      progressPercent: number;
      /** Format: int32 */
      totalPlants: number;
    };
    Point: WithRequired<{
      type: "Point";
    } & Omit<components["schemas"]["Geometry"], "type"> & {
      /**
       * @description A single position consisting of X and Y values in the coordinate system specified by the crs field.
       * @example [
       *   120,
       *   -9.53
       * ]
       */
      coordinates?: number[];
      /** @enum {string} */
      type?: "Point";
    }, "coordinates" | "type">;
    Polygon: WithRequired<{
      type: "Polygon";
    } & Omit<components["schemas"]["Geometry"], "type"> & {
      coordinates?: number[][][];
      /** @enum {string} */
      type?: "Polygon";
    }, "coordinates" | "type">;
    ProjectAcceleratorDetailsPayload: {
      abbreviatedName?: string;
      applicationReforestableLand?: number;
      confirmedReforestableLand?: number;
      countryCode?: string;
      dealDescription?: string;
      /** @enum {string} */
      dealStage?: "Phase 0 (Doc Review)" | "Phase 1" | "Phase 2" | "Phase 3" | "Graduated, Finished Planting" | "Non Graduate" | "Application Submitted" | "Project Lead Screening Review" | "Screening Questions Ready for Review" | "Carbon Pre-Check" | "Submission Requires Follow Up" | "Carbon Eligible" | "Closed Lost" | "Issue Active" | "Issue Pending" | "Issue Reesolved";
      failureRisk?: string;
      investmentThesis?: string;
      landUseModelTypes: ("Native Forest" | "Monoculture" | "Sustainable Timber" | "Other Timber" | "Mangroves" | "Agroforestry" | "Silvopasture" | "Other Land-Use Model")[];
      maxCarbonAccumulation?: number;
      minCarbonAccumulation?: number;
      /** Format: int32 */
      numCommunities?: number;
      /** Format: int32 */
      numNativeSpecies?: number;
      perHectareBudget?: number;
      /** @enum {string} */
      pipeline?: "Accelerator Projects" | "Carbon Supply" | "Carbon Waitlist";
      /** Format: int64 */
      projectId: number;
      projectLead?: string;
      /** @enum {string} */
      region?: "Antarctica" | ("East Asia & Pacific") | ("Europe & Central Asia") | ("Latin America & Caribbean") | ("Middle East & North Africa") | "North America" | "Oceania" | "South Asia" | "Sub-Saharan Africa";
      totalExpansionPotential?: number;
      whatNeedsToBeTrue?: string;
    };
    ProjectPayload: {
      /** Format: int64 */
      createdBy?: number;
      /** Format: date-time */
      createdTime?: string;
      description?: string;
      /** Format: int64 */
      id: number;
      /** Format: int64 */
      modifiedBy?: number;
      /** Format: date-time */
      modifiedTime?: string;
      name: string;
      /** Format: int64 */
      organizationId: number;
    };
    ProjectReportSettingsPayload: {
      /** @description If true, reports are enabled for this project. */
      isEnabled: boolean;
      /** Format: int64 */
      projectId: number;
    };
    ProjectVotesPayload: {
      phases: components["schemas"]["PhaseVotes"][];
    };
    PutNurseryV1: {
      /** Format: date */
      buildCompletedDate?: string;
      /** Format: date */
      buildStartedDate?: string;
      /** Format: int32 */
      capacity?: number;
      /** Format: int64 */
      id: number;
      notes?: string;
      /** Format: date */
      operationStartedDate?: string;
      selected: boolean;
      workers: components["schemas"]["WorkersPayloadV1"];
    };
    PutPlantingSiteSpeciesV1: {
      /** Format: int64 */
      id: number;
      /** Format: int32 */
      mortalityRateInField?: number;
      /** Format: int32 */
      totalPlanted?: number;
    };
    PutPlantingSiteV1: {
      /** Format: int64 */
      id: number;
      /** Format: int32 */
      mortalityRate?: number;
      notes?: string;
      selected: boolean;
      species: components["schemas"]["PutPlantingSiteSpeciesV1"][];
      /** Format: int32 */
      totalPlantedArea?: number;
      /** Format: int32 */
      totalPlantingSiteArea?: number;
      /** Format: int32 */
      totalPlantsPlanted?: number;
      /** Format: int32 */
      totalTreesPlanted?: number;
      workers: components["schemas"]["WorkersPayloadV1"];
    };
    PutReportPayload: {
      version: string;
    };
    PutReportPayloadV1: WithRequired<{
      version: "1";
    } & Omit<components["schemas"]["PutReportPayload"], "version"> & {
      annualDetails?: components["schemas"]["AnnualDetailsPayloadV1"];
      notes?: string;
      nurseries?: components["schemas"]["PutNurseryV1"][];
      plantingSites?: components["schemas"]["PutPlantingSiteV1"][];
      seedBanks?: components["schemas"]["PutSeedBankV1"][];
      summaryOfProgress?: string;
    }, "nurseries" | "plantingSites" | "seedBanks">;
    PutReportRequestPayload: {
      report: components["schemas"]["PutReportPayloadV1"];
    };
    PutSeedBankV1: {
      /** Format: date */
      buildCompletedDate?: string;
      /** Format: date */
      buildStartedDate?: string;
      /** Format: int64 */
      id: number;
      notes?: string;
      /** Format: date */
      operationStartedDate?: string;
      selected: boolean;
      workers: components["schemas"]["WorkersPayloadV1"];
    };
    ReassignDeliveryRequestPayload: {
      reassignments: components["schemas"]["ReassignmentPayload"][];
    };
    ReassignmentPayload: {
      /** Format: int64 */
      fromPlantingId: number;
      notes?: string;
      /**
       * Format: int32
       * @description Number of plants to reassign from the planting's original subzone to the new one. Must be less than or equal to the number of plants in the original planting.
       */
      numPlants: number;
      /** Format: int64 */
      toPlantingSubzoneId: number;
    };
    RecordTimeseriesValuesRequestPayload: {
      timeseries: components["schemas"]["TimeseriesValuesPayload"][];
    };
    /** @description Results of a request to record timeseries values. */
    RecordTimeseriesValuesResponsePayload: {
      error?: components["schemas"]["ErrorDetails"];
      /** @description List of values that the server failed to record. Will not be included if all the values were recorded successfully. */
      failures?: components["schemas"]["TimeseriesValuesErrorPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    RecordedPlantPayload: {
      /** @enum {string} */
      certainty: "Known" | "Other" | "Unknown";
      /** @description GPS coordinates where plant was observed. */
      gpsCoordinates: components["schemas"]["Point"];
      /**
       * Format: int64
       * @description Required if certainty is Known. Ignored if certainty is Other or Unknown.
       */
      speciesId?: number;
      /** @description If certainty is Other, the optional user-supplied name of the species. Ignored if certainty is Known or Unknown. */
      speciesName?: string;
      /** @enum {string} */
      status: "Live" | "Dead" | "Existing";
    };
    ReplaceObservationPlotRequestPayload: {
      /** @enum {string} */
      duration: "Temporary" | "LongTerm";
      justification: string;
    };
    ReplaceObservationPlotResponsePayload: {
      /** @description IDs of monitoring plots that were added to the observation. Empty if no plots were added. */
      addedMonitoringPlotIds: number[];
      /** @description IDs of monitoring plots that were removed from the observation. Will usually include the requested plot ID, but may be empty if the replacement request couldn't be satisfied. */
      removedMonitoringPlotIds: number[];
      status: components["schemas"]["SuccessOrError"];
    };
    RescheduleObservationRequestPayload: {
      /**
       * Format: date
       * @description The end date for this observation, should be limited to 2 months from the start date .
       */
      endDate: string;
      /**
       * Format: date
       * @description The start date for this observation, can be up to a year from the date this schedule request occurs on.
       */
      startDate: string;
    };
    ResolveUploadRequestPayload: {
      /** @description If true, the data for entries that already exist will be overwritten with the values in the uploaded file. If false, only entries that don't already exist will be imported. */
      overwriteExisting: boolean;
    };
    ScheduleObservationRequestPayload: {
      /**
       * Format: date
       * @description The end date for this observation, should be limited to 2 months from the start date .
       */
      endDate: string;
      /**
       * Format: int64
       * @description Which planting site this observation needs to be scheduled for.
       */
      plantingSiteId: number;
      /**
       * Format: date
       * @description The start date for this observation, can be up to a year from the date this schedule request occurs on.
       */
      startDate: string;
    };
    ScheduleObservationResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    Score: {
      /** @enum {string} */
      category: "Carbon" | "Finance" | "Forestry" | "Legal" | "Community" | "GIS" | "Climate Impact" | "Expansion Potential" | "Experience and Understanding" | "Operational Capacity" | "Responsiveness and Attention to Detail" | "Values Alignment";
      /** Format: date-time */
      modifiedTime: string;
      qualitative?: string;
      /**
       * Format: int32
       * @description If `null`, a score has not been selected.
       */
      value?: number;
    };
    /** @description A search criterion. The search will return results that match this criterion. The criterion can be composed of other search criteria to form arbitrary Boolean search expressions. TYPESCRIPT-OVERRIDE-TYPE-WITH-ANY */
    SearchNodePayload: {operation: "and" | "field" | "not" | "or"; [key: string]: any;};
    SearchRequestPayload: {
      /**
       * Format: int32
       * @description Maximum number of top-level search results to return. The system may impose a limit on this value. A separate system-imposed limit may also be applied to lists of child objects inside the top-level results. Use a value of 0 to return the maximum number of allowed results.
       * @default 25
       */
      count?: number;
      /** @description Starting point for search results. If present, a previous search will be continued from where it left off. This should be the value of the cursor that was returned in the response to a previous search. */
      cursor?: string;
      /**
       * @description List of fields to return. Field names should be relative to the prefix. They may navigate the data hierarchy using '.' or '_' as delimiters.
       * @example [
       *   "processingStartDate",
       *   "viabilityTests.seedsTested",
       *   "facility_name"
       * ]
       */
      fields: string[];
      /**
       * @description Prefix for field names. This determines how field names are interpreted, and also how results are structured. Each element in the "results" array in the response will be an instance of whatever entity the prefix points to. Always evaluated starting from the "organizations" level. If not present, the search will return a list of organizations.
       * @example facilities.accessions
       */
      prefix?: string;
      search?: components["schemas"]["AndNodePayload"] | components["schemas"]["FieldNodePayload"] | components["schemas"]["NotNodePayload"] | components["schemas"]["OrNodePayload"];
      /** @description How to sort the search results. This controls both the order of the top-level results and the order of any lists of child objects. */
      sortOrder?: components["schemas"]["SearchSortOrderElement"][];
    };
    SearchResponsePayload: {
      cursor?: string;
      results: {
          [key: string]: unknown;
        }[];
    };
    SearchSortOrderElement: {
      /**
       * @default Ascending
       * @enum {string}
       */
      direction?: "Ascending" | "Descending";
      field: string;
    };
    SearchValuesResponsePayload: {
      results: {
        [key: string]: components["schemas"]["FieldValuesPayload"];
      };
    };
    SeedCountSummaryPayload: {
      /**
       * Format: int64
       * @description Total number of seeds remaining in accessions whose quantities are measured in seeds.
       */
      subtotalBySeedCount: number;
      /**
       * Format: int64
       * @description Estimated total number of seeds remaining in accessions whose quantities are measured by weight. This estimate is based on the subset weight and count. Accessions measured by weight that don't have subset weights and counts are not included in this estimate.
       */
      subtotalByWeightEstimate: number;
      /**
       * Format: int64
       * @description Total number of seeds remaining. The sum of subtotalBySeedCount and subtotalByWeightEstimate.
       */
      total: number;
      /**
       * Format: int32
       * @description Number of accessions that are measured by weight and don't have subset weight and count data. The system cannot estimate how many seeds they have.
       */
      unknownQuantityAccessions: number;
    };
    /** @description Represents a quantity of seeds, measured either in individual seeds or by weight. */
    SeedQuantityPayload: {
      /** @description If this quantity is a weight measurement, the weight in grams. This is not set if the "units" field is "Seeds". This is always calculated on the server side and is ignored on input. */
      grams?: number;
      /** @description Number of units of seeds. If "units" is "Seeds", this is the number of seeds and must be an integer. Otherwise it is a measurement in the weight units specified in the "units" field, and may have a fractional part. */
      quantity: number;
      /** @enum {string} */
      units: "Seeds" | "Grams" | "Milligrams" | "Kilograms" | "Ounces" | "Pounds";
    };
    SendFacilityAlertRequestPayload: {
      /** @description Alert body in plain text. HTML alerts are not supported yet. */
      body: string;
      subject: string;
    };
    SimpleErrorResponsePayload: {
      error: components["schemas"]["ErrorDetails"];
      status: components["schemas"]["SuccessOrError"];
    };
    SimpleSuccessResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
    };
    SpeciesLookupCommonNamePayload: {
      /** @description ISO 639-1 two-letter language code indicating the name's language. Some common names in the server's taxonomic database are not tagged with languages; this value will not be present for those names. */
      language?: string;
      name: string;
    };
    SpeciesLookupDetailsResponsePayload: {
      /** @description List of known common names for the species, if any. */
      commonNames?: components["schemas"]["SpeciesLookupCommonNamePayload"][];
      /**
       * @description IUCN Red List conservation category code.
       * @enum {string}
       */
      conservationCategory?: "CR" | "DD" | "EN" | "EW" | "EX" | "LC" | "NE" | "NT" | "VU";
      familyName: string;
      /**
       * @description If this is not the accepted name for the species, the type of problem the name has. Currently, this will always be "Name Is Synonym".
       * @enum {string}
       */
      problemType?: "Name Misspelled" | "Name Not Found" | "Name Is Synonym";
      scientificName: string;
      /** @description If this is not the accepted name for the species, the name to suggest as an alternative. */
      suggestedScientificName?: string;
    };
    SpeciesLookupNamesResponsePayload: {
      names: string[];
      /** @description True if there were more matching names than could be included in the response. */
      partial: boolean;
      status: components["schemas"]["SuccessOrError"];
    };
    SpeciesProblemElement: {
      /** @enum {string} */
      field: "Scientific Name";
      /** Format: int64 */
      id: number;
      /** @description Value for the field in question that would correct the problem. Absent if the system is unable to calculate a corrected value. */
      suggestedValue?: string;
      /** @enum {string} */
      type: "Name Misspelled" | "Name Not Found" | "Name Is Synonym";
    };
    SpeciesRequestPayload: {
      commonName?: string;
      /**
       * @description IUCN Red List conservation category code.
       * @enum {string}
       */
      conservationCategory?: "CR" | "DD" | "EN" | "EW" | "EX" | "LC" | "NE" | "NT" | "VU";
      ecosystemTypes?: ("Boreal forests/Taiga" | "Deserts and xeric shrublands" | "Flooded grasslands and savannas" | "Mangroves" | "Mediterranean forests, woodlands and scrubs" | "Montane grasslands and shrublands" | "Temperate broad leaf and mixed forests" | "Temperate coniferous forest" | "Temperate grasslands, savannas and shrublands" | "Tropical and subtropical coniferous forests" | "Tropical and subtropical dry broad leaf forests" | "Tropical and subtropical grasslands, savannas and shrublands" | "Tropical and subtropical moist broad leaf forests" | "Tundra")[];
      familyName?: string;
      /** @enum {string} */
      growthForm?: "Tree" | "Shrub" | "Forb" | "Graminoid" | "Fern" | "Fungus" | "Lichen" | "Moss" | "Vine" | "Liana" | "Shrub/Tree" | "Subshrub" | "Multiple Forms";
      /**
       * Format: int64
       * @description Which organization's species list to update.
       */
      organizationId: number;
      rare?: boolean;
      scientificName: string;
      /** @enum {string} */
      seedStorageBehavior?: "Orthodox" | "Recalcitrant" | "Intermediate" | "Unknown" | "Likely Orthodox" | "Likely Recalcitrant" | "Likely Intermediate";
    };
    SpeciesResponseElement: {
      commonName?: string;
      /**
       * @description IUCN Red List conservation category code.
       * @enum {string}
       */
      conservationCategory?: "CR" | "DD" | "EN" | "EW" | "EX" | "LC" | "NE" | "NT" | "VU";
      ecosystemTypes?: ("Boreal forests/Taiga" | "Deserts and xeric shrublands" | "Flooded grasslands and savannas" | "Mangroves" | "Mediterranean forests, woodlands and scrubs" | "Montane grasslands and shrublands" | "Temperate broad leaf and mixed forests" | "Temperate coniferous forest" | "Temperate grasslands, savannas and shrublands" | "Tropical and subtropical coniferous forests" | "Tropical and subtropical dry broad leaf forests" | "Tropical and subtropical grasslands, savannas and shrublands" | "Tropical and subtropical moist broad leaf forests" | "Tundra")[];
      familyName?: string;
      /** @enum {string} */
      growthForm?: "Tree" | "Shrub" | "Forb" | "Graminoid" | "Fern" | "Fungus" | "Lichen" | "Moss" | "Vine" | "Liana" | "Shrub/Tree" | "Subshrub" | "Multiple Forms";
      /** Format: int64 */
      id: number;
      problems?: components["schemas"]["SpeciesProblemElement"][];
      rare?: boolean;
      scientificName: string;
      /** @enum {string} */
      seedStorageBehavior?: "Orthodox" | "Recalcitrant" | "Intermediate" | "Unknown" | "Likely Orthodox" | "Likely Recalcitrant" | "Likely Intermediate";
    };
    SpeciesSummaryNurseryPayload: {
      /** Format: int64 */
      facilityId: number;
      name: string;
    };
    SpeciesSummaryPayload: {
      /** Format: int64 */
      germinatingQuantity: number;
      /** Format: int32 */
      germinationRate?: number;
      /**
       * Format: int32
       * @description Percentage of current and past inventory that was withdrawn due to death.
       */
      lossRate?: number;
      /** Format: int64 */
      notReadyQuantity: number;
      nurseries: components["schemas"]["SpeciesSummaryNurseryPayload"][];
      /** Format: int64 */
      readyQuantity: number;
      /** Format: int64 */
      speciesId: number;
      /**
       * Format: int64
       * @description Total number of germinated plants that have been withdrawn due to death.
       */
      totalDead: number;
      /**
       * Format: int64
       * @description Total number of germinated plants currently in inventory.
       */
      totalQuantity: number;
      /**
       * Format: int64
       * @description Total number of germinated plants that have been withdrawn in the past.
       */
      totalWithdrawn: number;
    };
    SubLocationPayload: {
      /**
       * Format: int32
       * @description If this sub-location is at a seed bank, the number of active accessions stored there.
       */
      activeAccessions?: number;
      /**
       * Format: int32
       * @description If this sub-location is at a nursery, the number of batches stored there that have seedlings.
       */
      activeBatches?: number;
      /** Format: int64 */
      facilityId: number;
      /** Format: int64 */
      id: number;
      name: string;
    };
    SubmissionDocumentPayload: {
      /** Format: date-time */
      createdTime: string;
      description?: string;
      /** @enum {string} */
      documentStore: "Dropbox" | "Google";
      /** Format: int64 */
      id: number;
      name: string;
      originalName?: string;
    };
    /**
     * @description Indicates of success or failure of the requested operation.
     * @enum {string}
     */
    SuccessOrError: "ok" | "error";
    SuccessResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
    };
    SummarizeAccessionSearchRequestPayload: {
      search?: components["schemas"]["AndNodePayload"] | components["schemas"]["FieldNodePayload"] | components["schemas"]["NotNodePayload"] | components["schemas"]["OrNodePayload"];
    };
    SummarizeAccessionSearchResponsePayload: {
      /** Format: int32 */
      accessions: number;
      seedsRemaining: components["schemas"]["SeedCountSummaryPayload"];
      /** Format: int32 */
      species: number;
      status: components["schemas"]["SuccessOrError"];
    };
    /** @description Summary of important statistics about the seed bank for the Summary page. */
    SummaryResponsePayload: {
      /** @description Number of accessions in each state. */
      accessionsByState: {
        [key: string]: number;
      };
      /** Format: int32 */
      activeAccessions: number;
      /** @description Summary of the number of seeds remaining across all active accessions. */
      seedsRemaining: components["schemas"]["SeedCountSummaryPayload"];
      /** Format: int32 */
      species: number;
      status: components["schemas"]["SuccessOrError"];
    };
    TimeZonePayload: {
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      id: string;
      /**
       * @description Long name of time zone, possibly including a city name. This name is guaranteed to be unique across all zones.
       * @example Central European Time - Berlin
       */
      longName: string;
    };
    TimeseriesIdPayload: {
      /** Format: int64 */
      deviceId: number;
      timeseriesName: string;
    };
    TimeseriesPayload: {
      /**
       * Format: int32
       * @description Number of significant fractional digits (after the decimal point), if this is a timeseries with non-integer numeric values.
       */
      decimalPlaces?: number;
      /**
       * Format: int64
       * @description ID of device that produces this timeseries.
       */
      deviceId: number;
      /** @description If any values have been recorded for the timeseries, the latest one. */
      latestValue?: components["schemas"]["TimeseriesValuePayload"];
      timeseriesName: string;
      /** @enum {string} */
      type: "Numeric" | "Text";
      /**
       * @description Units of measure for values in this timeseries.
       * @example volts
       */
      units?: string;
    };
    TimeseriesValuePayload: {
      /** Format: date-time */
      timestamp: string;
      /** @description Value to record. If the timeseries is of type Numeric, this must be a decimal or integer value in string form. If the timeseries is of type Text, this can be an arbitrary string. */
      value: string;
    };
    TimeseriesValuesErrorPayload: {
      /**
       * Format: int64
       * @description Device ID as specified in the failing request.
       */
      deviceId: number;
      /** @description Human-readable details about the failure. */
      message: string;
      /** @description Name of timeseries as specified in the failing request. */
      timeseriesName: string;
      /** @description Values that the server was not able to successfully record. */
      values: components["schemas"]["TimeseriesValuePayload"][];
    };
    TimeseriesValuesPayload: {
      /**
       * Format: int64
       * @description ID of device that produced this value.
       */
      deviceId: number;
      /** @description Name of timeseries. This must be the name of a timeseries that has already been created for the device. */
      timeseriesName: string;
      values: components["schemas"]["TimeseriesValuePayload"][];
    };
    UpdateAccessionRequestPayloadV2: {
      bagNumbers?: string[];
      /** Format: date */
      collectedDate?: string;
      collectionSiteCity?: string;
      collectionSiteCoordinates?: components["schemas"]["Geolocation"][];
      collectionSiteCountryCode?: string;
      collectionSiteCountrySubdivision?: string;
      collectionSiteLandowner?: string;
      collectionSiteName?: string;
      collectionSiteNotes?: string;
      /** @enum {string} */
      collectionSource?: "Wild" | "Reintroduced" | "Cultivated" | "Other";
      collectors?: string[];
      /** Format: date */
      dryingEndDate?: string;
      /** Format: int64 */
      facilityId?: number;
      notes?: string;
      plantId?: string;
      /**
       * Format: int32
       * @description Estimated number of plants the seeds were collected from.
       */
      plantsCollectedFrom?: number;
      /** Format: int64 */
      projectId?: number;
      /** Format: date */
      receivedDate?: string;
      /** @description Quantity of seeds remaining in the accession. If this is different than the existing value, it is considered a new observation, and the new value will override any previously-calculated remaining quantities. */
      remainingQuantity?: components["schemas"]["SeedQuantityPayload"];
      /** @description Notes associated with remaining quantity updates if any. */
      remainingQuantityNotes?: string;
      /** Format: int64 */
      speciesId?: number;
      /** @enum {string} */
      state?: "Awaiting Check-In" | "Awaiting Processing" | "Processing" | "Drying" | "In Storage" | "Used Up";
      subLocation?: string;
      /** Format: int32 */
      subsetCount?: number;
      /** @description Weight of subset of seeds. Units must be a weight measurement, not "Seeds". */
      subsetWeight?: components["schemas"]["SeedQuantityPayload"];
      /** Format: int32 */
      viabilityPercent?: number;
    };
    UpdateAccessionResponsePayloadV2: {
      accession: components["schemas"]["AccessionPayloadV2"];
      status: components["schemas"]["SuccessOrError"];
    };
    UpdateAutomationRequestPayload: {
      description?: string;
      /** Format: int64 */
      deviceId?: number;
      /** Format: double */
      lowerThreshold?: number;
      name: string;
      settings?: {
        [key: string]: unknown;
      };
      timeseriesName?: string;
      type: string;
      /** Format: double */
      upperThreshold?: number;
      /** Format: int32 */
      verbosity?: number;
    };
    UpdateBatchQuantitiesRequestPayload: {
      /** Format: int32 */
      germinatingQuantity: number;
      /** Format: int32 */
      notReadyQuantity: number;
      /** Format: int32 */
      readyQuantity: number;
      /** Format: int32 */
      version: number;
    };
    UpdateBatchRequestPayload: {
      notes?: string;
      /** Format: int64 */
      projectId?: number;
      /** Format: date */
      readyByDate?: string;
      subLocationIds?: number[];
      /** @enum {string} */
      substrate?: "MediaMix" | "Soil" | "Sand" | "Moss" | "PerliteVermiculite" | "Other";
      substrateNotes?: string;
      /** @enum {string} */
      treatment?: "Soak" | "Scarify" | "Chemical" | "Stratification" | "Other" | "Light";
      treatmentNotes?: string;
      /** Format: int32 */
      version: number;
    };
    UpdateCohortRequestPayload: {
      name: string;
      /** @enum {string} */
      phase: "Phase 0 - Due Diligence" | "Phase 1 - Feasibility Study" | "Phase 2 - Plan and Scale" | "Phase 3 - Implement and Monitor";
    };
    UpdateDeviceRequestPayload: {
      /**
       * @description Protocol-specific address of device, e.g., an IP address or a Bluetooth device ID.
       * @example 192.168.1.100
       */
      address?: string;
      /**
       * @description Name of device manufacturer.
       * @example InHand Networks
       */
      make: string;
      /**
       * @description Model number or model name of the device.
       * @example IR915L
       */
      model: string;
      /**
       * @description Name of this device.
       * @example BMU-1
       */
      name: string;
      /**
       * Format: int64
       * @description ID of parent device such as a hub or gateway, if any. The parent device must exist.
       */
      parentId?: number;
      /**
       * Format: int32
       * @description Port number if relevant for the protocol.
       * @example 50000
       */
      port?: number;
      /**
       * @description Device manager protocol name.
       * @example modbus
       */
      protocol?: string;
      /** @description Protocol- and device-specific custom settings. This is an arbitrary JSON object; the exact settings depend on the device type. */
      settings?: {
        [key: string]: unknown;
      };
      /**
       * @description High-level type of the device. Device manager may use this in conjunction with the make and model to determine which metrics to report.
       * @example inverter
       */
      type: string;
      /**
       * Format: int32
       * @description Level of diagnostic information to log.
       */
      verbosity?: number;
    };
    UpdateDraftPlantingSiteRequestPayload: {
      /** @description In-progress state of the draft. This includes map data and other information needed by the client. It is treated as opaque data by the server. */
      data: {
        [key: string]: unknown;
      };
      description?: string;
      name: string;
      /**
       * Format: int32
       * @description If the user has started defining planting subzones, the number of subzones defined so far.
       */
      numPlantingSubzones?: number;
      /**
       * Format: int32
       * @description If the user has started defining planting zones, the number of zones defined so far.
       */
      numPlantingZones?: number;
      /**
       * Format: int64
       * @description If the draft is associated with a project, its ID.
       */
      projectId?: number;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    UpdateFacilityRequestPayload: {
      /** Format: date */
      buildCompletedDate?: string;
      /** Format: date */
      buildStartedDate?: string;
      /**
       * Format: int32
       * @description For nursery facilities, the number of plants this nursery is capable of holding.
       */
      capacity?: number;
      description?: string;
      name: string;
      /** Format: date */
      operationStartedDate?: string;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    UpdateGlobalRolesRequestPayload: {
      globalRoles: ("Super-Admin" | "Accelerator Admin" | "TF Expert" | "Read Only")[];
    };
    UpdateNotificationRequestPayload: {
      read: boolean;
    };
    UpdateNotificationsRequestPayload: {
      /** Format: int64 */
      organizationId?: number;
      read: boolean;
    };
    UpdateOrganizationRequestPayload: {
      /**
       * @description ISO 3166 alpha-2 code of organization's country.
       * @example AU
       */
      countryCode?: string;
      /**
       * @description ISO 3166-2 code of organization's country subdivision (state, province, region, etc.) This is the full ISO 3166-2 code including the country prefix. If this is set, countryCode must also be set.
       * @example US-HI
       */
      countrySubdivisionCode?: string;
      description?: string;
      name: string;
      /** @enum {string} */
      organizationType?: "Government" | "NGO" | "Arboreta" | "Academia" | "ForProfit" | "Other";
      /** @description Non-empty additional description of organization when type is Other. */
      organizationTypeDetails?: string;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
      website?: string;
    };
    UpdateOrganizationUserRequestPayload: {
      /** @enum {string} */
      role: "Contributor" | "Manager" | "Admin" | "Owner" | "Terraformation Contact";
    };
    UpdateParticipantRequestPayload: {
      /**
       * Format: int64
       * @description Assign the participant to this cohort. If null, remove the participant from its current cohort, if any.
       */
      cohortId?: number;
      name: string;
      /** @description Set the participant's list of assigned projects to this. If projects are currently assigned to the participant but aren't included in this list, they will be removed from the participant. */
      projectIds: number[];
    };
    UpdatePlantingSiteRequestPayload: {
      /** @description Site boundary. Ignored if this is a detailed planting site. */
      boundary?: components["schemas"]["MultiPolygon"];
      description?: string;
      name: string;
      plantingSeasons?: components["schemas"]["UpdatedPlantingSeasonPayload"][];
      /** Format: int64 */
      projectId?: number;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    UpdatePlantingSubzoneRequestPayload: {
      plantingCompleted: boolean;
    };
    UpdatePlotObservationRequestPayload: {
      /** @description Observed coordinates, if any, up to one per position. */
      coordinates: components["schemas"]["ObservationMonitoringPlotCoordinatesPayload"][];
    };
    UpdateProjectAcceleratorDetailsRequestPayload: {
      abbreviatedName?: string;
      applicationReforestableLand?: number;
      confirmedReforestableLand?: number;
      countryCode?: string;
      dealDescription?: string;
      /** @enum {string} */
      dealStage?: "Phase 0 (Doc Review)" | "Phase 1" | "Phase 2" | "Phase 3" | "Graduated, Finished Planting" | "Non Graduate" | "Application Submitted" | "Project Lead Screening Review" | "Screening Questions Ready for Review" | "Carbon Pre-Check" | "Submission Requires Follow Up" | "Carbon Eligible" | "Closed Lost" | "Issue Active" | "Issue Pending" | "Issue Reesolved";
      failureRisk?: string;
      investmentThesis?: string;
      landUseModelTypes: ("Native Forest" | "Monoculture" | "Sustainable Timber" | "Other Timber" | "Mangroves" | "Agroforestry" | "Silvopasture" | "Other Land-Use Model")[];
      maxCarbonAccumulation?: number;
      minCarbonAccumulation?: number;
      /** Format: int32 */
      numCommunities?: number;
      /** Format: int32 */
      numNativeSpecies?: number;
      perHectareBudget?: number;
      /** @enum {string} */
      pipeline?: "Accelerator Projects" | "Carbon Supply" | "Carbon Waitlist";
      projectLead?: string;
      totalExpansionPotential?: number;
      whatNeedsToBeTrue?: string;
    };
    UpdateProjectRequestPayload: {
      description?: string;
      name: string;
    };
    UpdateReportPhotoRequestPayload: {
      caption?: string;
    };
    UpdateReportSettingsRequestPayload: {
      /** @description If true, enable organization-level reports. */
      organizationEnabled: boolean;
      /** Format: int64 */
      organizationId: number;
      /** @description Per-project report settings. If a project is missing from this list, its settings will revert to the defaults. */
      projects: components["schemas"]["ProjectReportSettingsPayload"][];
    };
    UpdateSubLocationRequestPayload: {
      name: string;
    };
    UpdateSubmissionRequestPayload: {
      feedback?: string;
      internalComment?: string;
      /** @enum {string} */
      status: "Not Submitted" | "In Review" | "Needs Translation" | "Approved" | "Rejected" | "Not Needed";
    };
    UpdateUserPreferencesRequestPayload: {
      /**
       * Format: int64
       * @description If present, update the user's per-organization preferences for this organization. If not present, update the user's global preferences.
       */
      organizationId?: number;
      preferences: {
        [key: string]: unknown;
      };
    };
    UpdateUserRequestPayload: {
      /**
       * @description Two-letter code of the user's country.
       * @example US
       */
      countryCode?: string;
      /** @description If true, the user wants to receive all the notifications for their organizations via email. This does not apply to certain kinds of notifications such as "You've been added to a new organization." If null, leave the existing value as-is. */
      emailNotificationsEnabled?: boolean;
      firstName: string;
      lastName: string;
      /**
       * @description IETF locale code containing user's preferred language.
       * @example en
       */
      locale?: string;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    UpdateViabilityTestRequestPayload: {
      /** Format: date */
      endDate?: string;
      notes?: string;
      /** @enum {string} */
      seedType?: "Fresh" | "Stored";
      /** Format: int32 */
      seedsCompromised?: number;
      /** Format: int32 */
      seedsEmpty?: number;
      /** Format: int32 */
      seedsFilled?: number;
      /** Format: int32 */
      seedsTested: number;
      /** Format: date */
      startDate?: string;
      /** @enum {string} */
      substrate?: "Nursery Media" | "Agar" | "Paper" | "Other" | "Sand" | "Media Mix" | "Soil" | "Moss" | "Perlite/Vermiculite" | "None";
      testResults?: components["schemas"]["ViabilityTestResultPayload"][];
      /** @enum {string} */
      treatment?: "Soak" | "Scarify" | "Chemical" | "Stratification" | "Other" | "Light";
      /**
       * Format: int64
       * @description ID of user who withdrew seeds to perform the test. If non-null, the current user must have permission to see the referenced user's membership details in the organization. If absent or null, the existing value is left unchanged.
       */
      withdrawnByUserId?: number;
    };
    UpdateWithdrawalRequestPayload: {
      /** Format: date */
      date?: string;
      notes?: string;
      /** @enum {string} */
      purpose?: "Other" | "Viability Testing" | "Out-planting" | "Nursery";
      /**
       * Format: int64
       * @description ID of the user who withdrew the seeds. Default is the withdrawal's existing user ID. If non-null, the current user must have permission to read the referenced user's membership details in the organization.
       */
      withdrawnByUserId?: number;
      /** @description Quantity of seeds withdrawn. For viability testing withdrawals, this is always the same as the test's "seedsTested" value. Otherwise, it is a user-supplied value. If this quantity is in weight and the remaining quantity of the accession is in seeds or vice versa, the accession must have a subset weight and count. */
      withdrawnQuantity?: components["schemas"]["SeedQuantityPayload"];
    };
    UpdatedPlantingSeasonPayload: {
      /** Format: date */
      endDate: string;
      /**
       * Format: int64
       * @description If present, the start and end dates of an existing planting season will be updated. Otherwise a new planting season will be created.
       */
      id?: number;
      /** Format: date */
      startDate: string;
    };
    UploadDeliverableDocumentResponsePayload: {
      /** Format: int64 */
      documentId: number;
      status: components["schemas"]["SuccessOrError"];
    };
    UploadFileResponsePayload: {
      /**
       * Format: int64
       * @description ID of uploaded file. This may be used to poll for the file's status.
       */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    UploadPlotPhotoRequestPayload: {
      gpsCoordinates: components["schemas"]["Point"];
      /** @enum {string} */
      position: "SouthwestCorner" | "SoutheastCorner" | "NortheastCorner" | "NorthwestCorner";
    };
    UploadPlotPhotoResponsePayload: {
      /** Format: int64 */
      fileId: number;
      status: components["schemas"]["SuccessOrError"];
    };
    /** @description List of conditions that might cause the user to want to cancel the upload but that can be automatically resolved if desired. */
    UploadProblemPayload: {
      /** @description Name of the field with the problem. Absent if the problem isn't specific to a single field. */
      fieldName?: string;
      /** @description Human-readable description of the problem. */
      message?: string;
      /**
       * Format: int32
       * @description Position (row number) of the record with the problem.
       */
      position?: number;
      /** @enum {string} */
      type: "Unrecognized Value" | "Missing Required Value" | "Duplicate Value" | "Malformed Value";
      /** @description The value that caused the problem. Absent if the problem wasn't caused by a specific field value. */
      value?: string;
    };
    UploadReportFileResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    UpsertProjectScoresRequestPayload: {
      /** @enum {string} */
      phase: "Phase 0 - Due Diligence" | "Phase 1 - Feasibility Study" | "Phase 2 - Plan and Scale" | "Phase 3 - Implement and Monitor";
      scores: components["schemas"]["UpsertScore"][];
    };
    UpsertProjectVotesRequestPayload: {
      /** @enum {string} */
      phase: "Phase 0 - Due Diligence" | "Phase 1 - Feasibility Study" | "Phase 2 - Plan and Scale" | "Phase 3 - Implement and Monitor";
      votes: components["schemas"]["UpsertVoteSelection"][];
    };
    UpsertScore: {
      /** @enum {string} */
      category: "Carbon" | "Finance" | "Forestry" | "Legal" | "Community" | "GIS" | "Climate Impact" | "Expansion Potential" | "Experience and Understanding" | "Operational Capacity" | "Responsiveness and Attention to Detail" | "Values Alignment";
      qualitative?: string;
      /**
       * Format: int32
       * @description If set to `null`, remove the selected score.
       */
      value?: number;
    };
    UpsertVoteSelection: {
      conditionalInfo?: string;
      /** Format: int64 */
      userId: number;
      /**
       * @description If set to `null`, remove the vote the user has previously selected.
       * @enum {string}
       */
      voteOption?: "No" | "Conditional" | "Yes";
    };
    UserProfilePayload: {
      /**
       * @description Two-letter code of the user's country.
       * @example US
       */
      countryCode?: string;
      email: string;
      /** @description If true, the user wants to receive all the notifications for their organizations via email. This does not apply to certain kinds of notifications such as "You've been added to a new organization." */
      emailNotificationsEnabled: boolean;
      firstName?: string;
      globalRoles: ("Super-Admin" | "Accelerator Admin" | "TF Expert" | "Read Only")[];
      /**
       * Format: int64
       * @description User's unique ID. This should not be shown to the user, but is a required input to some API endpoints.
       */
      id: number;
      lastName?: string;
      /**
       * @description IETF locale code containing user's preferred language.
       * @example en
       */
      locale?: string;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    UserWithGlobalRolesPayload: {
      /** Format: date-time */
      createdTime: string;
      email: string;
      firstName?: string;
      globalRoles: ("Super-Admin" | "Accelerator Admin" | "TF Expert" | "Read Only")[];
      /** Format: int64 */
      id: number;
      lastName?: string;
    };
    VersionsEntryPayload: {
      appName: string;
      minimumVersion: string;
      platform: string;
      recommendedVersion: string;
    };
    VersionsResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      versions: components["schemas"]["VersionsEntryPayload"][];
    };
    ViabilityTestResultPayload: {
      /** Format: date */
      recordingDate: string;
      /** Format: int32 */
      seedsGerminated: number;
    };
    VoteSelection: {
      conditionalInfo?: string;
      /** @description The vote the user has selected. Can be yes/no/conditional or `null` if a vote is not yet selected. */
      email: string;
      firstName?: string;
      lastName?: string;
      /** Format: int64 */
      userId: number;
      /** @enum {string} */
      voteOption?: "No" | "Conditional" | "Yes";
    };
    WorkersPayloadV1: {
      /** Format: int32 */
      femalePaidWorkers?: number;
      /** Format: int32 */
      paidWorkers?: number;
      /** Format: int32 */
      volunteers?: number;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /** Gets the list of cohorts. */
  listCohorts: {
    parameters: {
      query: {
        /** @description If specified, retrieve associated entities to the supplied depth. For example, 'participant' depth will return the participants associated to the cohort. */
        depth: "Cohort" | "Participant";
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["CohortListResponsePayload"];
        };
      };
    };
  };
  /** Creates a new cohort. */
  createCohort: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateCohortRequestPayload"];
      };
    };
    responses: {
      /** @description The cohort was created successfully. */
      200: {
        content: {
          "application/json": components["schemas"]["CohortResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a single cohort. */
  getCohort: {
    parameters: {
      query: {
        /** @description If specified, retrieve associated entities to the supplied depth. For example, 'participant' depth will return the participants associated to the cohort. */
        depth: "Cohort" | "Participant";
      };
      path: {
        cohortId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["CohortResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Updates the information within a single cohort. */
  updateCohort: {
    parameters: {
      path: {
        cohortId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateCohortRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["CohortResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Deletes a single cohort. */
  deleteCohort: {
    parameters: {
      path: {
        cohortId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Lists the deliverables for accelerator projects
   * @description The list may optionally be filtered based on certain criteria as specified in the query string. If no filter parameters are supplied, lists all the deliverables in all the participants and projects that are visible to the user. For users with accelerator admin privileges, this will be the full list of all deliverables for all accelerator projects.
   */
  listDeliverables: {
    parameters: {
      query?: {
        /** @description List deliverables for projects belonging to this organization. Ignored if participantId or projectId is specified. */
        organizationId?: number;
        /** @description List deliverables for all projects in this participant. Ignored if projectId is specified. */
        participantId?: number;
        /** @description List deliverables for this project only. */
        projectId?: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["ListDeliverablesResponsePayload"];
        };
      };
    };
  };
  /** Uploads a new document to satisfy a deliverable. */
  uploadDeliverableDocument: {
    parameters: {
      path: {
        deliverableId: number;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          description: string;
          /** Format: binary */
          file: string;
          projectId: string;
        };
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UploadDeliverableDocumentResponsePayload"];
        };
      };
    };
  };
  /** Gets a single submission document from a deliverable. */
  getDeliverableDocument: {
    parameters: {
      path: {
        deliverableId: number;
        documentId: number;
      };
    };
    responses: {
      /** @description If the current user has permission to view the document, redirects to the document on the document store. Depending on the document store, the redirect URL may or may not be valid for only a limited time. */
      307: {
        headers: {
          /** @description URL of document in document store. */
          Location?: unknown;
        };
        content: {
          "application/json": string;
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets the details of a single deliverable and its submission documents, if any. */
  getDeliverable: {
    parameters: {
      path: {
        deliverableId: number;
        projectId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetDeliverableResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Updates the state of a submission from a project.
   * @description Only permitted for users with accelerator admin privileges.
   */
  updateSubmission: {
    parameters: {
      path: {
        deliverableId: number;
        projectId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateSubmissionRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Lists organizations with the Accelerator internal tag and their projects.
   * @description By default, only lists tagged organizations that have projects that have not been assigned to participants yet.
   */
  listAcceleratorOrganizations: {
    parameters: {
      query?: {
        /** @description Whether to also include projects that have been assigned to participants. */
        includeParticipants?: boolean;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListAcceleratorOrganizationsResponsePayload"];
        };
      };
    };
  };
  /** Creates a new participant. */
  createParticipant: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateParticipantRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetParticipantResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a participant and its assigned projects. */
  getParticipant: {
    parameters: {
      path: {
        participantId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetParticipantResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Updates a participant's information. */
  updateParticipant: {
    parameters: {
      path: {
        participantId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateParticipantRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Deletes a participant that has no projects. */
  deleteParticipant: {
    parameters: {
      path: {
        participantId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description There are projects associated with the participant. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Gets the accelerator-related details for a project.
   * @description Does not include information such as project name that's available via the non-accelerator projects API.
   */
  getProjectAcceleratorDetails: {
    parameters: {
      path: {
        projectId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetProjectAcceleratorDetailsResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Updates the accelerator-related details for a project. */
  updateProjectAcceleratorDetails: {
    parameters: {
      path: {
        projectId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateProjectAcceleratorDetailsRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets score selections for a single project. */
  getProjectScores: {
    parameters: {
      path: {
        projectId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetProjectScoresResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Upserts score selections for a single project.
   * @description Update the scores for the project phase. If the (project, phase, category) does not exist, a new entry is created. Setting a `score` to `null` removes the score.
   */
  upsertProjectScores: {
    parameters: {
      path: {
        projectId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpsertProjectScoresRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Gets vote selections for a single project.
   * @description List every vote selection for this project, organized by phases. Each phase will contain a list of eligible voters and their selections.
   */
  getProjectVotes: {
    parameters: {
      path: {
        projectId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetProjectVotesResponsePayload"];
        };
      };
      /** @description Attempting to read votes without sufficient privilege */
      403: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Upserts vote selections for a single project.
   * @description Update the user's vote for the project phase. If the (user, project, phase) does not exist, a new entry is created. Setting a `voteOption` to `null` removes the vote.
   */
  upsertProjectVotes: {
    parameters: {
      path: {
        projectId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpsertProjectVotesRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description Attempting to delete votes without sufficient privilege */
      403: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description Attempting to upsert a vote in an inactive phase */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Remove one or more voters from the project/phase.
   * @description Remove the voters from the project phase, making them ineligible from voting. This is different from undoing a vote (by setting the `voteOption` to `null`). To remove voters from the entire project phase, set `userId` to `null`, and set `phaseDelete` to `true`
   */
  deleteProjectVotes: {
    parameters: {
      path: {
        projectId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeleteProjectVotesRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description Attempting to delete a phase of votes without safeguard */
      400: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description Attempting to delete votes without sufficient privilege */
      403: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description Attempting to delete a vote in an inactive phase */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets a list of automations for a device or facility. */
  listAutomations: {
    parameters: {
      query?: {
        deviceId?: number;
        facilityId?: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListAutomationsResponsePayload"];
        };
      };
    };
  };
  /** Creates a new automation for a device or facility. */
  createAutomation: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateAutomationRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateAutomationResponsePayload"];
        };
      };
    };
  };
  /** Gets the details of a single automation for a device or facility. */
  getAutomation: {
    parameters: {
      path: {
        automationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetAutomationResponsePayload"];
        };
      };
    };
  };
  /** Updates an existing automation for a device or facility. */
  updateAutomation: {
    parameters: {
      path: {
        automationId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateAutomationRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Deletes an existing automation from a device or facility. */
  deleteAutomation: {
    parameters: {
      path: {
        automationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Reports that an automation has been triggered. */
  postAutomationTrigger: {
    parameters: {
      path: {
        automationId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AutomationTriggerRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Registers a new device a facility's device manager. */
  createDevice: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateDeviceRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Searches for device managers matching a set of criteria. */
  getDeviceManagers: {
    parameters: {
      query?: {
        /** @description Search for device managers with this sensor kit ID. Either this or facilityId must be specified. */
        sensorKitId?: string;
        /** @description Search for device managers associated with this facility. Either this or sensorKitId must be specified. */
        facilityId?: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetDeviceManagersResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a specific device manager. */
  getDeviceManager: {
    parameters: {
      path: {
        deviceManagerId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetDeviceManagerResponsePayload"];
        };
      };
    };
  };
  /** Connects a device manager to a facility. */
  connectDeviceManager: {
    parameters: {
      path: {
        deviceManagerId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectDeviceManagerRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Lists the available templates for new devices. */
  listDeviceTemplates: {
    parameters: {
      query?: {
        category?: "PV" | "Seed Bank Default";
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListDeviceTemplatesResponsePayload"];
        };
      };
    };
  };
  /** Gets the configuration of a single device. */
  getDevice: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description Device configuration retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["GetDeviceResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Updates the configuration of an existing device. */
  updateDevice: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateDeviceRequestPayload"];
      };
    };
    responses: {
      /** @description Device configuration updated. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Marks a device as unresponsive.
   * @description Notifies the appropriate users so they can troubleshoot the problem.
   */
  deviceUnresponsive: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeviceUnresponsiveRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Lists all accessible facilities. */
  listAllFacilities: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListFacilitiesResponse"];
        };
      };
    };
  };
  /** Creates a new facility. */
  createFacility: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateFacilityRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateFacilityResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a single facility. */
  getFacility: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetFacilityResponse"];
        };
      };
    };
  };
  /** Updates information about a facility. */
  updateFacility: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateFacilityRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Sends an alert to the facility's configured alert recipients. */
  sendFacilityAlert: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SendFacilityAlertRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The request was received, but the user is still configuring or placing sensors, so no notification has been generated. */
      202: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Marks a facility as fully configured.
   * @description After connecting a device manager and finishing any necessary configuration of the facility's devices, send this request to enable processing of timeseries values and alerts from the device manager. Only valid if the facility's connection state is `Connected`.
   */
  postConfigured: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The facility's device manager was not in the process of being configured. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Lists the configurations of all the devices at a facility. */
  listFacilityDevices: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** @description Successfully listed the facility's devices. */
      200: {
        content: {
          "application/json": components["schemas"]["ListDeviceConfigsResponse"];
        };
      };
      /** @description The facility does not exist or is not accessible by the current user. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets a list of sub-locations at a facility. */
  listSubLocations: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListSubLocationsResponsePayload"];
        };
      };
    };
  };
  /** Creates a new sub-location at a facility. */
  createSubLocation: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateSubLocationRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetSubLocationResponsePayload"];
        };
      };
      /** @description A sub-location with the requested name already exists at the facility. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a specific sub-location at a facility. */
  getSubLocation: {
    parameters: {
      path: {
        facilityId: number;
        subLocationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetSubLocationResponsePayload"];
        };
      };
    };
  };
  /** Updates the name of a sub-location at a facility. */
  updateSubLocation: {
    parameters: {
      path: {
        facilityId: number;
        subLocationId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateSubLocationRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description A sub-location with the requested name already exists at the facility. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Deletes a sub-location from a facility.
   * @description The sub-location must not be in use.
   */
  deleteSubLocation: {
    parameters: {
      path: {
        facilityId: number;
        subLocationId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The sub-location is in use, e.g., there are seeds or seedlings stored there. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Lists the configurations of all the devices at a facility. */
  listFacilityDevices_1: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** @description Successfully listed the facility's devices. */
      200: {
        content: {
          "application/json": components["schemas"]["ListDeviceConfigsResponse"];
        };
      };
      /** @description The facility does not exist or is not accessible by the current user. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets the list of users that have global roles. */
  listGlobalRoles: {
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GlobalRoleUsersListResponsePayload"];
        };
      };
    };
  };
  /** Remove global roles from the supplied users. */
  deleteGlobalRoles: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeleteGlobalRolesRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets a list of supported time zones and their names. */
  listTimeZoneNames: {
    parameters: {
      query?: {
        /**
         * @description Language code and optional country code suffix. If not specified, the preferred locale from the Accept-Language header is used if supported; otherwise US English is the default.
         * @example zh-CN
         */
        locale?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListTimeZoneNamesResponsePayload"];
        };
      };
    };
  };
  /**
   * Redirects to a login page.
   * @description For interactive web applications, this can be used to redirect the user to a login page to allow the application to make other API requests. The login process will set a cookie that will authenticate to the API, and will then redirect back to the application. One approach is to use this in error response handlers: if an API request returns HTTP 401 Unauthorized, set location.href to this endpoint and set "redirect" to the URL of the page the user was on so they'll return there after logging in.
   */
  login: {
    parameters: {
      query: {
        /** @description URL to redirect to after login. The list of valid redirect URLs is restricted; this must be the URL of a Terraware web application. */
        redirect: string;
      };
    };
    responses: {
      /** @description Redirects to a login page. After login, the user will be redirected back to the URL specified in the "redirect" parameter. */
      302: {
        content: never;
      };
    };
  };
  /** Retrieve all notifications for current user scoped to an organization. */
  readAll: {
    parameters: {
      query?: {
        /** @description If set, return notifications relevant to that organization. */
        organizationId?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNotificationsResponsePayload"];
        };
      };
    };
  };
  /** Update notifications as read or unread */
  markAllRead: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateNotificationsRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Retrieve notifications count by organization for current user. */
  count: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNotificationsCountResponsePayload"];
        };
      };
    };
  };
  /** Retrieve a notification by its id. */
  read: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNotificationResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Update a single notification as read or unread */
  markRead: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateNotificationRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Creates a new seedling batch at a nursery. */
  createBatch: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateBatchRequestPayload"];
      };
    };
    responses: {
      /** @description The batch was created successfully. Response includes fields populated by the server, including the batch ID. */
      200: {
        content: {
          "application/json": components["schemas"]["BatchResponsePayload"];
        };
      };
    };
  };
  /**
   * Uploads a list of seedling batches to add to the nursery.
   * @description The uploaded file must be in CSV format. A template with the correct headers may be downloaded from the `/api/v1/nursery/batches/uploads/template` endpoint.
   */
  uploadSeedlingBatchesList: {
    parameters: {
      query: {
        facilityId: number;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
    responses: {
      /** @description The file has been successfully received. It will be processed asynchronously; use the ID returned in the response payload to poll for its status using the `/api/v1/nursery/batches/uploads/{uploadId}` GET endpoint. */
      200: {
        content: {
          "application/json": components["schemas"]["UploadFileResponsePayload"];
        };
      };
    };
  };
  /** Gets a template file that contains the required header row for seedling batch uploads. */
  getSeedlingBatchesUploadTemplate: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": string;
        };
      };
    };
  };
  /**
   * Gets the status of a seedling batches list uploaded previously.
   * @description Clients may poll this endpoint to monitor the progress of the file.
   */
  getSeedlingBatchesListUploadStatus: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetUploadStatusResponsePayload"];
        };
      };
    };
  };
  /**
   * Gets the history of changes to a seedling batch.
   * @description Each event includes a version number. For events such as details edits that are snapshots of the values at a particular time, clients can compare against the event with the previous version number to see what has changed, e.g., to show a delta or a diff view.
   */
  getBatchHistory: {
    parameters: {
      path: {
        batchId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetBatchHistoryResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Lists all the photos of a seedling batch. */
  listBatchPhotos: {
    parameters: {
      path: {
        batchId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListBatchPhotosResponsePayload"];
        };
      };
      /** @description The batch does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Creates a new photo of a seedling batch. */
  createBatchPhoto: {
    parameters: {
      path: {
        batchId: number;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateBatchPhotoResponsePayload"];
        };
      };
    };
  };
  /**
   * Retrieves a specific photo from a seedling batch.
   * @description Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio.
   */
  getBatchPhoto: {
    parameters: {
      query?: {
        /** @description Maximum desired width in pixels. If neither this nor maxHeight is specified, the full-sized original image will be returned. If this is specified, an image no wider than this will be returned. The image may be narrower than this value if needed to preserve the aspect ratio of the original. */
        maxWidth?: string;
        /** @description Maximum desired height in pixels. If neither this nor maxWidth is specified, the full-sized original image will be returned. If this is specified, an image no taller than this will be returned. The image may be shorter than this value if needed to preserve the aspect ratio of the original. */
        maxHeight?: string;
      };
      path: {
        batchId: number;
        photoId: number;
      };
    };
    responses: {
      /** @description The photo was successfully retrieved. */
      200: {
        content: {
          "image/jpeg": string;
          "image/png": string;
        };
      };
      /** @description The batch does not exist, or does not have a photo with the requested ID. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Deletes a photo from a seedling batch. */
  deleteBatchPhoto: {
    parameters: {
      path: {
        batchId: number;
        photoId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The batch does not exist, or does not have a photo with the requested ID. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a single seedling batch. */
  getBatch: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["BatchResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Updates non-quantity-related details about a batch. */
  updateBatch: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateBatchRequestPayload"];
      };
    };
    responses: {
      /** @description The batch was updated successfully. Response includes fields populated or modified by the server as a result of the update. */
      200: {
        content: {
          "application/json": components["schemas"]["BatchResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The requested resource has a newer version and was not updated. */
      412: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Deletes an existing seedling batch from a nursery. */
  deleteBatch: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Changes the statuses of seedlings in a batch.
   * @description There must be enough seedlings available to move to the next status.
   */
  changeBatchStatuses: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ChangeBatchStatusRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["BatchResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The requested resource has a newer version and was not updated. */
      412: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Updates the remaining quantities in a seedling batch.
   * @description This should not be used to record withdrawals; use the withdrawal API for that.
   */
  updateBatchQuantities: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateBatchQuantitiesRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["BatchResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The requested resource has a newer version and was not updated. */
      412: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets a summary of the numbers of plants in a nursery. */
  getNurserySummary: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNurserySummaryResponsePayload"];
        };
      };
    };
  };
  /** Gets a summary of the numbers of plants of each species in all nurseries. */
  getSpeciesSummary: {
    parameters: {
      path: {
        speciesId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesSummaryResponsePayload"];
        };
      };
    };
  };
  /** Withdraws seedlings from one or more seedling batches at a nursery. */
  createBatchWithdrawal: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateNurseryWithdrawalRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNurseryWithdrawalResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a specific nursery withdrawal. */
  getNurseryWithdrawal: {
    parameters: {
      path: {
        withdrawalId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNurseryWithdrawalResponsePayload"];
        };
      };
    };
  };
  /** Lists all the photos of a withdrawal. */
  listWithdrawalPhotos: {
    parameters: {
      path: {
        withdrawalId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListWithdrawalPhotosResponsePayload"];
        };
      };
      /** @description The withdrawal does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Creates a new photo of a seedling batch withdrawal. */
  uploadWithdrawalPhoto: {
    parameters: {
      path: {
        withdrawalId: number;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateNurseryWithdrawalPhotoResponsePayload"];
        };
      };
    };
  };
  /**
   * Retrieves a specific photo from a withdrawal.
   * @description Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio.
   */
  getWithdrawalPhoto: {
    parameters: {
      query?: {
        /** @description Maximum desired width in pixels. If neither this nor maxHeight is specified, the full-sized original image will be returned. If this is specified, an image no wider than this will be returned. The image may be narrower than this value if needed to preserve the aspect ratio of the original. */
        maxWidth?: string;
        /** @description Maximum desired height in pixels. If neither this nor maxWidth is specified, the full-sized original image will be returned. If this is specified, an image no taller than this will be returned. The image may be shorter than this value if needed to preserve the aspect ratio of the original. */
        maxHeight?: string;
      };
      path: {
        withdrawalId: number;
        photoId: number;
      };
    };
    responses: {
      /** @description The photo was successfully retrieved. */
      200: {
        content: {
          "image/jpeg": string;
          "image/png": string;
        };
      };
      /** @description The withdrawal does not exist, or does not have a photo with the requested ID. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Lists all organizations.
   * @description Lists all organizations the user can access.
   */
  listOrganizations: {
    parameters: {
      query?: {
        /** @description Return this level of information about the organization's contents. */
        depth?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListOrganizationsResponsePayload"];
        };
      };
    };
  };
  /** Creates a new organization. */
  createOrganization: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateOrganizationRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetOrganizationResponsePayload"];
        };
      };
    };
  };
  /** Gets information about an organization. */
  getOrganization: {
    parameters: {
      query?: {
        /** @description Return this level of information about the organization's contents. */
        depth?: string;
      };
      path: {
        /** @description ID of organization to get. User must be a member of the organization. */
        organizationId: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetOrganizationResponsePayload"];
        };
      };
    };
  };
  /** Updates an existing organization. */
  updateOrganization: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateOrganizationRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Deletes an existing organization.
   * @description Organizations can only be deleted if they have no members other than the current user.
   */
  deleteOrganization: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The organization has other members and cannot be deleted. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Lists the roles in an organization. */
  listOrganizationRoles: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListOrganizationRolesResponsePayload"];
        };
      };
    };
  };
  /** Lists the users in an organization. */
  listOrganizationUsers: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListOrganizationUsersResponsePayload"];
        };
      };
    };
  };
  /** Adds a user to an organization. */
  addOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AddOrganizationUserRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateOrganizationUserResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a user's membership in an organization. */
  getOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
        userId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetOrganizationUserResponsePayload"];
        };
      };
    };
  };
  /**
   * Updates the user's organization information.
   * @description Only includes organization-level information that can be modified by organization administrators.
   */
  updateOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
        userId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateOrganizationUserRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The user is not a member of the organization. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description An organization must have at least one owner; cannot change the role of an organization's only owner. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Removes a user from an organization.
   * @description Does not remove any data created by the user.
   */
  deleteOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
        userId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The user is not a member of the organization. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The user is the organization's only owner and an organization must have at least one owner. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Lists accessible projects. */
  listProjects: {
    parameters: {
      query?: {
        /** @description If specified, list projects in this organization. If absent, list projects in all the user's organizations. */
        organizationId?: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListProjectsResponsePayload"];
        };
      };
    };
  };
  /** Creates a new project. */
  createProject: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateProjectRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateProjectResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a specific project. */
  getProject: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetProjectResponsePayload"];
        };
      };
    };
  };
  /** Updates information about an existing project. */
  updateProject: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateProjectRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Deletes an existing project.
   * @description Any accessions, seedling batches, or planting sites that were assigned to the project will no longer be assigned to any project.
   */
  deleteProject: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Assigns multiple entities to a project.
   * @description Overwrites any existing project assignments.
   */
  assignProject: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AssignProjectRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Lists an organization's reports. */
  listReports: {
    parameters: {
      query: {
        organizationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListReportsResponsePayload"];
        };
      };
    };
  };
  /** Gets the report settings for an organization. */
  getReportSettings: {
    parameters: {
      query: {
        organizationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetReportSettingsResponsePayload"];
        };
      };
    };
  };
  /** Updates the report settings for an organization. */
  updateReportSettings: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateReportSettingsRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Retrieves the contents of a report. */
  getReport: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetReportResponsePayload"];
        };
      };
    };
  };
  /**
   * Updates a report.
   * @description The report must be locked by the current user.
   */
  updateReport: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PutReportRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The report is not locked by the current user. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Lists the files associated with a report. */
  listReportFiles: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListReportFilesResponsePayload"];
        };
      };
    };
  };
  /**
   * Locks a report.
   * @description Only succeeds if the report is not currently locked or if it is locked by the current user.
   */
  lockReport: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description The report is now locked by the current user. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The report was already locked by another user. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Locks a report even if it is locked by another user already. */
  forceLockReport: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description The report is now locked by the current user. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Lists the photos associated with a report. */
  listReportPhotos: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListReportPhotosResponsePayload"];
        };
      };
    };
  };
  /**
   * Submits a report.
   * @description The report must be locked by the current user. Submitting a report releases the lock. Once a report is submitted, it may no longer be locked or updated.
   */
  submitReport: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The report is missing required information and can't be submitted. */
      400: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The report is not locked by the current user or has already been submitted. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Releases the lock on a report. */
  unlockReport: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description The report is no longer locked. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The report is locked by another user. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Uploads a file to associate with a report. */
  uploadReportFile: {
    parameters: {
      path: {
        reportId: number;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UploadReportFileResponsePayload"];
        };
      };
    };
  };
  /** Downloads a file associated with a report. */
  downloadReportFile: {
    parameters: {
      path: {
        reportId: number;
        fileId: number;
      };
    };
    responses: {
      /** @description The file was successfully retrieved. */
      200: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  /** Deletes a file from a report. */
  deleteReportFile: {
    parameters: {
      path: {
        reportId: number;
        fileId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Uploads a photo to include with a report. */
  uploadReportPhoto: {
    parameters: {
      path: {
        reportId: number;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UploadReportFileResponsePayload"];
        };
      };
    };
  };
  /**
   * Gets the contents of a photo.
   * @description Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio.
   */
  getReportPhoto: {
    parameters: {
      query?: {
        /** @description Maximum desired width in pixels. If neither this nor maxHeight is specified, the full-sized original image will be returned. If this is specified, an image no wider than this will be returned. The image may be narrower than this value if needed to preserve the aspect ratio of the original. */
        maxWidth?: string;
        /** @description Maximum desired height in pixels. If neither this nor maxWidth is specified, the full-sized original image will be returned. If this is specified, an image no taller than this will be returned. The image may be shorter than this value if needed to preserve the aspect ratio of the original. */
        maxHeight?: string;
      };
      path: {
        reportId: number;
        photoId: number;
      };
    };
    responses: {
      /** @description The photo was successfully retrieved. */
      200: {
        content: {
          "image/jpeg": string;
          "image/png": string;
        };
      };
    };
  };
  /** Updates a photo's caption. */
  updateReportPhoto: {
    parameters: {
      path: {
        reportId: number;
        photoId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateReportPhotoRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Deletes a photo from a report. */
  deleteReportPhoto: {
    parameters: {
      path: {
        reportId: number;
        photoId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Exports selected fields from data matching a set of search criteria.
   * @description If a sublist field has multiple values, they are separated with line breaks in the exported file.
   */
  search_1: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SearchRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SearchResponsePayload"];
          "text/csv": string;
        };
      };
    };
  };
  /** Search for distinct values from data matching a set of search criteria. */
  searchDistinctValues: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SearchRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SearchValuesResponsePayload"];
        };
      };
    };
  };
  /** Deletes an existing accession. */
  delete: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Marks an accession as checked in. */
  checkIn: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets the history of changes to an accession. */
  getAccessionHistory: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetAccessionHistoryResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** List all the available photos for an accession. */
  listPhotos: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description The accession's photos are listed in the response. */
      200: {
        content: {
          "application/json": components["schemas"]["ListPhotosResponsePayload"];
        };
      };
      /** @description The accession does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Retrieve a specific photo from an accession.
   * @description Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio.
   */
  getPhoto: {
    parameters: {
      query?: {
        /** @description Maximum desired width in pixels. If neither this nor maxHeight is specified, the full-sized original image will be returned. If this is specified, an image no wider than this will be returned. The image may be narrower than this value if needed to preserve the aspect ratio of the original. */
        maxWidth?: string;
        /** @description Maximum desired height in pixels. If neither this nor maxWidth is specified, the full-sized original image will be returned. If this is specified, an image no taller than this will be returned. The image may be shorter than this value if needed to preserve the aspect ratio of the original. */
        maxHeight?: string;
      };
      path: {
        id: number;
        photoFilename: string;
      };
    };
    responses: {
      /** @description The photo was successfully retrieved. */
      200: {
        content: {
          "image/jpeg": string;
          "image/png": string;
        };
      };
      /** @description The accession does not exist, or does not have a photo with the requested filename. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Upload a new photo for an accession.
   * @description If there was already a photo with the specified filename, replaces it.
   */
  uploadPhoto: {
    parameters: {
      path: {
        id: number;
        photoFilename: string;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The specified accession does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Get the server's current date and time.
   * @description In test environments, the clock can be advanced artificially, which will cause it to differ from the real-world date and time.
   */
  getCurrentTime: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetCurrentTimeResponsePayload"];
        };
      };
    };
  };
  /** Records a log message from a device at a seed bank. */
  recordLogMessage: {
    parameters: {
      path: {
        /**
         * @description Source of the log message.
         * @example seedbank-app
         */
        tag: string;
      };
    };
    requestBody: {
      content: {
        "application/json": string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: never;
      };
    };
  };
  /** Get summary statistics about a specific seed bank or all seed banks within an organization. */
  getSeedBankSummary: {
    parameters: {
      query?: {
        /** @description If set, return summary on all seedbanks for that organization. */
        organizationId?: string;
        /** @description If set, return summary on that specific seedbank. */
        facilityId?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SummaryResponsePayload"];
        };
      };
    };
  };
  /** Get summary statistics about accessions that match a specified set of search criteria. */
  summarizeAccessionSearch: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SummarizeAccessionSearchRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SummarizeAccessionSearchResponsePayload"];
        };
      };
    };
  };
  /** List the values of a set of search fields for a set of accessions matching certain filter criteria. */
  listFieldValues: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ListFieldValuesRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListFieldValuesResponsePayload"];
        };
      };
    };
  };
  /** List the possible values of a set of search fields. */
  listAllFieldValues: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ListAllFieldValuesRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListAllFieldValuesResponsePayload"];
        };
      };
    };
  };
  /** Lists all the species available in an organization. */
  listSpecies: {
    parameters: {
      query: {
        /** @description Organization whose species should be listed. */
        organizationId: string;
        /** @description Only list species that are currently used in the organization's inventory, accessions or planting sites. */
        inUse?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListSpeciesResponsePayload"];
        };
      };
    };
  };
  /** Creates a new species. */
  createSpecies: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SpeciesRequestPayload"];
      };
    };
    responses: {
      /** @description Species created. */
      200: {
        content: {
          "application/json": components["schemas"]["CreateSpeciesResponsePayload"];
        };
      };
      /** @description A species with the requested name already exists. */
      409: {
        content: {
          "application/json": components["schemas"]["CreateSpeciesResponsePayload"];
        };
      };
    };
  };
  /** Gets more information about a species with a particular scientific name. */
  getSpeciesDetails: {
    parameters: {
      query: {
        /** @description Exact scientific name to look up. This name is case-sensitive. */
        scientificName: string;
        /**
         * @description If specified, only return common names in this language or whose language is unknown. Names with unknown languages are always included. This is a two-letter ISO 639-1 language code.
         * @example en
         */
        language?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SpeciesLookupDetailsResponsePayload"];
        };
      };
      /** @description The scientific name was not found in the server's taxonomic database. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** @description Gets a list of known scientific names whose words begin with particular letters. */
  listSpeciesNames: {
    parameters: {
      query: {
        /**
         * @description Space-delimited list of word prefixes to search for. Non-alphabetic characters are ignored, and matches are case-insensitive. The order of prefixes is significant; "ag sc" will match "Aglaonema schottianum" but won't match "Scabiosa agrestis".
         * @example ag sc
         */
        search: string;
        /** @description Maximum number of results to return. */
        maxResults?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SpeciesLookupNamesResponsePayload"];
        };
      };
    };
  };
  /** @description Returns details about a problem with a species. */
  getSpeciesProblem: {
    parameters: {
      path: {
        problemId: number;
      };
    };
    responses: {
      /** @description Problem retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesProblemResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Applies suggested changes to fix a problem with a species.
   * @description Only valid for problems that include suggested changes.
   */
  acceptProblemSuggestion: {
    parameters: {
      path: {
        problemId: number;
      };
    };
    responses: {
      /** @description Suggestion applied. Response contains the updated species information. */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description There is no suggested change for this problem. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Deletes information about a problem with a species without applying any suggested changes. */
  deleteProblem: {
    parameters: {
      path: {
        problemId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Uploads a list of species to add to the organization.
   * @description The uploaded file must be in CSV format. A template with the correct headers may be downloaded from the `/api/v1/species/uploads/template` endpoint.
   */
  uploadSpeciesList: {
    parameters: {
      query: {
        organizationId: number;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
    responses: {
      /** @description The file has been successfully received. It will be processed asynchronously; use the ID returned in the response payload to poll for its status using the `/api/v1/species/uploads/{uploadId}` GET endpoint. */
      200: {
        content: {
          "application/json": components["schemas"]["UploadFileResponsePayload"];
        };
      };
    };
  };
  /** Gets a template file that contains the required header row for species list uploads. */
  getSpeciesListUploadTemplate: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": string;
        };
      };
    };
  };
  /**
   * Gets the status of a species list uploaded previously.
   * @description Clients may poll this endpoint to monitor the progress of the file.
   */
  getSpeciesListUploadStatus: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetUploadStatusResponsePayload"];
        };
      };
    };
  };
  /**
   * Deletes a species list upload that is awaiting user action.
   * @description This may only be called if the status of the upload is "Awaiting User Action".
   */
  deleteSpeciesListUpload: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The upload was not awaiting user action. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Resolves the problems with a species list that is awaiting user action.
   * @description This may only be called if the status of the upload is "Awaiting User Action".
   */
  resolveSpeciesListUpload: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ResolveUploadRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The upload was not awaiting user action. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a single species. */
  getSpecies: {
    parameters: {
      query: {
        /** @description Organization whose information about the species should be returned. */
        organizationId: string;
      };
      path: {
        speciesId: number;
      };
    };
    responses: {
      /** @description Species retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Updates an existing species. */
  updateSpecies: {
    parameters: {
      path: {
        speciesId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SpeciesRequestPayload"];
      };
    };
    responses: {
      /** @description Species updated or merged with an existing species. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Deletes an existing species.
   * @description The species will no longer appear in the organization's list of species, but existing data (plants, seeds, etc.) that refer to the species will still refer to it.
   */
  deleteSpecies: {
    parameters: {
      path: {
        speciesId: number;
      };
    };
    responses: {
      /** @description Species deleted. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description Cannot delete the species because it is currently in use. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Lists the timeseries for one or more devices. */
  listTimeseries: {
    parameters: {
      query: {
        deviceId: number[];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListTimeseriesResponsePayload"];
        };
      };
    };
  };
  /**
   * Defines a list of timeseries for one or more devices.
   * @description If there are existing timeseries with the same names, the old definitions will be overwritten.
   */
  createMultipleTimeseries: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateTimeseriesRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Returns historical values of timeseries. */
  getTimeseriesHistory: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["GetTimeseriesHistoryRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetTimeseriesHistoryResponsePayload"];
        };
      };
    };
  };
  /** Records new values for one or more timeseries. */
  recordTimeseriesValues: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["RecordTimeseriesValuesRequestPayload"];
      };
    };
    responses: {
      /** @description Successfully processed the request. Note that this status will be returned even if the server was unable to record some of the values. In that case, the failed values will be returned in the response payload. */
      200: {
        content: {
          "application/json": components["schemas"]["RecordTimeseriesValuesResponsePayload"];
        };
      };
      /** @description The request was valid, but the user is still configuring or placing sensors, so the timeseries values have not been recorded. */
      202: {
        content: {
          "application/json": components["schemas"]["RecordTimeseriesValuesResponsePayload"];
        };
      };
      /** @description The request had more than 1000 values. */
      413: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a specific delivery of seedlings to a planting site. */
  getDelivery: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetDeliveryResponsePayload"];
        };
      };
    };
  };
  /** Reassigns some of the seedlings from a delivery to a different planting subzone. */
  reassignDelivery: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ReassignDeliveryRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Saves a draft of an in-progress planting site. */
  createDraftPlantingSite: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateDraftPlantingSiteRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateDraftPlantingSiteResponsePayload"];
        };
      };
    };
  };
  /** Gets the details of a saved draft of a planting site. */
  getDraftPlantingSite: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetDraftPlantingSiteResponsePayload"];
        };
      };
    };
  };
  /** Updates an existing draft of an in-progress planting site. */
  updateDraftPlantingSite: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateDraftPlantingSiteRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Deletes an existing draft of an in-progress planting site. */
  deleteDraftPlantingSite: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Gets an API token to use for displaying Mapbox maps.
   * @description Mapbox API tokens are short-lived; when a token expires, request a new one.
   */
  getMapboxToken: {
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetMapboxTokenResponsePayload"];
        };
      };
      /** @description The server is not configured to return Mapbox tokens. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The server is temporarily unable to generate a new Mapbox token. */
      503: {
        content: {
          "application/json": components["schemas"]["GetMapboxTokenResponsePayload"];
        };
      };
    };
  };
  /** Gets a list of observations of planting sites. */
  listObservations: {
    parameters: {
      query?: {
        /** @description Limit results to observations of planting sites in a specific organization. Ignored if plantingSiteId is specified. */
        organizationId?: string;
        /** @description Limit results to observations of a specific planting site. Required if organizationId is not specified. */
        plantingSiteId?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListObservationsResponsePayload"];
        };
      };
    };
  };
  /** Schedules a new observation. */
  scheduleObservation: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ScheduleObservationRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ScheduleObservationResponsePayload"];
        };
      };
    };
  };
  /** Gets a list of the results of observations. */
  listObservationResults: {
    parameters: {
      query?: {
        organizationId?: number;
        plantingSiteId?: number;
        /** @description Maximum number of results to return. Results are always returned in order of completion time, newest first, so setting this to 1 will return the results of the most recently completed observation. */
        limit?: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListObservationResultsResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a single observation. */
  getObservation: {
    parameters: {
      path: {
        observationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetObservationResponsePayload"];
        };
      };
    };
  };
  /** Reschedules an existing observation. */
  rescheduleObservation: {
    parameters: {
      path: {
        observationId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RescheduleObservationRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Gets a list of monitoring plots assigned to an observation. */
  listAssignedPlots: {
    parameters: {
      path: {
        observationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListAssignedPlotsResponsePayload"];
        };
      };
    };
  };
  /** Updates information about the observation of a plot. */
  updatePlotObservation: {
    parameters: {
      path: {
        observationId: number;
        plotId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdatePlotObservationRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Stores the results of a completed observation of a plot. */
  completePlotObservation: {
    parameters: {
      path: {
        observationId: number;
        plotId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CompletePlotObservationRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The observation of the plot was already completed. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Claims a monitoring plot.
   * @description A plot may only be claimed by one user at a time.
   */
  claimMonitoringPlot: {
    parameters: {
      path: {
        observationId: number;
        plotId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The plot is already claimed by someone else. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Uploads a photo of a monitoring plot. */
  uploadPlotPhoto: {
    parameters: {
      path: {
        observationId: number;
        plotId: number;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
          payload: components["schemas"]["UploadPlotPhotoRequestPayload"];
        };
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UploadPlotPhotoResponsePayload"];
        };
      };
    };
  };
  /**
   * Retrieves a specific photo from an observation of a monitoring plot.
   * @description Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio.
   */
  getPlotPhoto: {
    parameters: {
      query?: {
        /** @description Maximum desired width in pixels. If neither this nor maxHeight is specified, the full-sized original image will be returned. If this is specified, an image no wider than this will be returned. The image may be narrower than this value if needed to preserve the aspect ratio of the original. */
        maxWidth?: number;
        /** @description Maximum desired height in pixels. If neither this nor maxWidth is specified, the full-sized original image will be returned. If this is specified, an image no taller than this will be returned. The image may be shorter than this value if needed to preserve the aspect ratio of the original. */
        maxHeight?: number;
      };
      path: {
        observationId: number;
        plotId: number;
        fileId: number;
      };
    };
    responses: {
      /** @description The photo was successfully retrieved. */
      200: {
        content: {
          "image/jpeg": string;
          "image/png": string;
        };
      };
      /** @description The plot observation does not exist, or does not have a photo with the requested ID. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Releases the claim on a monitoring plot. */
  releaseMonitoringPlot: {
    parameters: {
      path: {
        observationId: number;
        plotId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description You don't have a claim on the plot. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Requests that a monitoring plot be replaced with a new one.
   * @description Additional monitoring plots may be replaced as well, e.g., if the requested plot is part of a permanent cluster. In some cases, the requested plot will be removed from the observation but not replaced with a different one.
   */
  replaceObservationPlot: {
    parameters: {
      path: {
        observationId: number;
        plotId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ReplaceObservationPlotRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["ReplaceObservationPlotResponsePayload"];
        };
      };
      /** @description The observation does not exist or does not have the requested monitoring plot. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The observation of the monitoring plot has already been completed and the plot cannot be replaced. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Gets the results of an observation of a planting site.
   * @description Some information is only available once all plots have been completed.
   */
  getObservationResults: {
    parameters: {
      path: {
        observationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetObservationResultsResponsePayload"];
        };
      };
    };
  };
  /**
   * Gets a list of an organization's planting sites.
   * @description The list can optionally contain information about planting zones and subzones.
   */
  listPlantingSites: {
    parameters: {
      query: {
        organizationId: number;
        /** @description If true, include planting zones and subzones for each site. */
        full?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListPlantingSitesResponsePayload"];
        };
      };
    };
  };
  /** Creates a new planting site. */
  createPlantingSite: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreatePlantingSiteRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreatePlantingSiteResponsePayload"];
        };
      };
    };
  };
  /**
   * Gets information about a specific planting site.
   * @description Includes information about the site's planting zones and subzones.
   */
  getPlantingSite: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetPlantingSiteResponsePayload"];
        };
      };
    };
  };
  /** Updates information about an existing planting site. */
  updatePlantingSite: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdatePlantingSiteRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Deletes a planting site.
   * @description Planting site should not have any plantings.
   */
  deletePlantingSite: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The planting site is in use, e.g., there are plantings allocated to the site. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Gets the total number of plants planted at a planting site and in each planting zone.
   * @description The totals are based on nursery withdrawals.
   */
  getPlantingSiteReportedPlants: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetPlantingSiteReportedPlantsResponsePayload"];
        };
      };
    };
  };
  /** Updates information about a planting subzone. */
  updatePlantingSubzone: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdatePlantingSubzoneRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Gets a list of the species that have been planted in a specific planting subzone.
   * @description The list is based on nursery withdrawals.
   */
  listPlantingSubzoneSpecies: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListPlantingSubzoneSpeciesResponsePayload"];
        };
      };
    };
  };
  /** Gets a user by some criteria, for now only email is available */
  searchUsers: {
    parameters: {
      query: {
        /** @description The email to use when searching for a user */
        email: string;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetUserResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets information about the current user. */
  getMyself: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetUserResponsePayload"];
        };
      };
    };
  };
  /** Updates information about the current user. */
  updateMyself: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateUserRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Deletes the current user's account.
   * @description WARNING! This operation is not reversible.
   */
  deleteMyself: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Gets the current user's preferences. */
  getUserPreferences: {
    parameters: {
      query?: {
        /** @description If present, get the user's per-organization preferences for this organization. If not present, get the user's global preferences. */
        organizationId?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetUserPreferencesResponsePayload"];
        };
      };
    };
  };
  /** Updates the current user's preferences. */
  updateUserPreferences: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateUserPreferencesRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Get a user by ID, if they exist, only ordinary users are supported. */
  getUser: {
    parameters: {
      path: {
        userId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetUserResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Apply the supplied global roles to the user. */
  updateGlobalRoles: {
    parameters: {
      path: {
        userId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateGlobalRolesRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets the minimum and recommended versions for Terraware's client applications. */
  getVersions: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["VersionsResponsePayload"];
        };
      };
    };
  };
  /** Creates a new accession. */
  createAccession: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateAccessionRequestPayloadV2"];
      };
    };
    responses: {
      /** @description The accession was created successfully. Response includes fields populated by the server, including the accession number and ID. */
      200: {
        content: {
          "application/json": components["schemas"]["CreateAccessionResponsePayloadV2"];
        };
      };
    };
  };
  /**
   * Uploads a list of accessions to add to the facility.
   * @description The uploaded file must be in CSV format. A template with the correct headers may be downloaded from the `/api/v2/seedbank/accessions/uploads/template` endpoint.
   */
  uploadAccessionsList: {
    parameters: {
      query: {
        facilityId: number;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
    responses: {
      /** @description The file has been successfully received. It will be processed asynchronously; use the ID returned in the response payload to poll for its status using the `/api/v2/seedbank/accessions/uploads/{uploadId}` GET endpoint. */
      200: {
        content: {
          "application/json": components["schemas"]["UploadFileResponsePayload"];
        };
      };
    };
  };
  /** Gets a template file that contains the required header row for accessions list uploads. */
  getAccessionsListUploadTemplate: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": string;
        };
      };
    };
  };
  /**
   * Gets the status of an accessions list uploaded previously.
   * @description Clients may poll this endpoint to monitor the progress of the file.
   */
  getAccessionsListUploadStatus: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetUploadStatusResponsePayload"];
        };
      };
    };
  };
  /**
   * Deletes an accessions list upload that is awaiting user action.
   * @description This may only be called if the status of the upload is "Awaiting User Action".
   */
  deleteAccessionsListUpload: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The upload was not awaiting user action. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Resolves the problems with an accessions list that is awaiting user action.
   * @description This may only be called if the status of the upload is "Awaiting User Action".
   */
  resolveAccessionsListUpload: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ResolveUploadRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The upload was not awaiting user action. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Transfers seeds to a nursery. */
  createNurseryTransferWithdrawal: {
    parameters: {
      path: {
        accessionId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateNurseryTransferRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateNurseryTransferResponsePayload"];
        };
      };
    };
  };
  /** List all of the accession's viability tests. */
  listViabilityTests: {
    parameters: {
      path: {
        accessionId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListViabilityTestsResponsePayload"];
        };
      };
    };
  };
  /**
   * Create a new viability test on an existing accession.
   * @description May cause the accession's remaining quantity to change.
   */
  createViabilityTest: {
    parameters: {
      path: {
        accessionId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateViabilityTestRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
  };
  /** Get a single viability test. */
  getViabilityTest: {
    parameters: {
      path: {
        accessionId: number;
        viabilityTestId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetViabilityTestResponsePayload"];
        };
      };
    };
  };
  /**
   * Update the details of an existing viability test.
   * @description May cause the accession's remaining quantity to change.
   */
  updateViabilityTest: {
    parameters: {
      path: {
        accessionId: number;
        viabilityTestId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateViabilityTestRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
  };
  /**
   * Delete an existing viability test.
   * @description May cause the accession's remaining quantity to change.
   */
  deleteViabilityTest: {
    parameters: {
      path: {
        accessionId: number;
        viabilityTestId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
  };
  /** List all the withdrawals from an accession. */
  listWithdrawals: {
    parameters: {
      path: {
        accessionId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetWithdrawalsResponsePayload"];
        };
      };
    };
  };
  /**
   * Create a new withdrawal on an existing accession.
   * @description May cause the accession's remaining quantity to change.
   */
  createWithdrawal: {
    parameters: {
      path: {
        accessionId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateWithdrawalRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
  };
  /** Get a single withdrawal. */
  getWithdrawal: {
    parameters: {
      path: {
        accessionId: number;
        withdrawalId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetWithdrawalResponsePayload"];
        };
      };
    };
  };
  /**
   * Update the details of an existing withdrawal.
   * @description May cause the accession's remaining quantity to change.
   */
  updateWithdrawal: {
    parameters: {
      path: {
        accessionId: number;
        withdrawalId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateWithdrawalRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
  };
  /**
   * Delete an existing withdrawal.
   * @description May cause the accession's remaining quantity to change.
   */
  deleteWithdrawal: {
    parameters: {
      path: {
        accessionId: number;
        withdrawalId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
  };
  /** Retrieve an existing accession. */
  getAccession: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetAccessionResponsePayloadV2"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Update an existing accession. */
  updateAccession: {
    parameters: {
      query?: {
        /** @description If true, do not actually save the accession; just return the result that would have been returned if it had been saved. */
        simulate?: string;
      };
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateAccessionRequestPayloadV2"];
      };
    };
    responses: {
      /** @description The accession was updated successfully. Response includes fields populated or modified by the server as a result of the update. */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
      /** @description The specified accession doesn't exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description One of the requested changes couldn't be made because the accession is in a state that doesn't allow the change. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
}
