/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/api/v1/automations": {
    get: operations["listAutomations"];
    post: operations["createAutomation"];
  };
  "/api/v1/automations/{automationId}": {
    get: operations["getAutomation"];
    put: operations["updateAutomation"];
    delete: operations["deleteAutomation"];
  };
  "/api/v1/automations/{automationId}/trigger": {
    post: operations["postAutomationTrigger"];
  };
  "/api/v1/devices": {
    post: operations["createDevice"];
  };
  "/api/v1/devices/managers": {
    get: operations["getDeviceManagers"];
  };
  "/api/v1/devices/managers/{deviceManagerId}": {
    get: operations["getDeviceManager"];
  };
  "/api/v1/devices/managers/{deviceManagerId}/connect": {
    post: operations["connectDeviceManager"];
  };
  "/api/v1/devices/templates": {
    get: operations["listDeviceTemplates"];
  };
  "/api/v1/devices/{id}": {
    get: operations["getDevice"];
    put: operations["updateDevice"];
  };
  "/api/v1/devices/{id}/unresponsive": {
    /** Notifies the appropriate users so they can troubleshoot the problem. */
    post: operations["deviceUnresponsive"];
  };
  "/api/v1/facilities": {
    get: operations["listAllFacilities_1"];
    post: operations["createFacility_1"];
  };
  "/api/v1/facilities/{facilityId}": {
    get: operations["getFacility"];
    put: operations["updateFacility"];
  };
  "/api/v1/facilities/{facilityId}/alert/send": {
    post: operations["sendFacilityAlert"];
  };
  "/api/v1/facilities/{facilityId}/configured": {
    /** After connecting a device manager and finishing any necessary configuration of the facility's devices, send this request to enable processing of timeseries values and alerts from the device manager. Only valid if the facility's connection state is `Connected`. */
    post: operations["postConfigured_1"];
  };
  "/api/v1/facilities/{facilityId}/devices": {
    get: operations["listFacilityDevices"];
  };
  "/api/v1/facility": {
    get: operations["listAllFacilities"];
    post: operations["createFacility"];
  };
  "/api/v1/facility/{facilityId}": {
    get: operations["getFacility_1"];
    put: operations["updateFacility_1"];
  };
  "/api/v1/facility/{facilityId}/alert/send": {
    post: operations["sendFacilityAlert_1"];
  };
  "/api/v1/facility/{facilityId}/configured": {
    /** After connecting a device manager and finishing any necessary configuration of the facility's devices, send this request to enable processing of timeseries values and alerts from the device manager. Only valid if the facility's connection state is `Connected`. */
    post: operations["postConfigured"];
  };
  "/api/v1/facility/{facilityId}/devices": {
    get: operations["listFacilityDevices_1"];
  };
  "/api/v1/i18n/timeZones": {
    get: operations["listTimeZoneNames"];
  };
  "/api/v1/login": {
    /** For interactive web applications, this can be used to redirect the user to a login page to allow the application to make other API requests. The login process will set a cookie that will authenticate to the API, and will then redirect back to the application. One approach is to use this in error response handlers: if an API request returns HTTP 401 Unauthorized, set location.href to this endpoint and set "redirect" to the URL of the page the user was on so they'll return there after logging in. */
    get: operations["login"];
  };
  "/api/v1/notifications": {
    get: operations["readAll"];
    put: operations["markAllRead"];
  };
  "/api/v1/notifications/count": {
    get: operations["count"];
  };
  "/api/v1/notifications/{id}": {
    get: operations["read"];
    put: operations["markRead"];
  };
  "/api/v1/nursery/batches": {
    post: operations["createBatch"];
  };
  "/api/v1/nursery/batches/uploads": {
    /** The uploaded file must be in CSV format. A template with the correct headers may be downloaded from the `/api/v1/nursery/batches/uploads/template` endpoint. */
    post: operations["uploadSeedlingBatchesList"];
  };
  "/api/v1/nursery/batches/uploads/template": {
    get: operations["getSeedlingBatchesUploadTemplate"];
  };
  "/api/v1/nursery/batches/uploads/{uploadId}": {
    /** Clients may poll this endpoint to monitor the progress of the file. */
    get: operations["getSeedlingBatchesListUploadStatus"];
  };
  "/api/v1/nursery/batches/{id}": {
    get: operations["getBatch"];
    put: operations["updateBatch"];
    delete: operations["deleteBatch"];
  };
  "/api/v1/nursery/batches/{id}/quantities": {
    put: operations["updateBatchQuantities"];
  };
  "/api/v1/nursery/species/{speciesId}/summary": {
    get: operations["getSpeciesSummary"];
  };
  "/api/v1/nursery/withdrawals": {
    post: operations["createBatchWithdrawal"];
  };
  "/api/v1/nursery/withdrawals/{withdrawalId}": {
    get: operations["getNurseryWithdrawal"];
  };
  "/api/v1/nursery/withdrawals/{withdrawalId}/photos": {
    get: operations["listWithdrawalPhotos"];
    post: operations["uploadWithdrawalPhoto"];
  };
  "/api/v1/nursery/withdrawals/{withdrawalId}/photos/{photoId}": {
    /** Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio. */
    get: operations["getWithdrawalPhoto"];
  };
  "/api/v1/organizations": {
    /** Lists all organizations the user can access. */
    get: operations["listOrganizations"];
    post: operations["createOrganization"];
  };
  "/api/v1/organizations/{organizationId}": {
    get: operations["getOrganization"];
    put: operations["updateOrganization"];
    /** Organizations can only be deleted if they have no members other than the current user. */
    delete: operations["deleteOrganization"];
  };
  "/api/v1/organizations/{organizationId}/roles": {
    get: operations["listOrganizationRoles"];
  };
  "/api/v1/organizations/{organizationId}/users": {
    get: operations["listOrganizationUsers"];
    post: operations["addOrganizationUser"];
  };
  "/api/v1/organizations/{organizationId}/users/{userId}": {
    get: operations["getOrganizationUser"];
    /** Only includes organization-level information that can be modified by organization administrators. */
    put: operations["updateOrganizationUser"];
    /** Does not remove any data created by the user. */
    delete: operations["deleteOrganizationUser"];
  };
  "/api/v1/reports": {
    get: operations["listReports"];
  };
  "/api/v1/reports/{id}": {
    get: operations["getReport"];
    /** The report must be locked by the current user. */
    put: operations["updateReport"];
  };
  "/api/v1/reports/{id}/files": {
    get: operations["listReportFiles"];
  };
  "/api/v1/reports/{id}/lock": {
    /** Only succeeds if the report is not currently locked or if it is locked by the current user. */
    post: operations["lockReport"];
  };
  "/api/v1/reports/{id}/lock/force": {
    post: operations["forceLockReport"];
  };
  "/api/v1/reports/{id}/photos": {
    get: operations["listReportPhotos"];
  };
  "/api/v1/reports/{id}/submit": {
    /** The report must be locked by the current user. Submitting a report releases the lock. Once a report is submitted, it may no longer be locked or updated. */
    post: operations["submitReport"];
  };
  "/api/v1/reports/{id}/unlock": {
    post: operations["unlockReport"];
  };
  "/api/v1/reports/{reportId}/files": {
    post: operations["uploadReportFile"];
  };
  "/api/v1/reports/{reportId}/files/{fileId}": {
    get: operations["downloadReportFile"];
    delete: operations["deleteReportFile"];
  };
  "/api/v1/reports/{reportId}/photos": {
    post: operations["uploadReportPhoto"];
  };
  "/api/v1/reports/{reportId}/photos/{photoId}": {
    /** Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio. */
    get: operations["getReportPhoto"];
    put: operations["updateReportPhoto"];
    delete: operations["deleteReportPhoto"];
  };
  "/api/v1/search": {
    post: operations["search_1"];
  };
  "/api/v1/seedbank/accessions/{id}": {
    delete: operations["delete"];
  };
  "/api/v1/seedbank/accessions/{id}/checkIn": {
    post: operations["checkIn"];
  };
  "/api/v1/seedbank/accessions/{id}/history": {
    get: operations["getAccessionHistory"];
  };
  "/api/v1/seedbank/accessions/{id}/photos": {
    get: operations["listPhotos"];
  };
  "/api/v1/seedbank/accessions/{id}/photos/{photoFilename}": {
    /** Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio. */
    get: operations["getPhoto"];
    post: operations["uploadPhoto"];
  };
  "/api/v1/seedbank/clock": {
    /** In test environments, the clock can be advanced artificially, which will cause it to differ from the real-world date and time. */
    get: operations["getCurrentTime"];
  };
  "/api/v1/seedbank/log/{tag}": {
    post: operations["recordLogMessage"];
  };
  "/api/v1/seedbank/storageLocations": {
    get: operations["listStorageLocations"];
    post: operations["createStorageLocation"];
  };
  "/api/v1/seedbank/storageLocations/{id}": {
    get: operations["getStorageLocation"];
    put: operations["updateStorageLocation"];
    delete: operations["deleteStorageLocation"];
  };
  "/api/v1/seedbank/summary": {
    get: operations["getSeedBankSummary"];
    post: operations["summarizeAccessionSearch"];
  };
  "/api/v1/seedbank/values": {
    post: operations["listFieldValues"];
  };
  "/api/v1/seedbank/values/all": {
    post: operations["listAllFieldValues"];
  };
  "/api/v1/species": {
    get: operations["listSpecies"];
    post: operations["createSpecies"];
  };
  "/api/v1/species/lookup/details": {
    get: operations["getSpeciesDetails"];
  };
  "/api/v1/species/lookup/names": {
    /** Gets a list of known scientific names whose words begin with particular letters. */
    get: operations["listSpeciesNames"];
  };
  "/api/v1/species/problems/{problemId}": {
    /** Returns details about a problem with a species. */
    get: operations["getSpeciesProblem"];
    /** Only valid for problems that include suggested changes. */
    post: operations["acceptProblemSuggestion"];
    delete: operations["deleteProblem"];
  };
  "/api/v1/species/uploads": {
    /** The uploaded file must be in CSV format. A template with the correct headers may be downloaded from the `/api/v1/species/uploads/template` endpoint. */
    post: operations["uploadSpeciesList"];
  };
  "/api/v1/species/uploads/template": {
    get: operations["getSpeciesListUploadTemplate"];
  };
  "/api/v1/species/uploads/{uploadId}": {
    /** Clients may poll this endpoint to monitor the progress of the file. */
    get: operations["getSpeciesListUploadStatus"];
    /** This may only be called if the status of the upload is "Awaiting User Action". */
    delete: operations["deleteSpeciesListUpload"];
  };
  "/api/v1/species/uploads/{uploadId}/resolve": {
    /** This may only be called if the status of the upload is "Awaiting User Action". */
    post: operations["resolveSpeciesListUpload"];
  };
  "/api/v1/species/{speciesId}": {
    get: operations["getSpecies"];
    put: operations["updateSpecies"];
    /** The species will no longer appear in the organization's list of species, but existing data (plants, seeds, etc.) that refer to the species will still refer to it. */
    delete: operations["deleteSpecies"];
  };
  "/api/v1/timeseries": {
    get: operations["listTimeseries"];
  };
  "/api/v1/timeseries/create": {
    /** If there are existing timeseries with the same names, the old definitions will be overwritten. */
    post: operations["createMultipleTimeseries"];
  };
  "/api/v1/timeseries/history": {
    post: operations["getTimeseriesHistory"];
  };
  "/api/v1/timeseries/values": {
    post: operations["recordTimeseriesValues"];
  };
  "/api/v1/tracking/deliveries/{id}": {
    get: operations["getDelivery"];
  };
  "/api/v1/tracking/deliveries/{id}/reassign": {
    post: operations["reassignDelivery"];
  };
  "/api/v1/tracking/mapbox/token": {
    get: operations["getMapboxToken"];
  };
  "/api/v1/tracking/sites": {
    get: operations["listPlantingSites"];
    post: operations["createPlantingSite"];
  };
  "/api/v1/tracking/sites/{id}": {
    get: operations["getPlantingSite"];
    put: operations["updatePlantingSite"];
  };
  "/api/v1/users/me": {
    get: operations["getMyself"];
    put: operations["updateMyself"];
    /** WARNING! This operation is not reversible. */
    delete: operations["deleteMyself"];
  };
  "/api/v1/users/me/preferences": {
    get: operations["getUserPreferences"];
    put: operations["updateUserPreferences"];
  };
  "/api/v1/versions": {
    get: operations["getVersions"];
  };
  "/api/v2/seedbank/accessions": {
    post: operations["createAccession"];
  };
  "/api/v2/seedbank/accessions/uploads": {
    /** The uploaded file must be in CSV format. A template with the correct headers may be downloaded from the `/api/v2/seedbank/accessions/uploads/template` endpoint. */
    post: operations["uploadAccessionsList"];
  };
  "/api/v2/seedbank/accessions/uploads/template": {
    get: operations["getAccessionsListUploadTemplate"];
  };
  "/api/v2/seedbank/accessions/uploads/{uploadId}": {
    /** Clients may poll this endpoint to monitor the progress of the file. */
    get: operations["getAccessionsListUploadStatus"];
    /** This may only be called if the status of the upload is "Awaiting User Action". */
    delete: operations["deleteAccessionsListUpload"];
  };
  "/api/v2/seedbank/accessions/uploads/{uploadId}/resolve": {
    /** This may only be called if the status of the upload is "Awaiting User Action". */
    post: operations["resolveAccessionsListUpload"];
  };
  "/api/v2/seedbank/accessions/{accessionId}/transfers/nursery": {
    post: operations["createNurseryTransferWithdrawal"];
  };
  "/api/v2/seedbank/accessions/{accessionId}/viabilityTests": {
    get: operations["listViabilityTests"];
    /** May cause the accession's remaining quantity to change. */
    post: operations["createViabilityTest"];
  };
  "/api/v2/seedbank/accessions/{accessionId}/viabilityTests/{viabilityTestId}": {
    get: operations["getViabilityTest"];
    /** May cause the accession's remaining quantity to change. */
    put: operations["updateViabilityTest"];
    /** May cause the accession's remaining quantity to change. */
    delete: operations["deleteViabilityTest"];
  };
  "/api/v2/seedbank/accessions/{accessionId}/withdrawals": {
    get: operations["listWithdrawals"];
    /** May cause the accession's remaining quantity to change. */
    post: operations["createWithdrawal"];
  };
  "/api/v2/seedbank/accessions/{accessionId}/withdrawals/{withdrawalId}": {
    get: operations["getWithdrawal"];
    /** May cause the accession's remaining quantity to change. */
    put: operations["updateWithdrawal"];
    /** May cause the accession's remaining quantity to change. */
    delete: operations["deleteWithdrawal"];
  };
  "/api/v2/seedbank/accessions/{id}": {
    get: operations["getAccession"];
    put: operations["updateAccession"];
  };
}

export interface components {
  schemas: {
    AccessionHistoryEntryPayload: {
      /** Format: date */
      date: string;
      /**
       * @description Human-readable description of the event. Does not include date or userName.
       * @example updated the status to Drying
       */
      description: string;
      /** @description Full name of the person responsible for the event, if known. */
      fullName?: string;
      /** @description User-entered notes about the event, if any. */
      notes?: string;
      type:
        | "Created"
        | "QuantityUpdated"
        | "StateChanged"
        | "ViabilityTesting"
        | "Withdrawal";
    };
    AccessionPayloadV2: {
      /** @description Server-generated human-readable identifier for the accession. This is unique within a single seed bank, but different seed banks may have accessions with the same number. */
      accessionNumber: string;
      /** @description Server-calculated active indicator. This is based on the accession's state. */
      active: "Inactive" | "Active";
      bagNumbers?: string[];
      /** Format: date */
      collectedDate?: string;
      collectionSiteCity?: string;
      collectionSiteCoordinates?: components["schemas"]["Geolocation"][];
      collectionSiteCountryCode?: string;
      collectionSiteCountrySubdivision?: string;
      collectionSiteLandowner?: string;
      collectionSiteName?: string;
      collectionSiteNotes?: string;
      collectionSource?: "Wild" | "Reintroduced" | "Cultivated" | "Other";
      /** @description Names of the people who collected the seeds. */
      collectors?: string[];
      /** Format: date */
      dryingEndDate?: string;
      /**
       * Format: int32
       * @description Estimated number of seeds remaining. Absent if there isn't enough information to calculate an estimate.
       */
      estimatedCount?: number;
      /** @description Estimated weight of seeds remaining. Absent if there isn't enough information to calculate an estimate. */
      estimatedWeight?: components["schemas"]["SeedQuantityPayload"];
      /** Format: int64 */
      facilityId: number;
      /**
       * Format: int64
       * @description Server-generated unique identifier for the accession. This is unique across all seed banks, but is not suitable for display to end users.
       */
      id: number;
      /** @description Most recent user observation of seeds remaining in the accession. This is not directly editable; it is updated by the server whenever the "remainingQuantity" field is edited. */
      latestObservedQuantity?: components["schemas"]["SeedQuantityPayload"];
      /**
       * Format: date-time
       * @description Time of most recent user observation of seeds remaining in the accession. This is updated by the server whenever the "remainingQuantity" field is edited.
       */
      latestObservedTime?: string;
      notes?: string;
      photoFilenames?: string[];
      plantId?: string;
      /**
       * Format: int32
       * @description Estimated number of plants the seeds were collected from.
       */
      plantsCollectedFrom?: number;
      /** Format: date */
      receivedDate?: string;
      /** @description Number or weight of seeds remaining for withdrawal and testing. May be calculated by the server after withdrawals. */
      remainingQuantity?: components["schemas"]["SeedQuantityPayload"];
      /** @description Which source of data this accession originally came from. */
      source?: "Web" | "Seed Collector App" | "File Import";
      /** @description Scientific name of the species. */
      speciesScientificName?: string;
      /** @description Common name of the species, if defined. */
      speciesCommonName?: string;
      /**
       * Format: int64
       * @description Server-generated unique ID of the species.
       */
      speciesId?: number;
      state:
        | "Awaiting Check-In"
        | "Awaiting Processing"
        | "Processing"
        | "Drying"
        | "In Storage"
        | "Used Up";
      storageLocation?: string;
      /** Format: int32 */
      subsetCount?: number;
      /** @description Weight of subset of seeds. Units must be a weight measurement, not "Seeds". */
      subsetWeight?: components["schemas"]["SeedQuantityPayload"];
      /**
       * Format: int32
       * @description Total number of seeds withdrawn. If withdrawals are measured by weight, this is an estimate based on the accession's subset count and weight.
       */
      totalWithdrawnCount?: number;
      /** @description Total weight of seeds withdrawn. If withdrawals are measured by seed count, this is an estimate based on the accession's subset count and weight. */
      totalWithdrawnWeight?: components["schemas"]["SeedQuantityPayload"];
      /** Format: int32 */
      viabilityPercent?: number;
      viabilityTests?: components["schemas"]["GetViabilityTestPayload"][];
      withdrawals?: components["schemas"]["GetWithdrawalPayload"][];
    };
    AddOrganizationUserRequestPayload: {
      email: string;
      role: "Contributor" | "Manager" | "Admin" | "Owner";
    };
    AllFieldValuesPayload: {
      /** @description All the values this field could possibly have, whether or not any accessions have them. For fields that allow the user to enter arbitrary values, this is equivalent to querying the list of values without any filter criteria, that is, it's a list of all the user-entered values. */
      values: string[];
      /** @description If true, the list of values is too long to return in its entirety and "values" is a partial list. */
      partial: boolean;
    };
    /** @description Search criterion that matches results that meet all of a set of other search criteria. That is, if the list of children is x, y, and z, this will require x AND y AND z. */
    AndNodePayload: components["schemas"]["SearchNodePayload"] & {
      /** @description List of criteria all of which must be satisfied */
      children?: components["schemas"]["SearchNodePayload"][];
    } & {
      children: unknown;
    };
    AnnualDetailsPayloadV1: {
      bestMonthsForObservation: number[];
      budgetNarrativeSummary?: string;
      catalyticDetail?: string;
      challenges?: string;
      isCatalytic: boolean;
      keyLessons?: string;
      nextSteps?: string;
      opportunities?: string;
      projectImpact?: string;
      projectSummary?: string;
      socialImpact?: string;
      successStories?: string;
      sustainableDevelopmentGoals: components["schemas"]["GoalProgressPayloadV1"][];
    };
    AutomationPayload: {
      /** Format: int64 */
      id: number;
      /** Format: int64 */
      facilityId: number;
      type: string;
      /** @description Short human-readable name of this automation. */
      name: string;
      /** @description Human-readable description of this automation. */
      description?: string;
      /** Format: int64 */
      deviceId?: number;
      timeseriesName?: string;
      /** Format: int32 */
      verbosity: number;
      /** Format: double */
      lowerThreshold?: number;
      /** Format: double */
      upperThreshold?: number;
      /** @description Client-defined configuration data for this automation. */
      settings?: { [key: string]: unknown };
    };
    AutomationTriggerRequestPayload: {
      /**
       * Format: double
       * @description For automations that are triggered by changes to timeseries values, the value that triggered the automation.
       */
      timeseriesValue?: number;
      /** @description Default message to publish if the automation type isn't yet supported by the server. */
      message?: string;
    };
    BatchPayload: {
      /**
       * Format: int64
       * @description If this batch was created via a seed withdrawal, the ID of the seed accession it came from.
       */
      accessionId?: number;
      /** Format: date */
      addedDate: string;
      batchNumber: string;
      /** Format: int64 */
      facilityId: number;
      /** Format: int32 */
      germinatingQuantity: number;
      /** Format: int64 */
      id: number;
      /** Format: date-time */
      latestObservedTime: string;
      notes?: string;
      /** Format: int32 */
      notReadyQuantity: number;
      /** Format: date */
      readyByDate?: string;
      /** Format: int32 */
      readyQuantity: number;
      /** Format: int64 */
      speciesId: number;
      /**
       * Format: int32
       * @description Increases every time a batch is updated. Must be passed as a parameter for certain kinds of write operations to detect when a batch has changed since the client last retrieved it.
       */
      version: number;
    };
    BatchResponsePayload: {
      batch: components["schemas"]["BatchPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    BatchWithdrawalPayload: {
      /** Format: int64 */
      batchId: number;
      /** Format: int32 */
      germinatingQuantityWithdrawn?: number;
      /** Format: int32 */
      notReadyQuantityWithdrawn: number;
      /** Format: int32 */
      readyQuantityWithdrawn: number;
    };
    /** @description Coordinate reference system used for X and Y coordinates in this geometry. By default, coordinates are in WGS 84, with longitude and latitude in degrees. In that case, this element is not present. Otherwise, it specifies which coordinate system to use. */
    CRS: {
      type: "name";
      properties: components["schemas"]["CRSProperties"];
    };
    CRSProperties: {
      /**
       * @description Name of the coordinate reference system. This must be in the form EPSG:nnnn where nnnn is the numeric identifier of a coordinate system in the EPSG dataset. The default is Longitude/Latitude EPSG:4326, which is the coordinate system +for GeoJSON.
       * @example EPSG:4326
       */
      name: string;
    };
    ConnectDeviceManagerRequestPayload: {
      /** Format: int64 */
      facilityId: number;
    };
    CreateAccessionRequestPayloadV2: {
      bagNumbers?: string[];
      /** Format: date */
      collectedDate?: string;
      collectionSiteCity?: string;
      collectionSiteCoordinates?: components["schemas"]["Geolocation"][];
      collectionSiteCountryCode?: string;
      collectionSiteCountrySubdivision?: string;
      collectionSiteLandowner?: string;
      collectionSiteName?: string;
      collectionSiteNotes?: string;
      collectionSource?: "Wild" | "Reintroduced" | "Cultivated" | "Other";
      collectors?: string[];
      /** Format: int64 */
      facilityId?: number;
      notes?: string;
      plantId?: string;
      /**
       * Format: int32
       * @description Estimated number of plants the seeds were collected from.
       */
      plantsCollectedFrom?: number;
      /** Format: date */
      receivedDate?: string;
      source?: "Web" | "Seed Collector App" | "File Import";
      /** Format: int64 */
      speciesId?: number;
      state?:
        | "Awaiting Check-In"
        | "Awaiting Processing"
        | "Processing"
        | "Drying"
        | "In Storage"
        | "Used Up";
      storageLocation?: string;
    };
    CreateAccessionResponsePayloadV2: {
      accession: components["schemas"]["AccessionPayloadV2"];
      status: components["schemas"]["SuccessOrError"];
    };
    CreateAutomationRequestPayload: {
      /** Format: int64 */
      facilityId: number;
      type: string;
      name: string;
      description?: string;
      /** Format: int64 */
      deviceId?: number;
      timeseriesName?: string;
      /** Format: int32 */
      verbosity?: number;
      /** Format: double */
      lowerThreshold?: number;
      /** Format: double */
      upperThreshold?: number;
      settings?: { [key: string]: unknown };
    };
    CreateAutomationResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateBatchRequestPayload: {
      /** Format: date */
      addedDate: string;
      /** Format: int64 */
      facilityId: number;
      notes?: string;
      /** Format: date */
      readyByDate?: string;
      /** Format: int64 */
      speciesId: number;
      /** Format: int32 */
      germinatingQuantity: number;
      /** Format: int32 */
      notReadyQuantity: number;
      /** Format: int32 */
      readyQuantity: number;
    };
    CreateDeviceRequestPayload: {
      /**
       * Format: int64
       * @description Identifier of facility where this device is located.
       */
      facilityId: number;
      /**
       * @description Name of this device.
       * @example BMU-1
       */
      name: string;
      /**
       * @description High-level type of the device. Device manager may use this in conjunction with the make and model to determine which metrics to report.
       * @example inverter
       */
      type: string;
      /**
       * @description Name of device manufacturer.
       * @example InHand Networks
       */
      make: string;
      /**
       * @description Model number or model name of the device.
       * @example IR915L
       */
      model: string;
      /**
       * @description Device manager protocol name.
       * @example modbus
       */
      protocol?: string;
      /**
       * @description Protocol-specific address of device, e.g., an IP address or a Bluetooth device ID.
       * @example 192.168.1.100
       */
      address?: string;
      /**
       * Format: int32
       * @description Port number if relevant for the protocol.
       * @example 50000
       */
      port?: number;
      /** @description Protocol- and device-specific custom settings. This is an arbitrary JSON object; the exact settings depend on the device type. */
      settings?: { [key: string]: unknown };
      /**
       * Format: int32
       * @description Level of diagnostic information to log.
       */
      verbosity?: number;
      /**
       * Format: int64
       * @description ID of parent device such as a hub or gateway, if any. The parent device must exist.
       */
      parentId?: number;
    };
    CreateFacilityRequestPayload: {
      /** Format: date */
      buildCompletedDate?: string;
      /** Format: date */
      buildStartedDate?: string;
      /**
       * Format: int32
       * @description For nursery facilities, the number of plants this nursery is capable of holding.
       */
      capacity?: number;
      description?: string;
      name: string;
      /** Format: date */
      operationStartedDate?: string;
      /**
       * Format: int64
       * @description Which organization this facility belongs to.
       */
      organizationId: number;
      storageLocationNames?: string[];
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
      type: "Seed Bank" | "Desalination" | "Reverse Osmosis" | "Nursery";
    };
    CreateFacilityResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateNurseryTransferRequestPayload: {
      /** Format: date */
      date: string;
      /** Format: int64 */
      destinationFacilityId: number;
      /** Format: int32 */
      germinatingQuantity: number;
      notes?: string;
      /** Format: int32 */
      notReadyQuantity: number;
      /** Format: date */
      readyByDate?: string;
      /** Format: int32 */
      readyQuantity: number;
      /**
       * Format: int64
       * @description ID of the user who withdrew the seeds. Default is the current user's ID. If non-null, the current user must have permission to read the referenced user's membership details in the organization.
       */
      withdrawnByUserId?: number;
    };
    CreateNurseryTransferResponsePayload: {
      /** @description Updated accession that includes a withdrawal for the nursery transfer. */
      accession: components["schemas"]["AccessionPayloadV2"];
      /** @description Details of newly-created seedling batch. */
      batch: components["schemas"]["BatchPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    CreateNurseryWithdrawalPhotoResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateNurseryWithdrawalRequestPayload: {
      batchWithdrawals: components["schemas"]["BatchWithdrawalPayload"][];
      /**
       * Format: int64
       * @description If purpose is "Nursery Transfer", the ID of the facility to transfer to. Must be in the same organization as the originating facility. Not allowed for purposes other than "Nursery Transfer".
       */
      destinationFacilityId?: number;
      /** Format: int64 */
      facilityId: number;
      notes?: string;
      /**
       * Format: int64
       * @description If purpose is "Out Plant", the ID of the planting site to which the seedlings were delivered.
       */
      plantingSiteId?: number;
      /**
       * Format: int64
       * @description If purpose is "Out Plant", the ID of the plot to which the seedlings were delivered. Must be specified if the planting site has plots, but must be omitted or set to null if the planting site has no plots.
       */
      plotId?: number;
      purpose: "Nursery Transfer" | "Dead" | "Out Plant" | "Other";
      /**
       * Format: date
       * @description If purpose is "Nursery Transfer", the estimated ready-by date to use for the batches that are created at the other nursery.
       */
      readyByDate?: string;
      /** Format: date */
      withdrawnDate: string;
    };
    CreateOrganizationRequestPayload: {
      /**
       * @description ISO 3166 alpha-2 code of organization's country.
       * @example AU
       */
      countryCode?: string;
      /**
       * @description ISO 3166-2 code of organization's country subdivision (state, province, region, etc.) This is the full ISO 3166-2 code including the country prefix. If this is set, countryCode must also be set.
       * @example US-HI
       */
      countrySubdivisionCode?: string;
      description?: string;
      name: string;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    CreateOrganizationUserResponsePayload: {
      /**
       * Format: int64
       * @description The ID of the newly-added user.
       */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreatePlantingSiteRequestPayload: {
      description?: string;
      name: string;
      /** Format: int64 */
      organizationId: number;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    CreatePlantingSiteResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateSpeciesResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateStorageLocationRequestPayload: {
      /** Format: int64 */
      facilityId: number;
      name: string;
    };
    CreateTimeseriesEntry: {
      /**
       * Format: int64
       * @description ID of device that produces this timeseries.
       */
      deviceId: number;
      /** @description Name of this timeseries. Duplicate timeseries names for the same device aren't allowed, but different devices can have timeseries with the same name. */
      timeseriesName: string;
      type: "Numeric" | "Text";
      /**
       * Format: int32
       * @description Number of significant fractional digits (after the decimal point), if this is a timeseries with non-integer numeric values.
       */
      decimalPlaces?: number;
      /**
       * @description Units of measure for values in this timeseries.
       * @example volts
       */
      units?: string;
    };
    CreateTimeseriesRequestPayload: {
      timeseries: components["schemas"]["CreateTimeseriesEntry"][];
    };
    CreateViabilityTestRequestPayload: {
      /** Format: date */
      endDate?: string;
      notes?: string;
      /** Format: int32 */
      seedsCompromised?: number;
      /** Format: int32 */
      seedsEmpty?: number;
      /** Format: int32 */
      seedsFilled?: number;
      /** Format: int32 */
      seedsTested: number;
      seedType?: "Fresh" | "Stored";
      /** Format: date */
      startDate?: string;
      substrate?:
        | "Nursery Media"
        | "Agar"
        | "Paper"
        | "Other"
        | "Sand"
        | "Media Mix"
        | "Soil"
        | "Moss"
        | "Perlite/Vermiculite"
        | "None";
      testResults?: components["schemas"]["ViabilityTestResultPayload"][];
      testType: "Lab" | "Nursery" | "Cut";
      treatment?:
        | "Soak"
        | "Scarify"
        | "Chemical"
        | "Stratification"
        | "Other"
        | "Light";
      /**
       * Format: int64
       * @description ID of user who withdrew seeds to perform the test. Defaults to the current user. If non-null, the current user must have permission to see the referenced user's membership details in the organization.
       */
      withdrawnByUserId?: number;
    };
    CreateWithdrawalRequestPayload: {
      /** Format: date */
      date?: string;
      purpose?: "Other" | "Viability Testing" | "Out-planting" | "Nursery";
      notes?: string;
      /**
       * Format: int64
       * @description ID of the user who withdrew the seeds. Default is the current user's ID. If non-null, the current user must have permission to read the referenced user's membership details in the organization.
       */
      withdrawnByUserId?: number;
      /** @description Quantity of seeds withdrawn. If this quantity is in weight and the remaining quantity of the accession is in seeds or vice versa, the accession must have a subset weight and count. */
      withdrawnQuantity?: components["schemas"]["SeedQuantityPayload"];
    };
    /** @description If the withdrawal was an outplanting to a planting site, the delivery that was created. Not present for other withdrawal purposes. */
    DeliveryPayload: {
      /** Format: int64 */
      id: number;
      plantings: components["schemas"]["PlantingPayload"][];
      /** Format: int64 */
      plantingSiteId: number;
      /** Format: int64 */
      withdrawalId: number;
    };
    DeviceConfig: {
      /**
       * Format: int64
       * @description Unique identifier of this device.
       */
      id: number;
      /**
       * Format: int64
       * @description Identifier of facility where this device is located.
       */
      facilityId: number;
      /**
       * @description Name of this device.
       * @example BMU-1
       */
      name: string;
      /**
       * @description High-level type of the device. Device manager may use this in conjunction with the make and model to determine which metrics to report.
       * @example inverter
       */
      type: string;
      /**
       * @description Name of device manufacturer.
       * @example InHand Networks
       */
      make: string;
      /**
       * @description Model number or model name of the device.
       * @example IR915L
       */
      model: string;
      /**
       * @description Device manager protocol name.
       * @example modbus
       */
      protocol?: string;
      /**
       * @description Protocol-specific address of device, e.g., an IP address or a Bluetooth device ID.
       * @example 192.168.1.100
       */
      address?: string;
      /**
       * Format: int32
       * @description Port number if relevant for the protocol.
       * @example 50000
       */
      port?: number;
      settings?: { [key: string]: unknown };
      /**
       * Format: int32
       * @description Level of diagnostic information to log.
       */
      verbosity?: number;
      /**
       * Format: int64
       * @description ID of parent device such as a hub or gateway, if any.
       */
      parentId?: number;
    };
    DeviceManagerPayload: {
      /** Format: int64 */
      id: number;
      sensorKitId: string;
      /** @description If true, this device manager is available to connect to a facility. */
      available: boolean;
      /**
       * Format: int64
       * @description The facility this device manager is connected to, or null if it is not connected.
       */
      facilityId?: number;
      /** @description If true, this device manager is currently online. */
      isOnline: boolean;
      /**
       * Format: date-time
       * @description When the device manager's isOnline value changed most recently. In other words, if isOnline is true, the device manager has been online since this time; if isOnline is false, the device manager has been offline since this time. This may be null if the device manager has not come online for the first time yet.
       */
      onlineChangedTime?: string;
      /**
       * Format: int32
       * @description If an update is being downloaded or installed, its progress as a percentage. Not present if no update is in progress.
       */
      updateProgress?: number;
    };
    DeviceTemplatePayload: {
      /** Format: int64 */
      id: number;
      category: "PV" | "Seed Bank Default";
      name: string;
      type: string;
      make: string;
      model: string;
      protocol?: string;
      address?: string;
      /** Format: int32 */
      port?: number;
      settings?: { [key: string]: unknown };
      /** Format: int32 */
      verbosity?: number;
    };
    DeviceUnresponsiveRequestPayload: {
      /**
       * Format: date-time
       * @description When the device most recently responded. Null or absent if the device has never responded.
       */
      lastRespondedTime?: string;
      /**
       * Format: int32
       * @description The expected amount of time between updates from the device. Null or absent if there is no fixed update interval.
       */
      expectedIntervalSecs?: number;
    };
    ErrorDetails: {
      message: string;
    };
    FacilityPayload: {
      /** Format: date */
      buildCompletedDate?: string;
      /** Format: date */
      buildStartedDate?: string;
      /**
       * Format: int32
       * @description For nursery facilities, the number of plants this nursery is capable of holding.
       */
      capacity?: number;
      connectionState: "Not Connected" | "Connected" | "Configured";
      /** Format: date-time */
      createdTime: string;
      description?: string;
      /** Format: int64 */
      id: number;
      name: string;
      /** Format: date */
      operationStartedDate?: string;
      /** Format: int64 */
      organizationId: number;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
      type: "Seed Bank" | "Desalination" | "Reverse Osmosis" | "Nursery";
    };
    FieldNodePayload: components["schemas"]["SearchNodePayload"] & {
      field?: string;
      /** @description List of values to match. For exact and fuzzy searches, a list of at least one value to search for; the list may include null to match accessions where the field does not have a value. For range searches, the list must contain exactly two values, the minimum and maximum; one of the values may be null to search for all values above a minimum or below a maximum. */
      values?: (string | null)[];
      type?: "Exact" | "ExactOrFuzzy" | "Fuzzy" | "Range";
    } & {
      field: unknown;
      type: unknown;
      values: unknown;
    };
    FieldValuesPayload: {
      /** @description List of values in the matching accessions. If there are accessions where the field has no value, this list will contain null (an actual null value, not the string "null"). */
      values: (string | null)[];
      /** @description If true, the list of values is too long to return in its entirety and "values" is a partial list. */
      partial: boolean;
    };
    Geolocation: {
      latitude: number;
      longitude: number;
      accuracy?: number;
    };
    GetAccessionHistoryResponsePayload: {
      /** @description History of changes in descending time order (newest first.) */
      history: components["schemas"]["AccessionHistoryEntryPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetAccessionResponsePayloadV2: {
      accession: components["schemas"]["AccessionPayloadV2"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetAutomationResponsePayload: {
      automation: components["schemas"]["AutomationPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetCurrentTimeResponsePayload: {
      /** Format: date-time */
      currentTime: string;
      status: components["schemas"]["SuccessOrError"];
    };
    GetDeliveryResponsePayload: {
      delivery: components["schemas"]["DeliveryPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetDeviceManagerResponsePayload: {
      manager: components["schemas"]["DeviceManagerPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetDeviceManagersResponsePayload: {
      /** @description List of device managers that match the conditions in the request. Empty if there were no matches, e.g., the requested short code didn't exist. */
      managers: components["schemas"]["DeviceManagerPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetDeviceResponsePayload: {
      device: components["schemas"]["DeviceConfig"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetFacilityResponse: {
      facility: components["schemas"]["FacilityPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetMapboxTokenResponsePayload: {
      token: string;
      status: components["schemas"]["SuccessOrError"];
    };
    GetNotificationResponsePayload: {
      notification: components["schemas"]["NotificationPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetNotificationsCountResponsePayload: {
      notifications: components["schemas"]["NotificationCountPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetNotificationsResponsePayload: {
      notifications: components["schemas"]["NotificationPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetNurseryV1: {
      /** Format: date */
      buildCompletedDate?: string;
      buildCompletedDateEditable: boolean;
      /** Format: date */
      buildStartedDate?: string;
      buildStartedDateEditable: boolean;
      /** Format: int32 */
      capacity?: number;
      /** Format: int64 */
      id: number;
      /** Format: int32 */
      mortalityRate: number;
      name: string;
      notes?: string;
      /** Format: date */
      operationStartedDate?: string;
      operationStartedDateEditable: boolean;
      selected: boolean;
      /** Format: int64 */
      totalPlantsPropagated: number;
      workers: components["schemas"]["WorkersPayloadV1"];
    };
    GetNurseryWithdrawalResponsePayload: {
      batches: components["schemas"]["BatchPayload"][];
      /** @description If the withdrawal was an outplanting to a planting site, the delivery that was created. Not present for other withdrawal purposes. */
      delivery?: components["schemas"]["DeliveryPayload"];
      withdrawal: components["schemas"]["NurseryWithdrawalPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetOrganizationResponsePayload: {
      organization: components["schemas"]["OrganizationPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetOrganizationUserResponsePayload: {
      user: components["schemas"]["OrganizationUserPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetPlantingSiteResponsePayload: {
      site: components["schemas"]["PlantingSitePayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetPlantingSiteSpeciesV1: {
      /** Format: int64 */
      id: number;
      /** Format: int32 */
      mortalityRateInField?: number;
      /** Format: int32 */
      mortalityRateInNursery?: number;
      /** Format: int32 */
      totalPlanted?: number;
    };
    GetPlantingSiteV1: {
      /** Format: int64 */
      id: number;
      /** Format: int32 */
      mortalityRate?: number;
      name: string;
      notes?: string;
      selected: boolean;
      species: components["schemas"]["GetPlantingSiteSpeciesV1"][];
      /** Format: int32 */
      totalPlantedArea?: number;
      /** Format: int32 */
      totalPlantingSiteArea?: number;
      /** Format: int32 */
      totalPlantsPlanted?: number;
      /** Format: int32 */
      totalTreesPlanted?: number;
      workers: components["schemas"]["WorkersPayloadV1"];
    };
    GetReportPayload: {
      /** Format: int64 */
      id: number;
      /** Format: int32 */
      year: number;
      lockedByName?: string;
      /** Format: int64 */
      lockedByUserId?: number;
      modifiedByName?: string;
      /** Format: int64 */
      modifiedByUserId?: number;
      submittedByName?: string;
      /** Format: int64 */
      submittedByUserId?: number;
      status: "New" | "In Progress" | "Locked" | "Submitted";
      /** Format: int32 */
      quarter: number;
      /** Format: date-time */
      modifiedTime?: string;
      /** Format: date-time */
      lockedTime?: string;
      /** Format: date-time */
      submittedTime?: string;
      version: string;
    };
    GetReportPayloadV1: components["schemas"]["GetReportPayload"] & {
      annualDetails?: components["schemas"]["AnnualDetailsPayloadV1"];
      isAnnual?: boolean;
      notes?: string;
      nurseries?: components["schemas"]["GetNurseryV1"][];
      organizationName?: string;
      plantingSites?: components["schemas"]["GetPlantingSiteV1"][];
      seedBanks?: components["schemas"]["GetSeedBankV1"][];
      summaryOfProgress?: string;
      /** Format: int32 */
      totalNurseries?: number;
      /** Format: int32 */
      totalPlantingSites?: number;
      /** Format: int32 */
      totalSeedBanks?: number;
    } & {
      id: unknown;
      isAnnual: unknown;
      nurseries: unknown;
      organizationName: unknown;
      plantingSites: unknown;
      quarter: unknown;
      seedBanks: unknown;
      status: unknown;
      totalNurseries: unknown;
      totalPlantingSites: unknown;
      totalSeedBanks: unknown;
      year: unknown;
    };
    GetReportResponsePayload: {
      report: components["schemas"]["GetReportPayloadV1"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetSeedBankV1: {
      /** Format: date */
      buildCompletedDate?: string;
      buildCompletedDateEditable: boolean;
      /** Format: date */
      buildStartedDate?: string;
      buildStartedDateEditable: boolean;
      /** Format: int64 */
      id: number;
      name: string;
      notes?: string;
      /** Format: date */
      operationStartedDate?: string;
      operationStartedDateEditable: boolean;
      selected: boolean;
      /** Format: int64 */
      totalSeedsStored: number;
      workers: components["schemas"]["WorkersPayloadV1"];
    };
    GetSpeciesProblemResponsePayload: {
      problem: components["schemas"]["SpeciesProblemElement"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetSpeciesResponsePayload: {
      species: components["schemas"]["SpeciesResponseElement"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetSpeciesSummaryResponsePayload: {
      summary: components["schemas"]["SpeciesSummaryPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetStorageLocationResponsePayload: {
      storageLocation: components["schemas"]["StorageLocationPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetTimeseriesHistoryRequestPayload: {
      /**
       * Format: date-time
       * @description Start of time range to query. If this is non-null, endTime must also be specified, and seconds must be null or absent.
       */
      startTime?: string;
      /**
       * Format: date-time
       * @description End of time range to query. If this is non-null, startTime must also be specified, and seconds must be null or absent.
       */
      endTime?: string;
      /**
       * Format: int64
       * @description Number of seconds in the past to start the time range. If this is non-null, startTime and endTime must be null or absent.
       */
      seconds?: number;
      /**
       * Format: int32
       * @description Number of values to return. The time range is divided into this many equal intervals, and a value is returned from each interval if available.
       */
      count: number;
      /** @description Timeseries to query. May be from different devices. */
      timeseries: components["schemas"]["TimeseriesIdPayload"][];
    };
    GetTimeseriesHistoryResponsePayload: {
      values: components["schemas"]["TimeseriesValuesPayload"][];
    };
    GetUploadStatusDetailsPayload: {
      /** Format: int64 */
      id: number;
      status:
        | "Receiving"
        | "Validating"
        | "Processing"
        | "Completed"
        | "Processing Failed"
        | "Invalid"
        | "Receiving Failed"
        | "Awaiting Validation"
        | "Awaiting User Action"
        | "Awaiting Processing";
      errors?: components["schemas"]["UploadProblemPayload"][];
      warnings?: components["schemas"]["UploadProblemPayload"][];
      /** @description True if the server is finished processing the file, either successfully or not. */
      finished: boolean;
    };
    GetUploadStatusResponsePayload: {
      details: components["schemas"]["GetUploadStatusDetailsPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetUserPreferencesResponsePayload: {
      /** @description The user's preferences, or null if no preferences have been stored yet. */
      preferences?: { [key: string]: unknown };
      status: components["schemas"]["SuccessOrError"];
    };
    GetUserResponsePayload: {
      user: components["schemas"]["UserProfilePayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetViabilityTestPayload: {
      /** Format: int64 */
      accessionId: number;
      /** Format: date */
      endDate?: string;
      /** Format: int64 */
      id: number;
      notes?: string;
      /** Format: int32 */
      seedsCompromised?: number;
      /** Format: int32 */
      seedsEmpty?: number;
      /** Format: int32 */
      seedsFilled?: number;
      /** Format: int32 */
      seedsTested: number;
      seedType?: "Fresh" | "Stored";
      /** Format: date */
      startDate?: string;
      substrate?:
        | "Nursery Media"
        | "Agar"
        | "Paper"
        | "Other"
        | "Sand"
        | "Media Mix"
        | "Soil"
        | "Moss"
        | "Perlite/Vermiculite"
        | "None";
      testResults?: components["schemas"]["ViabilityTestResultPayload"][];
      testType: "Lab" | "Nursery" | "Cut";
      /** Format: int32 */
      totalSeedsGerminated?: number;
      treatment?:
        | "Soak"
        | "Scarify"
        | "Chemical"
        | "Stratification"
        | "Other"
        | "Light";
      /**
       * Format: int32
       * @description Server-calculated viability percent for this test. For lab and nursery tests, this is based on the total seeds germinated across all test results. For cut tests, it is based on the number of seeds filled.
       */
      viabilityPercent?: number;
      /** @description Full name of user who withdrew seeds to perform the test. */
      withdrawnByName?: string;
      /**
       * Format: int64
       * @description ID of user who withdrew seeds to perform the test.
       */
      withdrawnByUserId?: number;
    };
    GetViabilityTestResponsePayload: {
      viabilityTest: components["schemas"]["GetViabilityTestPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetWithdrawalPayload: {
      /** Format: date */
      date: string;
      /**
       * Format: int32
       * @description Number of seeds withdrawn. Calculated by server. This is an estimate if "withdrawnQuantity" is a weight quantity and the accession has subset weight and count data. Absent if "withdrawnQuantity" is a weight quantity and the accession has no subset weight and count.
       */
      estimatedCount?: number;
      /** @description Weight of seeds withdrawn. Calculated by server. This is an estimate if "withdrawnQuantity" is a seed count and the accession has subset weight and count data. Absent if "withdrawnQuantity" is a seed count and the accession has no subset weight and count. */
      estimatedWeight?: components["schemas"]["SeedQuantityPayload"];
      /**
       * Format: int64
       * @description Server-assigned unique ID of this withdrawal.
       */
      id?: number;
      purpose?: "Other" | "Viability Testing" | "Out-planting" | "Nursery";
      notes?: string;
      /**
       * Format: int64
       * @description If this withdrawal is of purpose "Viability Testing", the ID of the test it is associated with.
       */
      viabilityTestId?: number;
      /** @description Full name of the person who withdrew the seeds. V1 COMPATIBILITY: This is the "staffResponsible" v1 field, which may not be the name of an organization user. */
      withdrawnByName?: string;
      /**
       * Format: int64
       * @description ID of the user who withdrew the seeds. Only present if the current user has permission to list the users in the organization. V1 COMPATIBILITY: Also absent if the withdrawal was written with the v1 API and we haven't yet written the code to figure out which user ID to assign.
       */
      withdrawnByUserId?: number;
      /** @description Quantity of seeds withdrawn. For viability testing withdrawals, this is always the same as the test's "seedsTested" value. */
      withdrawnQuantity?: components["schemas"]["SeedQuantityPayload"];
    };
    GetWithdrawalResponsePayload: {
      withdrawal: components["schemas"]["GetWithdrawalPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetWithdrawalsResponsePayload: {
      withdrawals: components["schemas"]["GetWithdrawalPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GoalProgressPayloadV1: {
      goal:
        | "NoPoverty"
        | "ZeroHunger"
        | "GoodHealth"
        | "QualityEducation"
        | "GenderEquality"
        | "CleanWater"
        | "AffordableEnergy"
        | "DecentWork"
        | "Industry"
        | "ReducedInequalities"
        | "SustainableCities"
        | "ResponsibleConsumption"
        | "ClimateAction"
        | "LifeBelowWater"
        | "LifeOnLand"
        | "Peace"
        | "Partnerships";
      progress?: string;
    };
    ListAllFieldValuesRequestPayload: {
      /** Format: int64 */
      facilityId?: number;
      fields: string[];
      /** Format: int64 */
      organizationId?: number;
    };
    ListAllFieldValuesResponsePayload: {
      results: {
        [key: string]: components["schemas"]["AllFieldValuesPayload"];
      };
      status: components["schemas"]["SuccessOrError"];
    };
    ListAutomationsResponsePayload: {
      automations: components["schemas"]["AutomationPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListDeviceConfigsResponse: {
      devices: components["schemas"]["DeviceConfig"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListDeviceTemplatesResponsePayload: {
      templates: components["schemas"]["DeviceTemplatePayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListFacilitiesResponse: {
      facilities: components["schemas"]["FacilityPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListFieldValuesRequestPayload: {
      /** Format: int64 */
      facilityId?: number;
      fields: string[];
      /** Format: int64 */
      organizationId?: number;
      search?:
        | components["schemas"]["AndNodePayload"]
        | components["schemas"]["FieldNodePayload"]
        | components["schemas"]["NotNodePayload"]
        | components["schemas"]["OrNodePayload"];
    };
    ListFieldValuesResponsePayload: {
      results: { [key: string]: components["schemas"]["FieldValuesPayload"] };
      status: components["schemas"]["SuccessOrError"];
    };
    ListOrganizationRolesResponsePayload: {
      roles: components["schemas"]["OrganizationRolePayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListOrganizationUsersResponsePayload: {
      users: components["schemas"]["OrganizationUserPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListOrganizationsResponsePayload: {
      organizations: components["schemas"]["OrganizationPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListPhotosResponseElement: {
      filename: string;
      /** Format: int64 */
      size: number;
    };
    ListPhotosResponsePayload: {
      photos: components["schemas"]["ListPhotosResponseElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListPlantingSitesResponsePayload: {
      sites: components["schemas"]["PlantingSitePayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListReportFilesResponseElement: {
      filename: string;
      /** Format: int64 */
      id: number;
    };
    ListReportFilesResponsePayload: {
      files: components["schemas"]["ListReportFilesResponseElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListReportPhotosResponseElement: {
      caption?: string;
      filename: string;
      /** Format: int64 */
      id: number;
    };
    ListReportPhotosResponsePayload: {
      photos: components["schemas"]["ListReportPhotosResponseElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListReportsResponseElement: {
      /** Format: int64 */
      id: number;
      lockedByName?: string;
      /** Format: int64 */
      lockedByUserId?: number;
      /** Format: date-time */
      lockedTime?: string;
      modifiedByName?: string;
      /** Format: int64 */
      modifiedByUserId?: number;
      /** Format: date-time */
      modifiedTime?: string;
      /** Format: int32 */
      quarter: number;
      status: "New" | "In Progress" | "Locked" | "Submitted";
      submittedByName?: string;
      /** Format: int64 */
      submittedByUserId?: number;
      /** Format: date-time */
      submittedTime?: string;
      /** Format: int32 */
      year: number;
    };
    ListReportsResponsePayload: {
      reports: components["schemas"]["ListReportsResponseElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListSpeciesResponsePayload: {
      species: components["schemas"]["SpeciesResponseElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListStorageLocationsResponsePayload: {
      storageLocations: components["schemas"]["StorageLocationPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListTimeZoneNamesResponsePayload: {
      timeZones: components["schemas"]["TimeZonePayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListTimeseriesResponsePayload: {
      timeseries: components["schemas"]["TimeseriesPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListViabilityTestsResponsePayload: {
      viabilityTests: components["schemas"]["GetViabilityTestPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListWithdrawalPhotosResponsePayload: {
      photos: components["schemas"]["NurseryWithdrawalPhotoPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    MultiPolygon: {
      coordinates: number[][][][];
      type: "MultiPolygon";
      crs?: components["schemas"]["CRS"];
    };
    /** @description Search criterion that matches results that do not match a set of search criteria. */
    NotNodePayload: components["schemas"]["SearchNodePayload"] & {
      child?: components["schemas"]["SearchNodePayload"];
    } & {
      child: unknown;
    };
    NotificationCountPayload: {
      /** Format: int64 */
      organizationId?: number;
      /** Format: int32 */
      unread: number;
    };
    NotificationPayload: {
      /** Format: int64 */
      id: number;
      notificationCriticality: "Info" | "Warning" | "Error" | "Success";
      /** Format: int64 */
      organizationId?: number;
      title: string;
      body: string;
      /** Format: uri */
      localUrl: string;
      /** Format: date-time */
      createdTime: string;
      isRead: boolean;
    };
    NurseryWithdrawalPayload: {
      batchWithdrawals: components["schemas"]["BatchWithdrawalPayload"][];
      /**
       * Format: int64
       * @description If purpose is "Nursery Transfer", the ID of the facility to which the seedlings were transferred.
       */
      destinationFacilityId?: number;
      /** Format: int64 */
      facilityId: number;
      /** Format: int64 */
      id: number;
      notes?: string;
      purpose: "Nursery Transfer" | "Dead" | "Out Plant" | "Other";
      /** Format: date */
      withdrawnDate: string;
    };
    NurseryWithdrawalPhotoPayload: {
      /** Format: int64 */
      id: number;
    };
    /** @description Search criterion that matches results that meet any of a set of other search criteria. That is, if the list of children is x, y, and z, this will require x OR y OR z. */
    OrNodePayload: components["schemas"]["SearchNodePayload"] & {
      /** @description List of criteria at least one of which must be satisfied */
      children?: components["schemas"]["SearchNodePayload"][];
    } & {
      children: unknown;
    };
    OrganizationPayload: {
      /** @description Whether this organization can submit reports to Terraformation. */
      canSubmitReports: boolean;
      /**
       * @description ISO 3166 alpha-2 code of organization's country.
       * @example AU
       */
      countryCode?: string;
      /**
       * @description ISO 3166-2 code of organization's country subdivision (state, province, region, etc.) This is the full ISO 3166-2 code including the country prefix. If this is set, countryCode will also be set.
       * @example US-HI
       */
      countrySubdivisionCode?: string;
      /** Format: date-time */
      createdTime: string;
      description?: string;
      /** @description This organization's facilities. Only included if depth is "Facility". */
      facilities?: components["schemas"]["FacilityPayload"][];
      /** Format: int64 */
      id: number;
      name: string;
      /** @description The current user's role in the organization. */
      role: "Contributor" | "Manager" | "Admin" | "Owner";
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
      /**
       * Format: int32
       * @description The total number of users in the organization, including the current user.
       */
      totalUsers: number;
    };
    OrganizationRolePayload: {
      role: "Contributor" | "Manager" | "Admin" | "Owner";
      /**
       * Format: int32
       * @description Total number of users in the organization with this role.
       */
      totalUsers: number;
    };
    OrganizationUserPayload: {
      /**
       * Format: date-time
       * @description Date and time the user was added to the organization.
       */
      addedTime: string;
      email: string;
      /** Format: int64 */
      id: number;
      /** @description The user's first name. Not present if the user has been added to the organization but has not signed up for an account yet. */
      firstName?: string;
      /** @description The user's last name. Not present if the user has been added to the organization but has not signed up for an account yet. */
      lastName?: string;
      role: "Contributor" | "Manager" | "Admin" | "Owner";
    };
    PlantingPayload: {
      /** Format: int64 */
      id: number;
      /** @description If type is "Reassignment To", the reassignment notes, if any. */
      notes?: string;
      /**
       * Format: int32
       * @description Number of plants planted or reassigned. If type is "Reassignment From", this will be negative.
       */
      numPlants: number;
      /** Format: int64 */
      plotId?: number;
      /** Format: int64 */
      speciesId: number;
      type: "Delivery" | "Reassignment From" | "Reassignment To";
    };
    PlantingSitePayload: {
      boundary?: components["schemas"]["MultiPolygon"];
      description?: string;
      /** Format: int64 */
      id: number;
      name: string;
      plantingZones?: components["schemas"]["PlantingZonePayload"][];
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    PlantingZonePayload: {
      boundary: components["schemas"]["MultiPolygon"];
      /** Format: int64 */
      id: number;
      name: string;
      plots: components["schemas"]["PlotPayload"][];
    };
    PlotPayload: {
      boundary: components["schemas"]["MultiPolygon"];
      fullName: string;
      /** Format: int64 */
      id: number;
      name: string;
    };
    PutNurseryV1: {
      /** Format: date */
      buildCompletedDate?: string;
      /** Format: date */
      buildStartedDate?: string;
      /** Format: int32 */
      capacity?: number;
      /** Format: int64 */
      id: number;
      notes?: string;
      /** Format: date */
      operationStartedDate?: string;
      selected: boolean;
      workers: components["schemas"]["WorkersPayloadV1"];
    };
    PutPlantingSiteSpeciesV1: {
      /** Format: int64 */
      id: number;
      /** Format: int32 */
      mortalityRateInField?: number;
      /** Format: int32 */
      mortalityRateInNursery?: number;
      /** Format: int32 */
      totalPlanted?: number;
    };
    PutPlantingSiteV1: {
      /** Format: int64 */
      id: number;
      notes?: string;
      selected: boolean;
      species: components["schemas"]["PutPlantingSiteSpeciesV1"][];
      /** Format: int32 */
      mortalityRate?: number;
      /** Format: int32 */
      totalPlantedArea?: number;
      /** Format: int32 */
      totalPlantingSiteArea?: number;
      /** Format: int32 */
      totalPlantsPlanted?: number;
      /** Format: int32 */
      totalTreesPlanted?: number;
      workers: components["schemas"]["WorkersPayloadV1"];
    };
    PutReportPayload: {
      version: string;
    };
    PutReportPayloadV1: components["schemas"]["PutReportPayload"] & {
      annualDetails?: components["schemas"]["AnnualDetailsPayloadV1"];
      notes?: string;
      nurseries?: components["schemas"]["PutNurseryV1"][];
      plantingSites?: components["schemas"]["PutPlantingSiteV1"][];
      seedBanks?: components["schemas"]["PutSeedBankV1"][];
      summaryOfProgress?: string;
    } & {
      nurseries: unknown;
      plantingSites: unknown;
      seedBanks: unknown;
    };
    PutReportRequestPayload: {
      report: components["schemas"]["PutReportPayloadV1"];
    };
    PutSeedBankV1: {
      /** Format: date */
      buildCompletedDate?: string;
      /** Format: date */
      buildStartedDate?: string;
      /** Format: int64 */
      id: number;
      notes?: string;
      /** Format: date */
      operationStartedDate?: string;
      selected: boolean;
      workers: components["schemas"]["WorkersPayloadV1"];
    };
    ReassignDeliveryRequestPayload: {
      reassignments: components["schemas"]["ReassignmentPayload"][];
    };
    ReassignmentPayload: {
      /** Format: int64 */
      fromPlantingId: number;
      /**
       * Format: int32
       * @description Number of plants to reassign from the planting's original plot to the new one. Must be less than or equal to the number of plants in the original planting.
       */
      numPlants: number;
      notes?: string;
      /** Format: int64 */
      toPlotId: number;
    };
    RecordTimeseriesValuesRequestPayload: {
      timeseries: components["schemas"]["TimeseriesValuesPayload"][];
    };
    /** @description Results of a request to record timeseries values. */
    RecordTimeseriesValuesResponsePayload: {
      /** @description List of values that the server failed to record. Will not be included if all the values were recorded successfully. */
      failures?: components["schemas"]["TimeseriesValuesErrorPayload"][];
      status: components["schemas"]["SuccessOrError"];
      error?: components["schemas"]["ErrorDetails"];
    };
    ResolveUploadRequestPayload: {
      /** @description If true, the data for entries that already exist will be overwritten with the values in the uploaded file. If false, only entries that don't already exist will be imported. */
      overwriteExisting: boolean;
    };
    /** @description A search criterion. The search will return results that match this criterion. The criterion can be composed of other search criteria to form arbitrary Boolean search expressions. TYPESCRIPT-OVERRIDE-TYPE-WITH-ANY */
    SearchNodePayload: any;
    SearchRequestPayload: {
      /**
       * @description Prefix for field names. This determines how field names are interpreted, and also how results are structured. Each element in the "results" array in the response will be an instance of whatever entity the prefix points to. Always evaluated starting from the "organizations" level. If not present, the search will return a list of organizations.
       * @example facilities.accessions
       */
      prefix?: string;
      /**
       * @description List of fields to return. Field names should be relative to the prefix. They may navigate the data hierarchy using '.' or '_' as delimiters.
       * @example processingStartDate,viabilityTests.seedsTested,facility_name
       */
      fields: string[];
      /** @description How to sort the search results. This controls both the order of the top-level results and the order of any lists of child objects. */
      sortOrder?: components["schemas"]["SearchSortOrderElement"][];
      search?:
        | components["schemas"]["AndNodePayload"]
        | components["schemas"]["FieldNodePayload"]
        | components["schemas"]["NotNodePayload"]
        | components["schemas"]["OrNodePayload"];
      /**
       * Format: int32
       * @description Maximum number of top-level search results to return. The system may impose a limit on this value. A separate system-imposed limit may also be applied to lists of child objects inside the top-level results. Use a value of 0 to return the maximum number of allowed results.
       * @default 25
       */
      count: number;
      /** @description Starting point for search results. If present, a previous search will be continued from where it left off. This should be the value of the cursor that was returned in the response to a previous search. */
      cursor?: string;
    };
    SearchResponsePayload: {
      results: { [key: string]: unknown }[];
      cursor?: string;
    };
    SearchSortOrderElement: {
      field: string;
      /** @default Ascending */
      direction?: "Ascending" | "Descending";
    };
    SeedCountSummaryPayload: {
      /**
       * Format: int64
       * @description Total number of seeds remaining. The sum of subtotalBySeedCount and subtotalByWeightEstimate.
       */
      total: number;
      /**
       * Format: int64
       * @description Total number of seeds remaining in accessions whose quantities are measured in seeds.
       */
      subtotalBySeedCount: number;
      /**
       * Format: int64
       * @description Estimated total number of seeds remaining in accessions whose quantities are measured by weight. This estimate is based on the subset weight and count. Accessions measured by weight that don't have subset weights and counts are not included in this estimate.
       */
      subtotalByWeightEstimate: number;
      /**
       * Format: int32
       * @description Number of accessions that are measured by weight and don't have subset weight and count data. The system cannot estimate how many seeds they have.
       */
      unknownQuantityAccessions: number;
    };
    /** @description Represents a quantity of seeds, measured either in individual seeds or by weight. */
    SeedQuantityPayload: {
      /** @description Number of units of seeds. If "units" is "Seeds", this is the number of seeds and must be an integer. Otherwise it is a measurement in the weight units specified in the "units" field, and may have a fractional part. */
      quantity: number;
      units:
        | "Seeds"
        | "Grams"
        | "Milligrams"
        | "Kilograms"
        | "Ounces"
        | "Pounds";
      /** @description If this quantity is a weight measurement, the weight in grams. This is not set if the "units" field is "Seeds". This is always calculated on the server side and is ignored on input. */
      grams?: number;
    };
    SendFacilityAlertRequestPayload: {
      subject: string;
      /** @description Alert body in plain text. HTML alerts are not supported yet. */
      body: string;
    };
    SimpleErrorResponsePayload: {
      error: components["schemas"]["ErrorDetails"];
      status: components["schemas"]["SuccessOrError"];
    };
    SimpleSuccessResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
    };
    SpeciesLookupCommonNamePayload: {
      name: string;
      /** @description ISO 639-1 two-letter language code indicating the name's language. Some common names in the server's taxonomic database are not tagged with languages; this value will not be present for those names. */
      language?: string;
    };
    SpeciesLookupDetailsResponsePayload: {
      scientificName: string;
      /** @description List of known common names for the species, if any. */
      commonNames?: components["schemas"]["SpeciesLookupCommonNamePayload"][];
      familyName: string;
      /** @description True if the species is known to be endangered, false if the species is known to not be endangered. This value will not be present if the server's taxonomic database doesn't indicate whether or not the species is endangered. */
      endangered?: boolean;
      /** @description If this is not the accepted name for the species, the type of problem the name has. Currently, this will always be "Name Is Synonym". */
      problemType?: "Name Misspelled" | "Name Not Found" | "Name Is Synonym";
      /** @description If this is not the accepted name for the species, the name to suggest as an alternative. */
      suggestedScientificName?: string;
    };
    SpeciesLookupNamesResponsePayload: {
      names: string[];
      /** @description True if there were more matching names than could be included in the response. */
      partial: boolean;
      status: components["schemas"]["SuccessOrError"];
    };
    SpeciesProblemElement: {
      /** Format: int64 */
      id: number;
      field: "Scientific Name";
      type: "Name Misspelled" | "Name Not Found" | "Name Is Synonym";
      /** @description Value for the field in question that would correct the problem. Absent if the system is unable to calculate a corrected value. */
      suggestedValue?: string;
    };
    SpeciesRequestPayload: {
      ecosystemTypes?: (
        | "Boreal forests/Taiga"
        | "Deserts and xeric shrublands"
        | "Flooded grasslands and savannas"
        | "Mangroves"
        | "Mediterranean forests, woodlands and scrubs"
        | "Montane grasslands and shrublands"
        | "Temperate broad leaf and mixed forests"
        | "Temperate coniferous forest"
        | "Temperate grasslands, savannas and shrublands"
        | "Tropical and subtropical coniferous forests"
        | "Tropical and subtropical dry broad leaf forests"
        | "Tropical and subtropical grasslands, savannas and shrublands"
        | "Tropical and subtropical moist broad leaf forests"
        | "Tundra"
      )[];
      commonName?: string;
      endangered?: boolean;
      familyName?: string;
      growthForm?: "Tree" | "Shrub" | "Forb" | "Graminoid" | "Fern";
      /**
       * Format: int64
       * @description Which organization's species list to update.
       */
      organizationId: number;
      rare?: boolean;
      scientificName: string;
      seedStorageBehavior?:
        | "Orthodox"
        | "Recalcitrant"
        | "Intermediate"
        | "Unknown";
    };
    SpeciesResponseElement: {
      ecosystemTypes?: (
        | "Boreal forests/Taiga"
        | "Deserts and xeric shrublands"
        | "Flooded grasslands and savannas"
        | "Mangroves"
        | "Mediterranean forests, woodlands and scrubs"
        | "Montane grasslands and shrublands"
        | "Temperate broad leaf and mixed forests"
        | "Temperate coniferous forest"
        | "Temperate grasslands, savannas and shrublands"
        | "Tropical and subtropical coniferous forests"
        | "Tropical and subtropical dry broad leaf forests"
        | "Tropical and subtropical grasslands, savannas and shrublands"
        | "Tropical and subtropical moist broad leaf forests"
        | "Tundra"
      )[];
      commonName?: string;
      endangered?: boolean;
      familyName?: string;
      growthForm?: "Tree" | "Shrub" | "Forb" | "Graminoid" | "Fern";
      /** Format: int64 */
      id: number;
      problems?: components["schemas"]["SpeciesProblemElement"][];
      rare?: boolean;
      scientificName: string;
      seedStorageBehavior?:
        | "Orthodox"
        | "Recalcitrant"
        | "Intermediate"
        | "Unknown";
    };
    SpeciesSummaryNurseryPayload: {
      /** Format: int64 */
      facilityId: number;
      name: string;
    };
    SpeciesSummaryPayload: {
      /** Format: int64 */
      germinatingQuantity: number;
      /**
       * Format: int32
       * @description Percentage of current and past inventory that was withdrawn due to death.
       */
      lossRate: number;
      /** Format: int64 */
      notReadyQuantity: number;
      nurseries: components["schemas"]["SpeciesSummaryNurseryPayload"][];
      /** Format: int64 */
      readyQuantity: number;
      /** Format: int64 */
      speciesId: number;
      /**
       * Format: int64
       * @description Total number of germinated plants that have been withdrawn due to death.
       */
      totalDead: number;
      /**
       * Format: int64
       * @description Total number of germinated plants currently in inventory.
       */
      totalQuantity: number;
      /**
       * Format: int64
       * @description Total number of germinated plants that have been withdrawn in the past.
       */
      totalWithdrawn: number;
    };
    StorageLocationPayload: {
      /** Format: int32 */
      activeAccessions: number;
      /** Format: int64 */
      facilityId: number;
      /** Format: int64 */
      id: number;
      name: string;
    };
    /** @description Indicates of success or failure of the requested operation. */
    SuccessOrError: "ok" | "error";
    SummarizeAccessionSearchRequestPayload: {
      search?:
        | components["schemas"]["AndNodePayload"]
        | components["schemas"]["FieldNodePayload"]
        | components["schemas"]["NotNodePayload"]
        | components["schemas"]["OrNodePayload"];
    };
    SummarizeAccessionSearchResponsePayload: {
      /** Format: int32 */
      accessions: number;
      /** Format: int32 */
      species: number;
      seedsRemaining: components["schemas"]["SeedCountSummaryPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    /** @description Summary of important statistics about the seed bank for the Summary page. */
    SummaryResponsePayload: {
      /** Format: int32 */
      activeAccessions: number;
      /** Format: int32 */
      species: number;
      /** @description Number of accessions in each state. */
      accessionsByState: { [key: string]: number };
      /** @description Summary of the number of seeds remaining across all active accessions. */
      seedsRemaining: components["schemas"]["SeedCountSummaryPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    TimeZonePayload: {
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      id: string;
      /**
       * @description Long name of time zone, possibly including a city name. This name is guaranteed to be unique across all zones.
       * @example Central European Time - Berlin
       */
      longName: string;
    };
    TimeseriesIdPayload: {
      /** Format: int64 */
      deviceId: number;
      timeseriesName: string;
    };
    TimeseriesPayload: {
      /**
       * Format: int64
       * @description ID of device that produces this timeseries.
       */
      deviceId: number;
      timeseriesName: string;
      type: "Numeric" | "Text";
      /**
       * Format: int32
       * @description Number of significant fractional digits (after the decimal point), if this is a timeseries with non-integer numeric values.
       */
      decimalPlaces?: number;
      /**
       * @description Units of measure for values in this timeseries.
       * @example volts
       */
      units?: string;
      /** @description If any values have been recorded for the timeseries, the latest one. */
      latestValue?: components["schemas"]["TimeseriesValuePayload"];
    };
    TimeseriesValuePayload: {
      /** Format: date-time */
      timestamp: string;
      /** @description Value to record. If the timeseries is of type Numeric, this must be a decimal or integer value in string form. If the timeseries is of type Text, this can be an arbitrary string. */
      value: string;
    };
    TimeseriesValuesErrorPayload: {
      /**
       * Format: int64
       * @description Device ID as specified in the failing request.
       */
      deviceId: number;
      /** @description Name of timeseries as specified in the failing request. */
      timeseriesName: string;
      /** @description Values that the server was not able to successfully record. */
      values: components["schemas"]["TimeseriesValuePayload"][];
      /** @description Human-readable details about the failure. */
      message: string;
    };
    TimeseriesValuesPayload: {
      /**
       * Format: int64
       * @description ID of device that produced this value.
       */
      deviceId: number;
      /** @description Name of timeseries. This must be the name of a timeseries that has already been created for the device. */
      timeseriesName: string;
      values: components["schemas"]["TimeseriesValuePayload"][];
    };
    UpdateAccessionRequestPayloadV2: {
      bagNumbers?: string[];
      /** Format: date */
      collectedDate?: string;
      collectionSiteCity?: string;
      collectionSiteCoordinates?: components["schemas"]["Geolocation"][];
      collectionSiteCountryCode?: string;
      collectionSiteCountrySubdivision?: string;
      collectionSiteLandowner?: string;
      collectionSiteName?: string;
      collectionSiteNotes?: string;
      collectionSource?: "Wild" | "Reintroduced" | "Cultivated" | "Other";
      collectors?: string[];
      /** Format: date */
      dryingEndDate?: string;
      /** Format: int64 */
      facilityId?: number;
      notes?: string;
      plantId?: string;
      /**
       * Format: int32
       * @description Estimated number of plants the seeds were collected from.
       */
      plantsCollectedFrom?: number;
      /** Format: date */
      receivedDate?: string;
      /** @description Quantity of seeds remaining in the accession. If this is different than the existing value, it is considered a new observation, and the new value will override any previously-calculated remaining quantities. */
      remainingQuantity?: components["schemas"]["SeedQuantityPayload"];
      /** Format: int64 */
      speciesId?: number;
      state?:
        | "Awaiting Check-In"
        | "Awaiting Processing"
        | "Processing"
        | "Drying"
        | "In Storage"
        | "Used Up";
      storageLocation?: string;
      /** Format: int32 */
      subsetCount?: number;
      /** @description Weight of subset of seeds. Units must be a weight measurement, not "Seeds". */
      subsetWeight?: components["schemas"]["SeedQuantityPayload"];
      /** Format: int32 */
      viabilityPercent?: number;
    };
    UpdateAccessionResponsePayloadV2: {
      accession: components["schemas"]["AccessionPayloadV2"];
      status: components["schemas"]["SuccessOrError"];
    };
    UpdateAutomationRequestPayload: {
      type: string;
      name: string;
      description?: string;
      /** Format: int64 */
      deviceId?: number;
      timeseriesName?: string;
      /** Format: int32 */
      verbosity?: number;
      /** Format: double */
      lowerThreshold?: number;
      /** Format: double */
      upperThreshold?: number;
      settings?: { [key: string]: unknown };
    };
    UpdateBatchQuantitiesRequestPayload: {
      /** Format: int32 */
      germinatingQuantity: number;
      /** Format: int32 */
      notReadyQuantity: number;
      /** Format: int32 */
      readyQuantity: number;
      /** Format: int32 */
      version: number;
    };
    UpdateBatchRequestPayload: {
      notes?: string;
      /** Format: date */
      readyByDate?: string;
      /** Format: int32 */
      version: number;
    };
    UpdateDeviceRequestPayload: {
      /**
       * @description Name of this device.
       * @example BMU-1
       */
      name: string;
      /**
       * @description High-level type of the device. Device manager may use this in conjunction with the make and model to determine which metrics to report.
       * @example inverter
       */
      type: string;
      /**
       * @description Name of device manufacturer.
       * @example InHand Networks
       */
      make: string;
      /**
       * @description Model number or model name of the device.
       * @example IR915L
       */
      model: string;
      /**
       * @description Device manager protocol name.
       * @example modbus
       */
      protocol?: string;
      /**
       * @description Protocol-specific address of device, e.g., an IP address or a Bluetooth device ID.
       * @example 192.168.1.100
       */
      address?: string;
      /**
       * Format: int32
       * @description Port number if relevant for the protocol.
       * @example 50000
       */
      port?: number;
      /** @description Protocol- and device-specific custom settings. This is an arbitrary JSON object; the exact settings depend on the device type. */
      settings?: { [key: string]: unknown };
      /**
       * Format: int32
       * @description Level of diagnostic information to log.
       */
      verbosity?: number;
      /**
       * Format: int64
       * @description ID of parent device such as a hub or gateway, if any. The parent device must exist.
       */
      parentId?: number;
    };
    UpdateFacilityRequestPayload: {
      /** Format: date */
      buildCompletedDate?: string;
      /** Format: date */
      buildStartedDate?: string;
      /**
       * Format: int32
       * @description For nursery facilities, the number of plants this nursery is capable of holding.
       */
      capacity?: number;
      description?: string;
      name: string;
      /** Format: date */
      operationStartedDate?: string;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    UpdateNotificationRequestPayload: {
      read: boolean;
    };
    UpdateNotificationsRequestPayload: {
      read: boolean;
      /** Format: int64 */
      organizationId?: number;
    };
    UpdateOrganizationRequestPayload: {
      /**
       * @description ISO 3166 alpha-2 code of organization's country.
       * @example AU
       */
      countryCode?: string;
      /**
       * @description ISO 3166-2 code of organization's country subdivision (state, province, region, etc.) This is the full ISO 3166-2 code including the country prefix. If this is set, countryCode must also be set.
       * @example US-HI
       */
      countrySubdivisionCode?: string;
      description?: string;
      name: string;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    UpdateOrganizationUserRequestPayload: {
      role: "Contributor" | "Manager" | "Admin" | "Owner";
    };
    UpdatePlantingSiteRequestPayload: {
      description?: string;
      name: string;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    UpdateReportPhotoRequestPayload: {
      caption?: string;
    };
    UpdateStorageLocationRequestPayload: {
      name: string;
    };
    UpdateUserPreferencesRequestPayload: {
      /**
       * Format: int64
       * @description If present, update the user's per-organization preferences for this organization. If not present, update the user's global preferences.
       */
      organizationId?: number;
      preferences: { [key: string]: unknown };
    };
    UpdateUserRequestPayload: {
      /** @description If true, the user wants to receive all the notifications for their organizations via email. This does not apply to certain kinds of notifications such as "You've been added to a new organization." If null, leave the existing value as-is. */
      emailNotificationsEnabled?: boolean;
      firstName: string;
      lastName: string;
      /**
       * @description IETF locale code containing user's preferred language.
       * @example en
       */
      locale?: string;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    UpdateViabilityTestRequestPayload: {
      /** Format: date */
      endDate?: string;
      notes?: string;
      /** Format: int32 */
      seedsCompromised?: number;
      /** Format: int32 */
      seedsEmpty?: number;
      /** Format: int32 */
      seedsFilled?: number;
      /** Format: int32 */
      seedsTested: number;
      seedType?: "Fresh" | "Stored";
      /** Format: date */
      startDate?: string;
      substrate?:
        | "Nursery Media"
        | "Agar"
        | "Paper"
        | "Other"
        | "Sand"
        | "Media Mix"
        | "Soil"
        | "Moss"
        | "Perlite/Vermiculite"
        | "None";
      testResults?: components["schemas"]["ViabilityTestResultPayload"][];
      treatment?:
        | "Soak"
        | "Scarify"
        | "Chemical"
        | "Stratification"
        | "Other"
        | "Light";
      /**
       * Format: int64
       * @description ID of user who withdrew seeds to perform the test. If non-null, the current user must have permission to see the referenced user's membership details in the organization. If absent or null, the existing value is left unchanged.
       */
      withdrawnByUserId?: number;
    };
    UpdateWithdrawalRequestPayload: {
      /** Format: date */
      date?: string;
      purpose?: "Other" | "Viability Testing" | "Out-planting" | "Nursery";
      notes?: string;
      /**
       * Format: int64
       * @description ID of the user who withdrew the seeds. Default is the withdrawal's existing user ID. If non-null, the current user must have permission to read the referenced user's membership details in the organization.
       */
      withdrawnByUserId?: number;
      /** @description Quantity of seeds withdrawn. For viability testing withdrawals, this is always the same as the test's "seedsTested" value. Otherwise, it is a user-supplied value. If this quantity is in weight and the remaining quantity of the accession is in seeds or vice versa, the accession must have a subset weight and count. */
      withdrawnQuantity?: components["schemas"]["SeedQuantityPayload"];
    };
    UploadFileResponsePayload: {
      /**
       * Format: int64
       * @description ID of uploaded file. This may be used to poll for the file's status.
       */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    /** @description List of conditions that might cause the user to want to cancel the upload but that can be automatically resolved if desired. */
    UploadProblemPayload: {
      /** @description Name of the field with the problem. Absent if the problem isn't specific to a single field. */
      fieldName?: string;
      /** @description Human-readable description of the problem. */
      message?: string;
      /**
       * Format: int32
       * @description Position (row number) of the record with the problem.
       */
      position?: number;
      type:
        | "Unrecognized Value"
        | "Missing Required Value"
        | "Duplicate Value"
        | "Malformed Value";
      /** @description The value that caused the problem. Absent if the problem wasn't caused by a specific field value. */
      value?: string;
    };
    UploadReportFileResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    UserProfilePayload: {
      /**
       * Format: int64
       * @description User's unique ID. This should not be shown to the user, but is a required input to some API endpoints.
       */
      id: number;
      email: string;
      /** @description If true, the user wants to receive all the notifications for their organizations via email. This does not apply to certain kinds of notifications such as "You've been added to a new organization." */
      emailNotificationsEnabled: boolean;
      firstName?: string;
      lastName?: string;
      /**
       * @description IETF locale code containing user's preferred language.
       * @example en
       */
      locale?: string;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    VersionsEntryPayload: {
      appName: string;
      platform: string;
      minimumVersion: string;
      recommendedVersion: string;
    };
    VersionsResponsePayload: {
      versions: components["schemas"]["VersionsEntryPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ViabilityTestResultPayload: {
      /** Format: date */
      recordingDate: string;
      /** Format: int32 */
      seedsGerminated: number;
    };
    WorkersPayloadV1: {
      /** Format: int32 */
      femalePaidWorkers?: number;
      /** Format: int32 */
      paidWorkers?: number;
      /** Format: int32 */
      volunteers?: number;
    };
  };
}

export interface operations {
  listAutomations: {
    parameters: {
      query: {
        deviceId?: number;
        facilityId?: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListAutomationsResponsePayload"];
        };
      };
    };
  };
  createAutomation: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateAutomationResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateAutomationRequestPayload"];
      };
    };
  };
  getAutomation: {
    parameters: {
      path: {
        automationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetAutomationResponsePayload"];
        };
      };
    };
  };
  updateAutomation: {
    parameters: {
      path: {
        automationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateAutomationRequestPayload"];
      };
    };
  };
  deleteAutomation: {
    parameters: {
      path: {
        automationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  postAutomationTrigger: {
    parameters: {
      path: {
        automationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AutomationTriggerRequestPayload"];
      };
    };
  };
  createDevice: {
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateDeviceRequestPayload"];
      };
    };
  };
  getDeviceManagers: {
    parameters: {
      query: {
        sensorKitId?: string;
        facilityId?: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetDeviceManagersResponsePayload"];
        };
      };
    };
  };
  getDeviceManager: {
    parameters: {
      path: {
        deviceManagerId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetDeviceManagerResponsePayload"];
        };
      };
    };
  };
  connectDeviceManager: {
    parameters: {
      path: {
        deviceManagerId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectDeviceManagerRequestPayload"];
      };
    };
  };
  listDeviceTemplates: {
    parameters: {
      query: {
        category?: "PV" | "Seed Bank Default";
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListDeviceTemplatesResponsePayload"];
        };
      };
    };
  };
  getDevice: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** Device configuration retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["GetDeviceResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  updateDevice: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** Device configuration updated. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateDeviceRequestPayload"];
      };
    };
  };
  /** Notifies the appropriate users so they can troubleshoot the problem. */
  deviceUnresponsive: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeviceUnresponsiveRequestPayload"];
      };
    };
  };
  listAllFacilities_1: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListFacilitiesResponse"];
        };
      };
    };
  };
  createFacility_1: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateFacilityResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateFacilityRequestPayload"];
      };
    };
  };
  getFacility: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetFacilityResponse"];
        };
      };
    };
  };
  updateFacility: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateFacilityRequestPayload"];
      };
    };
  };
  sendFacilityAlert: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The request was received, but the user is still configuring or placing sensors, so no notification has been generated. */
      202: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SendFacilityAlertRequestPayload"];
      };
    };
  };
  /** After connecting a device manager and finishing any necessary configuration of the facility's devices, send this request to enable processing of timeseries values and alerts from the device manager. Only valid if the facility's connection state is `Connected`. */
  postConfigured_1: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The facility's device manager was not in the process of being configured. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listFacilityDevices: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** Successfully listed the facility's devices. */
      200: {
        content: {
          "application/json": components["schemas"]["ListDeviceConfigsResponse"];
        };
      };
      /** The facility does not exist or is not accessible by the current user. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listAllFacilities: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListFacilitiesResponse"];
        };
      };
    };
  };
  createFacility: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateFacilityResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateFacilityRequestPayload"];
      };
    };
  };
  getFacility_1: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetFacilityResponse"];
        };
      };
    };
  };
  updateFacility_1: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateFacilityRequestPayload"];
      };
    };
  };
  sendFacilityAlert_1: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The request was received, but the user is still configuring or placing sensors, so no notification has been generated. */
      202: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SendFacilityAlertRequestPayload"];
      };
    };
  };
  /** After connecting a device manager and finishing any necessary configuration of the facility's devices, send this request to enable processing of timeseries values and alerts from the device manager. Only valid if the facility's connection state is `Connected`. */
  postConfigured: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The facility's device manager was not in the process of being configured. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listFacilityDevices_1: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** Successfully listed the facility's devices. */
      200: {
        content: {
          "application/json": components["schemas"]["ListDeviceConfigsResponse"];
        };
      };
      /** The facility does not exist or is not accessible by the current user. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listTimeZoneNames: {
    parameters: {
      query: {
        /** Language code and optional country code suffix. If not specified, the preferred locale from the Accept-Language header is used if supported; otherwise US English is the default. */
        locale?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListTimeZoneNamesResponsePayload"];
        };
      };
    };
  };
  /** For interactive web applications, this can be used to redirect the user to a login page to allow the application to make other API requests. The login process will set a cookie that will authenticate to the API, and will then redirect back to the application. One approach is to use this in error response handlers: if an API request returns HTTP 401 Unauthorized, set location.href to this endpoint and set "redirect" to the URL of the page the user was on so they'll return there after logging in. */
  login: {
    parameters: {
      query: {
        /** URL to redirect to after login. The list of valid redirect URLs is restricted; this must be the URL of a Terraware web application. */
        redirect: string;
      };
    };
    responses: {
      /** Redirects to a login page. After login, the user will be redirected back to the URL specified in the "redirect" parameter. */
      302: never;
    };
  };
  readAll: {
    parameters: {
      query: {
        /** If set, return notifications relevant to that organization. */
        organizationId?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNotificationsResponsePayload"];
        };
      };
    };
  };
  markAllRead: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateNotificationsRequestPayload"];
      };
    };
  };
  count: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNotificationsCountResponsePayload"];
        };
      };
    };
  };
  read: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNotificationResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  markRead: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateNotificationRequestPayload"];
      };
    };
  };
  createBatch: {
    responses: {
      /** The batch was created successfully. Response includes fields populated by the server, including the batch ID. */
      200: {
        content: {
          "application/json": components["schemas"]["BatchResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateBatchRequestPayload"];
      };
    };
  };
  /** The uploaded file must be in CSV format. A template with the correct headers may be downloaded from the `/api/v1/nursery/batches/uploads/template` endpoint. */
  uploadSeedlingBatchesList: {
    parameters: {
      query: {
        facilityId: number;
      };
    };
    responses: {
      /** The file has been successfully received. It will be processed asynchronously; use the ID returned in the response payload to poll for its status using the `/api/v1/nursery/batches/uploads/{uploadId}` GET endpoint. */
      200: {
        content: {
          "application/json": components["schemas"]["UploadFileResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
  };
  getSeedlingBatchesUploadTemplate: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": string;
        };
      };
    };
  };
  /** Clients may poll this endpoint to monitor the progress of the file. */
  getSeedlingBatchesListUploadStatus: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetUploadStatusResponsePayload"];
        };
      };
    };
  };
  getBatch: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["BatchResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  updateBatch: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** The batch was updated successfully. Response includes fields populated or modified by the server as a result of the update. */
      200: {
        content: {
          "application/json": components["schemas"]["BatchResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** The requested resource has a newer version and was not updated. */
      412: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateBatchRequestPayload"];
      };
    };
  };
  deleteBatch: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  updateBatchQuantities: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["BatchResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** The requested resource has a newer version and was not updated. */
      412: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateBatchQuantitiesRequestPayload"];
      };
    };
  };
  getSpeciesSummary: {
    parameters: {
      path: {
        speciesId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesSummaryResponsePayload"];
        };
      };
    };
  };
  createBatchWithdrawal: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNurseryWithdrawalResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateNurseryWithdrawalRequestPayload"];
      };
    };
  };
  getNurseryWithdrawal: {
    parameters: {
      path: {
        withdrawalId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNurseryWithdrawalResponsePayload"];
        };
      };
    };
  };
  listWithdrawalPhotos: {
    parameters: {
      path: {
        withdrawalId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListWithdrawalPhotosResponsePayload"];
        };
      };
      /** The withdrawal does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  uploadWithdrawalPhoto: {
    parameters: {
      path: {
        withdrawalId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateNurseryWithdrawalPhotoResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
  };
  /** Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio. */
  getWithdrawalPhoto: {
    parameters: {
      path: {
        withdrawalId: number;
        photoId: number;
      };
      query: {
        /** Maximum desired width in pixels. If neither this nor maxHeight is specified, the full-sized original image will be returned. If this is specified, an image no wider than this will be returned. The image may be narrower than this value if needed to preserve the aspect ratio of the original. */
        maxWidth?: string;
        /** Maximum desired height in pixels. If neither this nor maxWidth is specified, the full-sized original image will be returned. If this is specified, an image no taller than this will be returned. The image may be shorter than this value if needed to preserve the aspect ratio of the original. */
        maxHeight?: string;
      };
    };
    responses: {
      /** The photo was successfully retrieved. */
      200: {
        content: {
          "image/jpeg": string;
          "image/png": string;
        };
      };
      /** The withdrawal does not exist, or does not have a photo with the requested ID. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Lists all organizations the user can access. */
  listOrganizations: {
    parameters: {
      query: {
        /** Return this level of information about the organization's contents. */
        depth?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListOrganizationsResponsePayload"];
        };
      };
    };
  };
  createOrganization: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetOrganizationResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateOrganizationRequestPayload"];
      };
    };
  };
  getOrganization: {
    parameters: {
      path: {
        /** ID of organization to get. User must be a member of the organization. */
        organizationId: string;
      };
      query: {
        /** Return this level of information about the organization's contents. */
        depth?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetOrganizationResponsePayload"];
        };
      };
    };
  };
  updateOrganization: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateOrganizationRequestPayload"];
      };
    };
  };
  /** Organizations can only be deleted if they have no members other than the current user. */
  deleteOrganization: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The organization has other members and cannot be deleted. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listOrganizationRoles: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListOrganizationRolesResponsePayload"];
        };
      };
    };
  };
  listOrganizationUsers: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListOrganizationUsersResponsePayload"];
        };
      };
    };
  };
  addOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateOrganizationUserResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AddOrganizationUserRequestPayload"];
      };
    };
  };
  getOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
        userId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetOrganizationUserResponsePayload"];
        };
      };
    };
  };
  /** Only includes organization-level information that can be modified by organization administrators. */
  updateOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
        userId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The user is not a member of the organization. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** An organization must have at least one owner; cannot change the role of an organization's only owner. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateOrganizationUserRequestPayload"];
      };
    };
  };
  /** Does not remove any data created by the user. */
  deleteOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
        userId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The user is not a member of the organization. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** The user is the organization's only owner and an organization must have at least one owner. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listReports: {
    parameters: {
      query: {
        organizationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListReportsResponsePayload"];
        };
      };
    };
  };
  getReport: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetReportResponsePayload"];
        };
      };
    };
  };
  /** The report must be locked by the current user. */
  updateReport: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The report is not locked by the current user. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PutReportRequestPayload"];
      };
    };
  };
  listReportFiles: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListReportFilesResponsePayload"];
        };
      };
    };
  };
  /** Only succeeds if the report is not currently locked or if it is locked by the current user. */
  lockReport: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** The report is now locked by the current user. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The report was already locked by another user. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  forceLockReport: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** The report is now locked by the current user. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  listReportPhotos: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListReportPhotosResponsePayload"];
        };
      };
    };
  };
  /** The report must be locked by the current user. Submitting a report releases the lock. Once a report is submitted, it may no longer be locked or updated. */
  submitReport: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The report is missing required information and can't be submitted. */
      400: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** The report is not locked by the current user or has already been submitted. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  unlockReport: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** The report is no longer locked. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The report is locked by another user. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  uploadReportFile: {
    parameters: {
      path: {
        reportId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["UploadReportFileResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
  };
  downloadReportFile: {
    parameters: {
      path: {
        reportId: number;
        fileId: number;
      };
    };
    responses: {
      /** The file was successfully retrieved. */
      200: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  deleteReportFile: {
    parameters: {
      path: {
        reportId: number;
        fileId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  uploadReportPhoto: {
    parameters: {
      path: {
        reportId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["UploadReportFileResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
  };
  /** Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio. */
  getReportPhoto: {
    parameters: {
      path: {
        reportId: number;
        photoId: number;
      };
      query: {
        /** Maximum desired width in pixels. If neither this nor maxHeight is specified, the full-sized original image will be returned. If this is specified, an image no wider than this will be returned. The image may be narrower than this value if needed to preserve the aspect ratio of the original. */
        maxWidth?: string;
        /** Maximum desired height in pixels. If neither this nor maxWidth is specified, the full-sized original image will be returned. If this is specified, an image no taller than this will be returned. The image may be shorter than this value if needed to preserve the aspect ratio of the original. */
        maxHeight?: string;
      };
    };
    responses: {
      /** The photo was successfully retrieved. */
      200: {
        content: {
          "image/jpeg": string;
          "image/png": string;
        };
      };
    };
  };
  updateReportPhoto: {
    parameters: {
      path: {
        reportId: number;
        photoId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateReportPhotoRequestPayload"];
      };
    };
  };
  deleteReportPhoto: {
    parameters: {
      path: {
        reportId: number;
        photoId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  search_1: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SearchResponsePayload"];
          "text/csv": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SearchRequestPayload"];
      };
    };
  };
  delete: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  checkIn: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  getAccessionHistory: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetAccessionHistoryResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listPhotos: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** The accession's photos are listed in the response. */
      200: {
        content: {
          "application/json": components["schemas"]["ListPhotosResponsePayload"];
        };
      };
      /** The accession does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio. */
  getPhoto: {
    parameters: {
      path: {
        id: number;
        photoFilename: string;
      };
      query: {
        /** Maximum desired width in pixels. If neither this nor maxHeight is specified, the full-sized original image will be returned. If this is specified, an image no wider than this will be returned. The image may be narrower than this value if needed to preserve the aspect ratio of the original. */
        maxWidth?: string;
        /** Maximum desired height in pixels. If neither this nor maxWidth is specified, the full-sized original image will be returned. If this is specified, an image no taller than this will be returned. The image may be shorter than this value if needed to preserve the aspect ratio of the original. */
        maxHeight?: string;
      };
    };
    responses: {
      /** The photo was successfully retrieved. */
      200: {
        content: {
          "image/jpeg": string;
          "image/png": string;
        };
      };
      /** The accession does not exist, or does not have a photo with the requested filename. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  uploadPhoto: {
    parameters: {
      path: {
        id: number;
        photoFilename: string;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The specified accession does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** The requested photo already exists on the accession. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
  };
  /** In test environments, the clock can be advanced artificially, which will cause it to differ from the real-world date and time. */
  getCurrentTime: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetCurrentTimeResponsePayload"];
        };
      };
    };
  };
  recordLogMessage: {
    parameters: {
      path: {
        /** Source of the log message. */
        tag: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
    };
    requestBody: {
      content: {
        "application/json": string;
      };
    };
  };
  listStorageLocations: {
    parameters: {
      query: {
        facilityId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListStorageLocationsResponsePayload"];
        };
      };
    };
  };
  createStorageLocation: {
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetStorageLocationResponsePayload"];
        };
      };
      /** A storage location with the requested name already exists at the facility. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateStorageLocationRequestPayload"];
      };
    };
  };
  getStorageLocation: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetStorageLocationResponsePayload"];
        };
      };
    };
  };
  updateStorageLocation: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** A storage location with the requested name already exists at the facility. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateStorageLocationRequestPayload"];
      };
    };
  };
  deleteStorageLocation: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  getSeedBankSummary: {
    parameters: {
      query: {
        /** If set, return summary on all seedbanks for that organization. */
        organizationId?: string;
        /** If set, return summary on that specific seedbank. */
        facilityId?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SummaryResponsePayload"];
        };
      };
    };
  };
  summarizeAccessionSearch: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SummarizeAccessionSearchResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SummarizeAccessionSearchRequestPayload"];
      };
    };
  };
  listFieldValues: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListFieldValuesResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ListFieldValuesRequestPayload"];
      };
    };
  };
  listAllFieldValues: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListAllFieldValuesResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ListAllFieldValuesRequestPayload"];
      };
    };
  };
  listSpecies: {
    parameters: {
      query: {
        /** Organization whose species should be listed. */
        organizationId: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListSpeciesResponsePayload"];
        };
      };
    };
  };
  createSpecies: {
    responses: {
      /** Species created. */
      200: {
        content: {
          "application/json": components["schemas"]["CreateSpeciesResponsePayload"];
        };
      };
      /** A species with the requested name already exists. */
      409: {
        content: {
          "application/json": components["schemas"]["CreateSpeciesResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SpeciesRequestPayload"];
      };
    };
  };
  getSpeciesDetails: {
    parameters: {
      query: {
        /** Exact scientific name to look up. This name is case-sensitive. */
        scientificName: string;
        /** If specified, only return common names in this language or whose language is unknown. Names with unknown languages are always included. This is a two-letter ISO 639-1 language code. */
        language?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SpeciesLookupDetailsResponsePayload"];
        };
      };
      /** The scientific name was not found in the server's taxonomic database. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets a list of known scientific names whose words begin with particular letters. */
  listSpeciesNames: {
    parameters: {
      query: {
        /** Space-delimited list of word prefixes to search for. Non-alphabetic characters are ignored, and matches are case-insensitive. The order of prefixes is significant; "ag sc" will match "Aglaonema schottianum" but won't match "Scabiosa agrestis". */
        search: string;
        /** Maximum number of results to return. */
        maxResults?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SpeciesLookupNamesResponsePayload"];
        };
      };
    };
  };
  /** Returns details about a problem with a species. */
  getSpeciesProblem: {
    parameters: {
      path: {
        problemId: number;
      };
    };
    responses: {
      /** Problem retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesProblemResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Only valid for problems that include suggested changes. */
  acceptProblemSuggestion: {
    parameters: {
      path: {
        problemId: number;
      };
    };
    responses: {
      /** Suggestion applied. Response contains the updated species information. */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** There is no suggested change for this problem. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  deleteProblem: {
    parameters: {
      path: {
        problemId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** The uploaded file must be in CSV format. A template with the correct headers may be downloaded from the `/api/v1/species/uploads/template` endpoint. */
  uploadSpeciesList: {
    parameters: {
      query: {
        organizationId: number;
      };
    };
    responses: {
      /** The file has been successfully received. It will be processed asynchronously; use the ID returned in the response payload to poll for its status using the `/api/v1/species/uploads/{uploadId}` GET endpoint. */
      200: {
        content: {
          "application/json": components["schemas"]["UploadFileResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
  };
  getSpeciesListUploadTemplate: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": string;
        };
      };
    };
  };
  /** Clients may poll this endpoint to monitor the progress of the file. */
  getSpeciesListUploadStatus: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetUploadStatusResponsePayload"];
        };
      };
    };
  };
  /** This may only be called if the status of the upload is "Awaiting User Action". */
  deleteSpeciesListUpload: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The upload was not awaiting user action. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** This may only be called if the status of the upload is "Awaiting User Action". */
  resolveSpeciesListUpload: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The upload was not awaiting user action. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ResolveUploadRequestPayload"];
      };
    };
  };
  getSpecies: {
    parameters: {
      path: {
        speciesId: number;
      };
      query: {
        /** Organization whose information about the species should be returned. */
        organizationId: string;
      };
    };
    responses: {
      /** Species retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  updateSpecies: {
    parameters: {
      path: {
        speciesId: number;
      };
    };
    responses: {
      /** Species updated or merged with an existing species. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SpeciesRequestPayload"];
      };
    };
  };
  /** The species will no longer appear in the organization's list of species, but existing data (plants, seeds, etc.) that refer to the species will still refer to it. */
  deleteSpecies: {
    parameters: {
      path: {
        speciesId: number;
      };
      query: {
        /** Organization from which the species should be deleted. */
        organizationId: string;
      };
    };
    responses: {
      /** Species deleted. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** Cannot delete the species because it is currently in use. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listTimeseries: {
    parameters: {
      query: {
        deviceId: number[];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListTimeseriesResponsePayload"];
        };
      };
    };
  };
  /** If there are existing timeseries with the same names, the old definitions will be overwritten. */
  createMultipleTimeseries: {
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateTimeseriesRequestPayload"];
      };
    };
  };
  getTimeseriesHistory: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetTimeseriesHistoryResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["GetTimeseriesHistoryRequestPayload"];
      };
    };
  };
  recordTimeseriesValues: {
    responses: {
      /** Successfully processed the request. Note that this status will be returned even if the server was unable to record some of the values. In that case, the failed values will be returned in the response payload. */
      200: {
        content: {
          "application/json": components["schemas"]["RecordTimeseriesValuesResponsePayload"];
        };
      };
      /** The request was valid, but the user is still configuring or placing sensors, so the timeseries values have not been recorded. */
      202: {
        content: {
          "application/json": components["schemas"]["RecordTimeseriesValuesResponsePayload"];
        };
      };
      /** The request had more than 1000 values. */
      413: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RecordTimeseriesValuesRequestPayload"];
      };
    };
  };
  getDelivery: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetDeliveryResponsePayload"];
        };
      };
    };
  };
  reassignDelivery: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ReassignDeliveryRequestPayload"];
      };
    };
  };
  getMapboxToken: {
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetMapboxTokenResponsePayload"];
        };
      };
      /** The server is not configured to return Mapbox tokens. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** The server is temporarily unable to generate a new Mapbox token. */
      503: {
        content: {
          "application/json": components["schemas"]["GetMapboxTokenResponsePayload"];
        };
      };
    };
  };
  listPlantingSites: {
    parameters: {
      query: {
        organizationId: number;
        /** If true, include planting zones and plots for each site. */
        full?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListPlantingSitesResponsePayload"];
        };
      };
    };
  };
  createPlantingSite: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreatePlantingSiteResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreatePlantingSiteRequestPayload"];
      };
    };
  };
  getPlantingSite: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetPlantingSiteResponsePayload"];
        };
      };
    };
  };
  updatePlantingSite: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdatePlantingSiteRequestPayload"];
      };
    };
  };
  getMyself: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetUserResponsePayload"];
        };
      };
    };
  };
  updateMyself: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateUserRequestPayload"];
      };
    };
  };
  /** WARNING! This operation is not reversible. */
  deleteMyself: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  getUserPreferences: {
    parameters: {
      query: {
        /** If present, get the user's per-organization preferences for this organization. If not present, get the user's global preferences. */
        organizationId?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetUserPreferencesResponsePayload"];
        };
      };
    };
  };
  updateUserPreferences: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateUserPreferencesRequestPayload"];
      };
    };
  };
  getVersions: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["VersionsResponsePayload"];
        };
      };
    };
  };
  createAccession: {
    responses: {
      /** The accession was created successfully. Response includes fields populated by the server, including the accession number and ID. */
      200: {
        content: {
          "application/json": components["schemas"]["CreateAccessionResponsePayloadV2"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateAccessionRequestPayloadV2"];
      };
    };
  };
  /** The uploaded file must be in CSV format. A template with the correct headers may be downloaded from the `/api/v2/seedbank/accessions/uploads/template` endpoint. */
  uploadAccessionsList: {
    parameters: {
      query: {
        facilityId: number;
      };
    };
    responses: {
      /** The file has been successfully received. It will be processed asynchronously; use the ID returned in the response payload to poll for its status using the `/api/v2/seedbank/accessions/uploads/{uploadId}` GET endpoint. */
      200: {
        content: {
          "application/json": components["schemas"]["UploadFileResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
  };
  getAccessionsListUploadTemplate: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": string;
        };
      };
    };
  };
  /** Clients may poll this endpoint to monitor the progress of the file. */
  getAccessionsListUploadStatus: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetUploadStatusResponsePayload"];
        };
      };
    };
  };
  /** This may only be called if the status of the upload is "Awaiting User Action". */
  deleteAccessionsListUpload: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The upload was not awaiting user action. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** This may only be called if the status of the upload is "Awaiting User Action". */
  resolveAccessionsListUpload: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The upload was not awaiting user action. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ResolveUploadRequestPayload"];
      };
    };
  };
  createNurseryTransferWithdrawal: {
    parameters: {
      path: {
        accessionId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateNurseryTransferResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateNurseryTransferRequestPayload"];
      };
    };
  };
  listViabilityTests: {
    parameters: {
      path: {
        accessionId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListViabilityTestsResponsePayload"];
        };
      };
    };
  };
  /** May cause the accession's remaining quantity to change. */
  createViabilityTest: {
    parameters: {
      path: {
        accessionId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateViabilityTestRequestPayload"];
      };
    };
  };
  getViabilityTest: {
    parameters: {
      path: {
        accessionId: number;
        viabilityTestId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetViabilityTestResponsePayload"];
        };
      };
    };
  };
  /** May cause the accession's remaining quantity to change. */
  updateViabilityTest: {
    parameters: {
      path: {
        accessionId: number;
        viabilityTestId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateViabilityTestRequestPayload"];
      };
    };
  };
  /** May cause the accession's remaining quantity to change. */
  deleteViabilityTest: {
    parameters: {
      path: {
        accessionId: number;
        viabilityTestId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
  };
  listWithdrawals: {
    parameters: {
      path: {
        accessionId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetWithdrawalsResponsePayload"];
        };
      };
    };
  };
  /** May cause the accession's remaining quantity to change. */
  createWithdrawal: {
    parameters: {
      path: {
        accessionId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateWithdrawalRequestPayload"];
      };
    };
  };
  getWithdrawal: {
    parameters: {
      path: {
        accessionId: number;
        withdrawalId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetWithdrawalResponsePayload"];
        };
      };
    };
  };
  /** May cause the accession's remaining quantity to change. */
  updateWithdrawal: {
    parameters: {
      path: {
        accessionId: number;
        withdrawalId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateWithdrawalRequestPayload"];
      };
    };
  };
  /** May cause the accession's remaining quantity to change. */
  deleteWithdrawal: {
    parameters: {
      path: {
        accessionId: number;
        withdrawalId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
  };
  getAccession: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetAccessionResponsePayloadV2"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  updateAccession: {
    parameters: {
      path: {
        id: number;
      };
      query: {
        /** If true, do not actually save the accession; just return the result that would have been returned if it had been saved. */
        simulate?: string;
      };
    };
    responses: {
      /** The accession was updated successfully. Response includes fields populated or modified by the server as a result of the update. */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
      /** The specified accession doesn't exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateAccessionRequestPayloadV2"];
      };
    };
  };
}

export interface external {}
