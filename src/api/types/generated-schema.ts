/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


/** WithRequired type helpers */
type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };

export interface paths {
  "/api/v1/accelerator/applications": {
    /**
     * List all the applications with optional search criteria
     * @description Only applications visible to the current user are returned.
     */
    get: operations["listApplications"];
    /** Create a new application */
    post: operations["createApplication"];
  };
  "/api/v1/accelerator/applications/{applicationId}": {
    /** Get information about an application */
    get: operations["getApplication"];
  };
  "/api/v1/accelerator/applications/{applicationId}/boundary": {
    /** Update an application's boundary */
    put: operations["updateApplicationBoundary"];
    /** Update an application's boundary using an uploaded file */
    post: operations["uploadApplicationBoundary"];
  };
  "/api/v1/accelerator/applications/{applicationId}/deliverables": {
    /** Get deliverables for an application */
    get: operations["getApplicationDeliverables"];
  };
  "/api/v1/accelerator/applications/{applicationId}/history": {
    /** Get the history of changes to the metadata of an application */
    get: operations["getApplicationHistory"];
  };
  "/api/v1/accelerator/applications/{applicationId}/modules": {
    /** Get modules for an application */
    get: operations["getApplicationModules"];
  };
  "/api/v1/accelerator/applications/{applicationId}/modules/{moduleId}/deliverables": {
    /** Get deliverables for an application module */
    get: operations["getApplicationModuleDeliverables"];
  };
  "/api/v1/accelerator/applications/{applicationId}/restart": {
    /**
     * Restart a previously-submitted application
     * @description If the application has not been submitted yet, this is a no-op.
     */
    post: operations["restartApplication"];
  };
  "/api/v1/accelerator/applications/{applicationId}/review": {
    /**
     * Update an application's metadata to reflect a review
     * @description This is an internal-user-only operation.
     */
    post: operations["reviewApplication"];
  };
  "/api/v1/accelerator/applications/{applicationId}/submit": {
    /**
     * Submit an application for review
     * @description If the application has already been submitted, this is a no-op.
     */
    post: operations["submitApplication"];
  };
  "/api/v1/accelerator/cohorts": {
    /** Gets the list of cohorts. */
    get: operations["listCohorts"];
    /** Creates a new cohort. */
    post: operations["createCohort"];
  };
  "/api/v1/accelerator/cohorts/{cohortId}": {
    /** Gets information about a single cohort. */
    get: operations["getCohort"];
    /** Updates the information within a single cohort. */
    put: operations["updateCohort"];
    /** Deletes a single cohort. */
    delete: operations["deleteCohort"];
  };
  "/api/v1/accelerator/deliverables": {
    /**
     * Lists the deliverables for accelerator projects
     * @description The list may optionally be filtered based on certain criteria as specified in the query string. If no filter parameters are supplied, lists all the deliverables in all the participants and projects that are visible to the user. For users with accelerator admin privileges, this will be the full list of all deliverables for all accelerator projects.
     */
    get: operations["listDeliverables"];
  };
  "/api/v1/accelerator/deliverables/{deliverableId}/documents": {
    /** Uploads a new document to satisfy a deliverable. */
    post: operations["uploadDeliverableDocument"];
  };
  "/api/v1/accelerator/deliverables/{deliverableId}/documents/{documentId}": {
    /** Gets a single submission document from a deliverable. */
    get: operations["getDeliverableDocument"];
  };
  "/api/v1/accelerator/deliverables/{deliverableId}/submissions/{projectId}": {
    /** Gets the details of a single deliverable and its submission documents, if any. */
    get: operations["getDeliverable"];
    /**
     * Updates the state of a submission from a project.
     * @description Only permitted for users with accelerator admin privileges.
     */
    put: operations["updateSubmission"];
  };
  "/api/v1/accelerator/deliverables/{deliverableId}/submissions/{projectId}/complete": {
    /** Marks a submission from a project as completed. */
    post: operations["completeSubmission"];
  };
  "/api/v1/accelerator/organizations": {
    /**
     * Lists organizations with the Accelerator internal tag and their projects.
     * @description By default, only lists tagged organizations that have projects that have not been assigned to participants yet.
     */
    get: operations["listAcceleratorOrganizations"];
  };
  "/api/v1/accelerator/participants": {
    /** Creates a new participant. */
    post: operations["createParticipant"];
  };
  "/api/v1/accelerator/participants/{participantId}": {
    /** Gets information about a participant and its assigned projects. */
    get: operations["getParticipant"];
    /** Updates a participant's information. */
    put: operations["updateParticipant"];
    /** Deletes a participant that has no projects. */
    delete: operations["deleteParticipant"];
  };
  "/api/v1/accelerator/projects/species": {
    /** Creates a new participant project species entry. */
    post: operations["createParticipantProjectSpecies"];
    /** Deletes participant project species entries. */
    delete: operations["deleteParticipantProjectSpecies"];
  };
  "/api/v1/accelerator/projects/species/assign": {
    /** Creates a new participant project species entry for every project ID and species ID pairing. */
    post: operations["assignParticipantProjectSpecies"];
  };
  "/api/v1/accelerator/projects/species/{participantProjectSpeciesId}": {
    /** Gets information about a participant project species. */
    get: operations["getParticipantProjectSpecies"];
    /** Updates a participant project species entry. */
    put: operations["updateParticipantProjectSpecies"];
  };
  "/api/v1/accelerator/projects/{projectId}": {
    /**
     * Gets the accelerator-related details for a project.
     * @description Does not include information such as project name that's available via the non-accelerator projects API.
     */
    get: operations["getProjectAcceleratorDetails"];
    /** Updates the accelerator-related details for a project. */
    put: operations["updateProjectAcceleratorDetails"];
  };
  "/api/v1/accelerator/projects/{projectId}/scores": {
    /** Gets score selections for a single project. */
    get: operations["getProjectScores"];
    /**
     * Upserts score selections for a single project.
     * @description Update the scores for the project phase. If the (project, phase, category) does not exist, a new entry is created. Setting a `score` to `null` removes the score.
     */
    put: operations["upsertProjectScores"];
  };
  "/api/v1/accelerator/projects/{projectId}/species": {
    /** Gets all species associated to a participant project. */
    get: operations["getSpeciesForProject"];
  };
  "/api/v1/accelerator/projects/{projectId}/species/snapshots/{deliverableId}": {
    /** Creates a new participant project species entry. */
    get: operations["getParticipantProjectSpeciesSnapshot"];
  };
  "/api/v1/accelerator/projects/{projectId}/votes": {
    /**
     * Gets vote selections for a single project.
     * @description List every vote selection for this project, organized by phases. Each phase will contain a list of eligible voters and their selections.
     */
    get: operations["getProjectVotes"];
    /**
     * Upserts vote selections for a single project.
     * @description Update the user's vote for the project phase. If the (user, project, phase) does not exist, a new entry is created. Setting a `voteOption` to `null` removes the vote.
     */
    put: operations["upsertProjectVotes"];
    /**
     * Remove one or more voters from the project/phase.
     * @description Remove the voters from the project phase, making them ineligible from voting. This is different from undoing a vote (by setting the `voteOption` to `null`). To remove voters from the entire project phase, set `userId` to `null`, and set `phaseDelete` to `true`
     */
    delete: operations["deleteProjectVotes"];
  };
  "/api/v1/accelerator/species/{speciesId}/projects": {
    /** Gets all participant projects associated to a species with active deliverable information if applicable. */
    get: operations["getProjectsForSpecies"];
  };
  "/api/v1/automations": {
    /** Gets a list of automations for a device or facility. */
    get: operations["listAutomations"];
    /** Creates a new automation for a device or facility. */
    post: operations["createAutomation"];
  };
  "/api/v1/automations/{automationId}": {
    /** Gets the details of a single automation for a device or facility. */
    get: operations["getAutomation"];
    /** Updates an existing automation for a device or facility. */
    put: operations["updateAutomation"];
    /** Deletes an existing automation from a device or facility. */
    delete: operations["deleteAutomation"];
  };
  "/api/v1/automations/{automationId}/trigger": {
    /** Reports that an automation has been triggered. */
    post: operations["postAutomationTrigger"];
  };
  "/api/v1/devices": {
    /** Registers a new device a facility's device manager. */
    post: operations["createDevice"];
  };
  "/api/v1/devices/{id}": {
    /** Gets the configuration of a single device. */
    get: operations["getDevice"];
    /** Updates the configuration of an existing device. */
    put: operations["updateDevice"];
  };
  "/api/v1/devices/{id}/unresponsive": {
    /**
     * Marks a device as unresponsive.
     * @description Notifies the appropriate users so they can troubleshoot the problem.
     */
    post: operations["deviceUnresponsive"];
  };
  "/api/v1/document-producer/documents": {
    /** Gets a list of all the documents. */
    get: operations["listDocuments"];
    /** Creates a new document. */
    post: operations["createDocument"];
  };
  "/api/v1/document-producer/documents/{documentId}/upgrade": {
    /**
     * Upgrades a document to a newer manifest.
     * @description The manifest must be for the same document template as the existing manifest.
     */
    post: operations["upgradeManifest"];
  };
  "/api/v1/document-producer/documents/{documentId}/versions": {
    /** Saves a version of a document. */
    post: operations["createSavedDocumentVersion"];
  };
  "/api/v1/document-producer/documents/{documentId}/versions/{versionId}": {
    /** Gets details of a specific saved version of a document. */
    get: operations["getSavedDocumentVersion"];
    /** Updates a saved version of a document. */
    put: operations["updateSavedDocumentVersion"];
  };
  "/api/v1/document-producer/documents/{id}": {
    /** Gets a document. */
    get: operations["getDocument"];
    /** Updates a document. */
    put: operations["updateDocument"];
  };
  "/api/v1/document-producer/documents/{id}/history": {
    /** Gets the history of a document. This includes both information about document edits and information about saved versions. */
    get: operations["getDocumentHistory"];
  };
  "/api/v1/document-producer/projects/{projectId}/images": {
    /** Save an image to a new variable value. */
    post: operations["uploadProjectImageValue"];
  };
  "/api/v1/document-producer/projects/{projectId}/images/{valueId}": {
    /**
     * Gets the contents of an image variable value.
     * @description Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio.
     */
    get: operations["getProjectImageValue"];
  };
  "/api/v1/document-producer/projects/{projectId}/owners": {
    /**
     * List the owners of a project's variables.
     * @description Only variables that actually have owners are returned.
     */
    get: operations["listVariableOwners"];
  };
  "/api/v1/document-producer/projects/{projectId}/owners/{variableId}": {
    /** Update or remove the owner of a variable in a project. */
    put: operations["updateVariableOwner"];
  };
  "/api/v1/document-producer/projects/{projectId}/values": {
    /**
     * Get the values of the variables in a project.
     * @description This may be used to fetch the full set of current values (the default behavior), the values from a saved version (if maxValueId is specified), or to poll for recent edits (if minValueId is specified).
     */
    get: operations["listProjectVariableValues"];
    /**
     * Update the values of the variables in a project.
     * @description Make a list of changes to a project's variable values. The changes are applied in order and are treated as an atomic unit. That is, the changes will either all succeed or all fail; there won't be a case where some of the changes are applied and some aren't. See the payload descriptions for more details about the operations you can perform on values.
     */
    post: operations["updateProjectVariableValues"];
  };
  "/api/v1/document-producer/projects/{projectId}/workflow/{variableId}": {
    /** Update the workflow details for a variable in a project. */
    put: operations["updateVariableWorkflowDetails"];
  };
  "/api/v1/document-producer/templates": {
    /** Gets a list of all the valid document templates. */
    get: operations["listDocumentTemplates"];
  };
  "/api/v1/document-producer/variables": {
    /** List the variables, optionally filtered by a given manifest or deliverable. Variables returned for a manifest include all section hierarchies and variables injected into section text. */
    get: operations["listVariables"];
  };
  "/api/v1/facilities": {
    /** Lists all accessible facilities. */
    get: operations["listAllFacilities"];
    /** Creates a new facility. */
    post: operations["createFacility"];
  };
  "/api/v1/facilities/{facilityId}": {
    /** Gets information about a single facility. */
    get: operations["getFacility"];
    /** Updates information about a facility. */
    put: operations["updateFacility"];
  };
  "/api/v1/facilities/{facilityId}/alert/send": {
    /** Sends an alert to the facility's configured alert recipients. */
    post: operations["sendFacilityAlert"];
  };
  "/api/v1/facilities/{facilityId}/configured": {
    /**
     * Marks a facility as fully configured.
     * @description After connecting a device manager and finishing any necessary configuration of the facility's devices, send this request to enable processing of timeseries values and alerts from the device manager. Only valid if the facility's connection state is `Connected`.
     */
    post: operations["postConfigured"];
  };
  "/api/v1/facilities/{facilityId}/devices": {
    /** Lists the configurations of all the devices at a facility. */
    get: operations["listFacilityDevices"];
  };
  "/api/v1/facilities/{facilityId}/subLocations": {
    /** Gets a list of sub-locations at a facility. */
    get: operations["listSubLocations"];
    /** Creates a new sub-location at a facility. */
    post: operations["createSubLocation"];
  };
  "/api/v1/facilities/{facilityId}/subLocations/{subLocationId}": {
    /** Gets information about a specific sub-location at a facility. */
    get: operations["getSubLocation"];
    /** Updates the name of a sub-location at a facility. */
    put: operations["updateSubLocation"];
    /**
     * Deletes a sub-location from a facility.
     * @description The sub-location must not be in use.
     */
    delete: operations["deleteSubLocation"];
  };
  "/api/v1/facility/{facilityId}/devices": {
    /** Lists the configurations of all the devices at a facility. */
    get: operations["listFacilityDevices_1"];
  };
  "/api/v1/globalRoles/users": {
    /** Gets the list of users that have global roles. */
    get: operations["listGlobalRoles"];
    /** Remove global roles from the supplied users. */
    delete: operations["deleteGlobalRoles"];
  };
  "/api/v1/i18n/timeZones": {
    /** Gets a list of supported time zones and their names. */
    get: operations["listTimeZoneNames"];
  };
  "/api/v1/internalTags": {
    /** List all the available internal tags */
    get: operations["listAllInternalTags"];
  };
  "/api/v1/internalTags/organizations": {
    /**
     * List the internal tags assigned to all organizations
     * @description This includes organizations with no internal tags, whose list of tags will be empty.
     */
    get: operations["listAllOrganizationInternalTags"];
  };
  "/api/v1/internalTags/organizations/{organizationId}": {
    /** List the internal tags assigned to an organization */
    get: operations["listOrganizationInternalTags"];
    /** Replace the list of internal tags assigned to an organization */
    put: operations["updateOrganizationInternalTags"];
  };
  "/api/v1/login": {
    /**
     * Redirects to a login page.
     * @description For interactive web applications, this can be used to redirect the user to a login page to allow the application to make other API requests. The login process will set a cookie that will authenticate to the API, and will then redirect back to the application. One approach is to use this in error response handlers: if an API request returns HTTP 401 Unauthorized, set location.href to this endpoint and set "redirect" to the URL of the page the user was on so they'll return there after logging in.
     */
    get: operations["login"];
  };
  "/api/v1/notifications": {
    /** Retrieve all notifications for current user scoped to an organization. */
    get: operations["readAll"];
    /** Update notifications as read or unread */
    put: operations["markAllRead"];
  };
  "/api/v1/notifications/count": {
    /** Retrieve notifications count by organization for current user. */
    get: operations["count"];
  };
  "/api/v1/notifications/{id}": {
    /** Retrieve a notification by its id. */
    get: operations["read"];
    /** Update a single notification as read or unread */
    put: operations["markRead"];
  };
  "/api/v1/nursery/batches": {
    /** Creates a new seedling batch at a nursery. */
    post: operations["createBatch"];
  };
  "/api/v1/nursery/batches/uploads": {
    /**
     * Uploads a list of seedling batches to add to the nursery.
     * @description The uploaded file must be in CSV format. A template with the correct headers may be downloaded from the `/api/v1/nursery/batches/uploads/template` endpoint.
     */
    post: operations["uploadSeedlingBatchesList"];
  };
  "/api/v1/nursery/batches/uploads/template": {
    /** Gets a template file that contains the required header row for seedling batch uploads. */
    get: operations["getSeedlingBatchesUploadTemplate"];
  };
  "/api/v1/nursery/batches/uploads/{uploadId}": {
    /**
     * Gets the status of a seedling batches list uploaded previously.
     * @description Clients may poll this endpoint to monitor the progress of the file.
     */
    get: operations["getSeedlingBatchesListUploadStatus"];
  };
  "/api/v1/nursery/batches/{batchId}/history": {
    /**
     * Gets the history of changes to a seedling batch.
     * @description Each event includes a version number. For events such as details edits that are snapshots of the values at a particular time, clients can compare against the event with the previous version number to see what has changed, e.g., to show a delta or a diff view.
     */
    get: operations["getBatchHistory"];
  };
  "/api/v1/nursery/batches/{batchId}/photos": {
    /** Lists all the photos of a seedling batch. */
    get: operations["listBatchPhotos"];
    /** Creates a new photo of a seedling batch. */
    post: operations["createBatchPhoto"];
  };
  "/api/v1/nursery/batches/{batchId}/photos/{photoId}": {
    /**
     * Retrieves a specific photo from a seedling batch.
     * @description Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio.
     */
    get: operations["getBatchPhoto"];
    /** Deletes a photo from a seedling batch. */
    delete: operations["deleteBatchPhoto"];
  };
  "/api/v1/nursery/batches/{id}": {
    /** Gets information about a single seedling batch. */
    get: operations["getBatch"];
    /** Updates non-quantity-related details about a batch. */
    put: operations["updateBatch"];
    /** Deletes an existing seedling batch from a nursery. */
    delete: operations["deleteBatch"];
  };
  "/api/v1/nursery/batches/{id}/changeStatuses": {
    /**
     * Changes the statuses of seedlings in a batch.
     * @description There must be enough seedlings available to move to the next status.
     */
    post: operations["changeBatchStatuses"];
  };
  "/api/v1/nursery/batches/{id}/quantities": {
    /**
     * Updates the remaining quantities in a seedling batch.
     * @description This should not be used to record withdrawals; use the withdrawal API for that.
     */
    put: operations["updateBatchQuantities"];
  };
  "/api/v1/nursery/facilities/{facilityId}/summary": {
    /** Gets a summary of the numbers of plants in a nursery. */
    get: operations["getNurserySummary"];
  };
  "/api/v1/nursery/species/{speciesId}/summary": {
    /** Gets a summary of the numbers of plants of each species in all nurseries. */
    get: operations["getSpeciesSummary"];
  };
  "/api/v1/nursery/withdrawals": {
    /** Withdraws seedlings from one or more seedling batches at a nursery. */
    post: operations["createBatchWithdrawal"];
  };
  "/api/v1/nursery/withdrawals/{withdrawalId}": {
    /** Gets information about a specific nursery withdrawal. */
    get: operations["getNurseryWithdrawal"];
  };
  "/api/v1/nursery/withdrawals/{withdrawalId}/photos": {
    /** Lists all the photos of a withdrawal. */
    get: operations["listWithdrawalPhotos"];
    /** Creates a new photo of a seedling batch withdrawal. */
    post: operations["uploadWithdrawalPhoto"];
  };
  "/api/v1/nursery/withdrawals/{withdrawalId}/photos/{photoId}": {
    /**
     * Retrieves a specific photo from a withdrawal.
     * @description Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio.
     */
    get: operations["getWithdrawalPhoto"];
  };
  "/api/v1/nursery/withdrawals/{withdrawalId}/undo": {
    /**
     * Undoes a withdrawal.
     * @description The withdrawal's plants will be returned to their original batches. Nursery transfers may not be undone. If the withdrawal was an outplanting to a planting site, the plants will be removed from the planting site's plant totals. This does not delete the original withdrawal.
     */
    post: operations["undoBatchWithdrawal"];
  };
  "/api/v1/organizations": {
    /**
     * Lists all organizations.
     * @description Lists all organizations the user can access.
     */
    get: operations["listOrganizations"];
    /** Creates a new organization. */
    post: operations["createOrganization"];
  };
  "/api/v1/organizations/{organizationId}": {
    /** Gets information about an organization. */
    get: operations["getOrganization"];
    /** Updates an existing organization. */
    put: operations["updateOrganization"];
    /**
     * Deletes an existing organization.
     * @description Organizations can only be deleted if they have no members other than the current user.
     */
    delete: operations["deleteOrganization"];
  };
  "/api/v1/organizations/{organizationId}/roles": {
    /** Lists the roles in an organization. */
    get: operations["listOrganizationRoles"];
  };
  "/api/v1/organizations/{organizationId}/users": {
    /** Lists the users in an organization. */
    get: operations["listOrganizationUsers"];
    /** Adds a user to an organization. */
    post: operations["addOrganizationUser"];
  };
  "/api/v1/organizations/{organizationId}/users/{userId}": {
    /** Gets information about a user's membership in an organization. */
    get: operations["getOrganizationUser"];
    /**
     * Updates the user's organization information.
     * @description Only includes organization-level information that can be modified by organization administrators.
     */
    put: operations["updateOrganizationUser"];
    /**
     * Removes a user from an organization.
     * @description Does not remove any data created by the user.
     */
    delete: operations["deleteOrganizationUser"];
  };
  "/api/v1/projects": {
    /** Lists accessible projects. */
    get: operations["listProjects"];
    /** Creates a new project. */
    post: operations["createProject"];
  };
  "/api/v1/projects/{id}": {
    /** Gets information about a specific project. */
    get: operations["getProject"];
    /** Updates information about an existing project. */
    put: operations["updateProject"];
    /**
     * Deletes an existing project.
     * @description Any accessions, seedling batches, or planting sites that were assigned to the project will no longer be assigned to any project.
     */
    delete: operations["deleteProject"];
  };
  "/api/v1/projects/{id}/assign": {
    /**
     * Assigns multiple entities to a project.
     * @description Overwrites any existing project assignments.
     */
    post: operations["assignProject"];
  };
  "/api/v1/projects/{projectId}/modules": {
    /** Gets modules for a project. */
    get: operations["listModules"];
  };
  "/api/v1/projects/{projectId}/modules/{moduleId}": {
    /** Gets one module for a project. */
    get: operations["getModule"];
  };
  "/api/v1/reports": {
    /** Lists an organization's reports. */
    get: operations["listReports"];
  };
  "/api/v1/reports/settings": {
    /** Gets the report settings for an organization. */
    get: operations["getReportSettings"];
    /** Updates the report settings for an organization. */
    put: operations["updateReportSettings"];
  };
  "/api/v1/reports/{id}": {
    /** Retrieves the contents of a report. */
    get: operations["getReport"];
    /**
     * Updates a report.
     * @description The report must be locked by the current user.
     */
    put: operations["updateReport"];
  };
  "/api/v1/reports/{id}/files": {
    /** Lists the files associated with a report. */
    get: operations["listReportFiles"];
  };
  "/api/v1/reports/{id}/lock": {
    /**
     * Locks a report.
     * @description Only succeeds if the report is not currently locked or if it is locked by the current user.
     */
    post: operations["lockReport"];
  };
  "/api/v1/reports/{id}/lock/force": {
    /** Locks a report even if it is locked by another user already. */
    post: operations["forceLockReport"];
  };
  "/api/v1/reports/{id}/photos": {
    /** Lists the photos associated with a report. */
    get: operations["listReportPhotos"];
  };
  "/api/v1/reports/{id}/submit": {
    /**
     * Submits a report.
     * @description The report must be locked by the current user. Submitting a report releases the lock. Once a report is submitted, it may no longer be locked or updated.
     */
    post: operations["submitReport"];
  };
  "/api/v1/reports/{id}/unlock": {
    /** Releases the lock on a report. */
    post: operations["unlockReport"];
  };
  "/api/v1/reports/{reportId}/files": {
    /** Uploads a file to associate with a report. */
    post: operations["uploadReportFile"];
  };
  "/api/v1/reports/{reportId}/files/{fileId}": {
    /** Downloads a file associated with a report. */
    get: operations["downloadReportFile"];
    /** Deletes a file from a report. */
    delete: operations["deleteReportFile"];
  };
  "/api/v1/reports/{reportId}/photos": {
    /** Uploads a photo to include with a report. */
    post: operations["uploadReportPhoto"];
  };
  "/api/v1/reports/{reportId}/photos/{photoId}": {
    /**
     * Gets the contents of a photo.
     * @description Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio.
     */
    get: operations["getReportPhoto"];
    /** Updates a photo's caption. */
    put: operations["updateReportPhoto"];
    /** Deletes a photo from a report. */
    delete: operations["deleteReportPhoto"];
  };
  "/api/v1/search": {
    /**
     * Exports selected fields from data matching a set of search criteria.
     * @description If a sublist field has multiple values, they are separated with line breaks in the exported file.
     */
    post: operations["search_1"];
  };
  "/api/v1/search/values": {
    /** Search for distinct values from data matching a set of search criteria. */
    post: operations["searchDistinctValues"];
  };
  "/api/v1/seedbank/accessions/{id}": {
    /** Deletes an existing accession. */
    delete: operations["delete"];
  };
  "/api/v1/seedbank/accessions/{id}/checkIn": {
    /** Marks an accession as checked in. */
    post: operations["checkIn"];
  };
  "/api/v1/seedbank/accessions/{id}/history": {
    /** Gets the history of changes to an accession. */
    get: operations["getAccessionHistory"];
  };
  "/api/v1/seedbank/accessions/{id}/photos": {
    /** List all the available photos for an accession. */
    get: operations["listPhotos"];
  };
  "/api/v1/seedbank/accessions/{id}/photos/{photoFilename}": {
    /**
     * Retrieve a specific photo from an accession.
     * @description Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio.
     */
    get: operations["getPhoto"];
    /**
     * Upload a new photo for an accession.
     * @description If there was already a photo with the specified filename, replaces it.
     */
    post: operations["uploadPhoto"];
    /** Delete one photo for an accession. */
    delete: operations["deletePhoto"];
  };
  "/api/v1/seedbank/clock": {
    /**
     * Get the server's current date and time.
     * @description In test environments, the clock can be advanced artificially, which will cause it to differ from the real-world date and time.
     */
    get: operations["getCurrentTime"];
  };
  "/api/v1/seedbank/log/{tag}": {
    /** Records a log message from a device at a seed bank. */
    post: operations["recordLogMessage"];
  };
  "/api/v1/seedbank/summary": {
    /** Get summary statistics about a specific seed bank or all seed banks within an organization. */
    get: operations["getSeedBankSummary"];
    /** Get summary statistics about accessions that match a specified set of search criteria. */
    post: operations["summarizeAccessionSearch"];
  };
  "/api/v1/seedbank/values": {
    /** List the values of a set of search fields for a set of accessions matching certain filter criteria. */
    post: operations["listFieldValues"];
  };
  "/api/v1/species": {
    /** Lists all the species available in an organization. */
    get: operations["listSpecies"];
    /** Creates a new species. */
    post: operations["createSpecies"];
  };
  "/api/v1/species/lookup/details": {
    /** Gets more information about a species with a particular scientific name. */
    get: operations["getSpeciesDetails"];
  };
  "/api/v1/species/lookup/names": {
    /** @description Gets a list of known scientific names whose words begin with particular letters. */
    get: operations["listSpeciesNames"];
  };
  "/api/v1/species/problems/{problemId}": {
    /** @description Returns details about a problem with a species. */
    get: operations["getSpeciesProblem"];
    /**
     * Applies suggested changes to fix a problem with a species.
     * @description Only valid for problems that include suggested changes.
     */
    post: operations["acceptProblemSuggestion"];
    /** Deletes information about a problem with a species without applying any suggested changes. */
    delete: operations["deleteProblem"];
  };
  "/api/v1/species/uploads": {
    /**
     * Uploads a list of species to add to the organization.
     * @description The uploaded file must be in CSV format. A template with the correct headers may be downloaded from the `/api/v1/species/uploads/template` endpoint.
     */
    post: operations["uploadSpeciesList"];
  };
  "/api/v1/species/uploads/template": {
    /** Gets a template file that contains the required header row for species list uploads. */
    get: operations["getSpeciesListUploadTemplate"];
  };
  "/api/v1/species/uploads/{uploadId}": {
    /**
     * Gets the status of a species list uploaded previously.
     * @description Clients may poll this endpoint to monitor the progress of the file.
     */
    get: operations["getSpeciesListUploadStatus"];
    /**
     * Deletes a species list upload that is awaiting user action.
     * @description This may only be called if the status of the upload is "Awaiting User Action".
     */
    delete: operations["deleteSpeciesListUpload"];
  };
  "/api/v1/species/uploads/{uploadId}/resolve": {
    /**
     * Resolves the problems with a species list that is awaiting user action.
     * @description This may only be called if the status of the upload is "Awaiting User Action".
     */
    post: operations["resolveSpeciesListUpload"];
  };
  "/api/v1/species/{speciesId}": {
    /** Gets information about a single species. */
    get: operations["getSpecies"];
    /** Updates an existing species. */
    put: operations["updateSpecies"];
    /**
     * Deletes an existing species.
     * @description The species will no longer appear in the organization's list of species, but existing data (plants, seeds, etc.) that refer to the species will still refer to it.
     */
    delete: operations["deleteSpecies"];
  };
  "/api/v1/support": {
    /** Lists support request types. */
    get: operations["listRequestTypes"];
    /** Submit support request types. */
    post: operations["submitRequest"];
  };
  "/api/v1/support/attachment": {
    /**
     * Upload a temporary attachment.
     * @description Uploads an attachment, which can be assigned to a support request during submission.
     */
    post: operations["uploadAttachment"];
  };
  "/api/v1/timeseries": {
    /** Lists the timeseries for one or more devices. */
    get: operations["listTimeseries"];
  };
  "/api/v1/timeseries/create": {
    /**
     * Defines a list of timeseries for one or more devices.
     * @description If there are existing timeseries with the same names, the old definitions will be overwritten.
     */
    post: operations["createMultipleTimeseries"];
  };
  "/api/v1/timeseries/values": {
    /** Records new values for one or more timeseries. */
    post: operations["recordTimeseriesValues"];
  };
  "/api/v1/tracking/deliveries/{id}": {
    /** Gets information about a specific delivery of seedlings to a planting site. */
    get: operations["getDelivery"];
  };
  "/api/v1/tracking/deliveries/{id}/reassign": {
    /** Reassigns some of the seedlings from a delivery to a different planting subzone. */
    post: operations["reassignDelivery"];
  };
  "/api/v1/tracking/draftSites": {
    /** Saves a draft of an in-progress planting site. */
    post: operations["createDraftPlantingSite"];
  };
  "/api/v1/tracking/draftSites/{id}": {
    /** Gets the details of a saved draft of a planting site. */
    get: operations["getDraftPlantingSite"];
    /** Updates an existing draft of an in-progress planting site. */
    put: operations["updateDraftPlantingSite"];
    /** Deletes an existing draft of an in-progress planting site. */
    delete: operations["deleteDraftPlantingSite"];
  };
  "/api/v1/tracking/mapbox/token": {
    /**
     * Gets an API token to use for displaying Mapbox maps.
     * @description Mapbox API tokens are short-lived; when a token expires, request a new one.
     */
    get: operations["getMapboxToken"];
  };
  "/api/v1/tracking/observations": {
    /** Gets a list of observations of planting sites. */
    get: operations["listObservations"];
    /** Schedules a new observation. */
    post: operations["scheduleObservation"];
  };
  "/api/v1/tracking/observations/results": {
    /** Gets a list of the results of observations. */
    get: operations["listObservationResults"];
  };
  "/api/v1/tracking/observations/{observationId}": {
    /** Gets information about a single observation. */
    get: operations["getObservation"];
    /** Reschedules an existing observation. */
    put: operations["rescheduleObservation"];
  };
  "/api/v1/tracking/observations/{observationId}/plots": {
    /** Gets a list of monitoring plots assigned to an observation. */
    get: operations["listAssignedPlots"];
  };
  "/api/v1/tracking/observations/{observationId}/plots/{plotId}": {
    /** Updates information about the observation of a plot. */
    put: operations["updatePlotObservation"];
    /** Stores the results of a completed observation of a plot. */
    post: operations["completePlotObservation"];
  };
  "/api/v1/tracking/observations/{observationId}/plots/{plotId}/claim": {
    /**
     * Claims a monitoring plot.
     * @description A plot may only be claimed by one user at a time.
     */
    post: operations["claimMonitoringPlot"];
  };
  "/api/v1/tracking/observations/{observationId}/plots/{plotId}/photos": {
    /** Uploads a photo of a monitoring plot. */
    post: operations["uploadPlotPhoto"];
  };
  "/api/v1/tracking/observations/{observationId}/plots/{plotId}/photos/{fileId}": {
    /**
     * Retrieves a specific photo from an observation of a monitoring plot.
     * @description Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio.
     */
    get: operations["getPlotPhoto"];
  };
  "/api/v1/tracking/observations/{observationId}/plots/{plotId}/release": {
    /** Releases the claim on a monitoring plot. */
    post: operations["releaseMonitoringPlot"];
  };
  "/api/v1/tracking/observations/{observationId}/plots/{plotId}/replace": {
    /**
     * Requests that a monitoring plot be replaced with a new one.
     * @description Additional monitoring plots may be replaced as well, e.g., if the requested plot is part of a permanent cluster. In some cases, the requested plot will be removed from the observation but not replaced with a different one.
     */
    post: operations["replaceObservationPlot"];
  };
  "/api/v1/tracking/observations/{observationId}/results": {
    /**
     * Gets the results of an observation of a planting site.
     * @description Some information is only available once all plots have been completed.
     */
    get: operations["getObservationResults"];
  };
  "/api/v1/tracking/sites": {
    /**
     * Gets a list of an organization's planting sites.
     * @description The list can optionally contain information about planting zones and subzones.
     */
    get: operations["listPlantingSites"];
    /** Creates a new planting site. */
    post: operations["createPlantingSite"];
  };
  "/api/v1/tracking/sites/validate": {
    /** Validates the definition of a new planting site. */
    post: operations["validatePlantingSite"];
  };
  "/api/v1/tracking/sites/{id}": {
    /**
     * Gets information about a specific planting site.
     * @description Includes information about the site's planting zones and subzones.
     */
    get: operations["getPlantingSite"];
    /** Updates information about an existing planting site. */
    put: operations["updatePlantingSite"];
    /**
     * Deletes a planting site.
     * @description Planting site should not have any plantings.
     */
    delete: operations["deletePlantingSite"];
  };
  "/api/v1/tracking/sites/{id}/reportedPlants": {
    /**
     * Gets the total number of plants planted at a planting site and in each planting zone.
     * @description The totals are based on nursery withdrawals.
     */
    get: operations["getPlantingSiteReportedPlants"];
  };
  "/api/v1/tracking/subzones/{id}": {
    /** Updates information about a planting subzone. */
    put: operations["updatePlantingSubzone"];
  };
  "/api/v1/tracking/subzones/{id}/species": {
    /**
     * Gets a list of the species that have been planted in a specific planting subzone.
     * @description The list is based on nursery withdrawals.
     */
    get: operations["listPlantingSubzoneSpecies"];
  };
  "/api/v1/users": {
    /** Gets a user by some criteria, for now only email is available */
    get: operations["searchUsers"];
  };
  "/api/v1/users/me": {
    /** Gets information about the current user. */
    get: operations["getMyself"];
    /** Updates information about the current user. */
    put: operations["updateMyself"];
    /**
     * Deletes the current user's account.
     * @description WARNING! This operation is not reversible.
     */
    delete: operations["deleteMyself"];
  };
  "/api/v1/users/me/cookies": {
    /** Updates the current user's cookie consent selection. */
    put: operations["updateCookieConsent"];
  };
  "/api/v1/users/me/preferences": {
    /** Gets the current user's preferences. */
    get: operations["getUserPreferences"];
    /** Updates the current user's preferences. */
    put: operations["updateUserPreferences"];
  };
  "/api/v1/users/{userId}": {
    /** Get a user by ID, if they exist, only ordinary users are supported. */
    get: operations["getUser"];
  };
  "/api/v1/users/{userId}/deliverableCategories": {
    /** Get the list of deliverable categories assigned to a user. */
    get: operations["getUserDeliverableCategories"];
    /** Update which deliverable categories are assigned to a user. */
    put: operations["updateUserDeliverableCategories"];
  };
  "/api/v1/users/{userId}/globalRoles": {
    /** Apply the supplied global roles to the user. */
    post: operations["updateGlobalRoles"];
  };
  "/api/v1/versions": {
    /** Gets the minimum and recommended versions for Terraware's client applications. */
    get: operations["getVersions"];
  };
  "/api/v2/seedbank/accessions": {
    /** Creates a new accession. */
    post: operations["createAccession"];
  };
  "/api/v2/seedbank/accessions/uploads": {
    /**
     * Uploads a list of accessions to add to the facility.
     * @description The uploaded file must be in CSV format. A template with the correct headers may be downloaded from the `/api/v2/seedbank/accessions/uploads/template` endpoint.
     */
    post: operations["uploadAccessionsList"];
  };
  "/api/v2/seedbank/accessions/uploads/template": {
    /** Gets a template file that contains the required header row for accessions list uploads. */
    get: operations["getAccessionsListUploadTemplate"];
  };
  "/api/v2/seedbank/accessions/uploads/{uploadId}": {
    /**
     * Gets the status of an accessions list uploaded previously.
     * @description Clients may poll this endpoint to monitor the progress of the file.
     */
    get: operations["getAccessionsListUploadStatus"];
    /**
     * Deletes an accessions list upload that is awaiting user action.
     * @description This may only be called if the status of the upload is "Awaiting User Action".
     */
    delete: operations["deleteAccessionsListUpload"];
  };
  "/api/v2/seedbank/accessions/uploads/{uploadId}/resolve": {
    /**
     * Resolves the problems with an accessions list that is awaiting user action.
     * @description This may only be called if the status of the upload is "Awaiting User Action".
     */
    post: operations["resolveAccessionsListUpload"];
  };
  "/api/v2/seedbank/accessions/{accessionId}/transfers/nursery": {
    /** Transfers seeds to a nursery. */
    post: operations["createNurseryTransferWithdrawal"];
  };
  "/api/v2/seedbank/accessions/{accessionId}/viabilityTests": {
    /** List all of the accession's viability tests. */
    get: operations["listViabilityTests"];
    /**
     * Create a new viability test on an existing accession.
     * @description May cause the accession's remaining quantity to change.
     */
    post: operations["createViabilityTest"];
  };
  "/api/v2/seedbank/accessions/{accessionId}/viabilityTests/{viabilityTestId}": {
    /** Get a single viability test. */
    get: operations["getViabilityTest"];
    /**
     * Update the details of an existing viability test.
     * @description May cause the accession's remaining quantity to change.
     */
    put: operations["updateViabilityTest"];
    /**
     * Delete an existing viability test.
     * @description May cause the accession's remaining quantity to change.
     */
    delete: operations["deleteViabilityTest"];
  };
  "/api/v2/seedbank/accessions/{accessionId}/withdrawals": {
    /** List all the withdrawals from an accession. */
    get: operations["listWithdrawals"];
    /**
     * Create a new withdrawal on an existing accession.
     * @description May cause the accession's remaining quantity to change.
     */
    post: operations["createWithdrawal"];
  };
  "/api/v2/seedbank/accessions/{accessionId}/withdrawals/{withdrawalId}": {
    /** Get a single withdrawal. */
    get: operations["getWithdrawal"];
    /**
     * Update the details of an existing withdrawal.
     * @description May cause the accession's remaining quantity to change.
     */
    put: operations["updateWithdrawal"];
    /**
     * Delete an existing withdrawal.
     * @description May cause the accession's remaining quantity to change.
     */
    delete: operations["deleteWithdrawal"];
  };
  "/api/v2/seedbank/accessions/{id}": {
    /** Retrieve an existing accession. */
    get: operations["getAccession"];
    /** Update an existing accession. */
    put: operations["updateAccession"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    AcceleratorOrganizationPayload: {
      /** Format: int64 */
      id: number;
      name: string;
      projects: components["schemas"]["AcceleratorProjectPayload"][];
    };
    AcceleratorProjectPayload: {
      /** Format: int64 */
      id: number;
      name: string;
      /** Format: int64 */
      participantId?: number;
    };
    AccessionHistoryEntryPayload: {
      /** Format: int64 */
      batchId?: number;
      /** Format: date */
      date: string;
      /**
       * @description Human-readable description of the event. Does not include date or userName.
       * @example updated the status to Drying
       */
      description: string;
      /** @description Full name of the person responsible for the event, if known. */
      fullName?: string;
      /** @description User-entered notes about the event, if any. */
      notes?: string;
      /** @enum {string} */
      type: "Created" | "QuantityUpdated" | "StateChanged" | "ViabilityTesting" | "Withdrawal";
    };
    AccessionPayloadV2: {
      /** @description Server-generated human-readable identifier for the accession. This is unique within a single seed bank, but different seed banks may have accessions with the same number. */
      accessionNumber: string;
      /**
       * @description Server-calculated active indicator. This is based on the accession's state.
       * @enum {string}
       */
      active: "Inactive" | "Active";
      bagNumbers?: string[];
      /** Format: date */
      collectedDate?: string;
      collectionSiteCity?: string;
      collectionSiteCoordinates?: components["schemas"]["Geolocation"][];
      collectionSiteCountryCode?: string;
      collectionSiteCountrySubdivision?: string;
      collectionSiteLandowner?: string;
      collectionSiteName?: string;
      collectionSiteNotes?: string;
      /** @enum {string} */
      collectionSource?: "Wild" | "Reintroduced" | "Cultivated" | "Other";
      /** @description Names of the people who collected the seeds. */
      collectors?: string[];
      /** Format: date */
      dryingEndDate?: string;
      /**
       * Format: int32
       * @description Estimated number of seeds remaining. Absent if there isn't enough information to calculate an estimate.
       */
      estimatedCount?: number;
      /** @description Estimated weight of seeds remaining. Absent if there isn't enough information to calculate an estimate. */
      estimatedWeight?: components["schemas"]["SeedQuantityPayload"];
      /** Format: int64 */
      facilityId: number;
      /** @description If true, plants from this accession's seeds were delivered to a planting site. */
      hasDeliveries: boolean;
      /**
       * Format: int64
       * @description Server-generated unique identifier for the accession. This is unique across all seed banks, but is not suitable for display to end users.
       */
      id: number;
      /** @description Most recent user observation of seeds remaining in the accession. This is not directly editable; it is updated by the server whenever the "remainingQuantity" field is edited. */
      latestObservedQuantity?: components["schemas"]["SeedQuantityPayload"];
      /**
       * Format: date-time
       * @description Time of most recent user observation of seeds remaining in the accession. This is updated by the server whenever the "remainingQuantity" field is edited.
       */
      latestObservedTime?: string;
      notes?: string;
      photoFilenames?: string[];
      plantId?: string;
      /**
       * Format: int32
       * @description Estimated number of plants the seeds were collected from.
       */
      plantsCollectedFrom?: number;
      /** Format: int64 */
      projectId?: number;
      /** Format: date */
      receivedDate?: string;
      /** @description Number or weight of seeds remaining for withdrawal and testing. May be calculated by the server after withdrawals. */
      remainingQuantity?: components["schemas"]["SeedQuantityPayload"];
      /**
       * @description Which source of data this accession originally came from.
       * @enum {string}
       */
      source?: "Web" | "Seed Collector App" | "File Import";
      /** @description Common name of the species, if defined. */
      speciesCommonName?: string;
      /**
       * Format: int64
       * @description Server-generated unique ID of the species.
       */
      speciesId?: number;
      /** @description Scientific name of the species. */
      speciesScientificName?: string;
      /** @enum {string} */
      state: "Awaiting Check-In" | "Awaiting Processing" | "Processing" | "Drying" | "In Storage" | "Used Up";
      subLocation?: string;
      /** Format: int32 */
      subsetCount?: number;
      /** @description Weight of subset of seeds. Units must be a weight measurement, not "Seeds". */
      subsetWeight?: components["schemas"]["SeedQuantityPayload"];
      /**
       * Format: int32
       * @description Total number of seeds withdrawn. If withdrawals are measured by weight, this is an estimate based on the accession's subset count and weight.
       */
      totalWithdrawnCount?: number;
      /** @description Total weight of seeds withdrawn. If withdrawals are measured by seed count, this is an estimate based on the accession's subset count and weight. */
      totalWithdrawnWeight?: components["schemas"]["SeedQuantityPayload"];
      /** Format: int32 */
      viabilityPercent?: number;
      viabilityTests?: components["schemas"]["GetViabilityTestPayload"][];
      withdrawals?: components["schemas"]["GetWithdrawalPayload"][];
    };
    AddOrganizationUserRequestPayload: {
      email: string;
      /** @enum {string} */
      role: "Contributor" | "Manager" | "Admin" | "Owner" | "Terraformation Contact";
    };
    /** @description Search criterion that matches results that meet all of a set of other search criteria. That is, if the list of children is x, y, and z, this will require x AND y AND z. */
    AndNodePayload: WithRequired<{
      operation: "and";
    } & Omit<components["schemas"]["SearchNodePayload"], "operation"> & {
      /** @description List of criteria all of which must be satisfied */
      children?: components["schemas"]["SearchNodePayload"][];
    }, "children">;
    AnnualDetailsPayloadV1: {
      bestMonthsForObservation: number[];
      budgetNarrativeSummary?: string;
      catalyticDetail?: string;
      challenges?: string;
      isCatalytic: boolean;
      keyLessons?: string;
      nextSteps?: string;
      opportunities?: string;
      projectImpact?: string;
      projectSummary?: string;
      socialImpact?: string;
      successStories?: string;
      sustainableDevelopmentGoals: components["schemas"]["GoalProgressPayloadV1"][];
    };
    /**
     * @description Operation that appends a new value to a variable. If the variable does not have an existing value, creates the value with list position 0.
     *
     * If the variable has an existing value and it is NOT a list, replaces the existing value. In this case, the new list position will be 0.
     *
     * If the variable has existing values and it IS a list, creates the value with a list position 1 greater than the currently-highest position, that is, appends the value to the list.
     *
     * If the variable is a table column and no rowValueId is specified, associates the new value with the most recently appended row. You MUST append a row value before appending the values of the columns.
     */
    AppendValueOperationPayload: WithRequired<{
      operation: "Append";
    } & Omit<components["schemas"]["ValueOperationPayload"], "operation"> & {
      /**
       * Format: int64
       * @description If the variable is a table column and the new value should be appended to an existing row, the existing row's value ID.
       */
      rowValueId?: number;
      value?: components["schemas"]["NewValuePayload"];
      /** Format: int64 */
      variableId?: number;
    }, "value" | "variableId">;
    ApplicationDeliverablePayload: {
      /** @enum {string} */
      category: "Compliance" | "Financial Viability" | "GIS" | "Carbon Eligibility" | "Stakeholders and Community Impact" | "Proposed Restoration Activities" | "Verra Non-Permanence Risk Tool (NPRT)" | "Supplemental Files";
      /** @description Optional description of the deliverable in HTML form. */
      descriptionHtml?: string;
      /** Format: int64 */
      id: number;
      internalComment?: string;
      /** Format: date-time */
      modifiedTime?: string;
      /** Format: int64 */
      moduleId: number;
      moduleName: string;
      name: string;
      /** Format: int64 */
      organizationId: number;
      organizationName: string;
      /** Format: int64 */
      projectId: number;
      projectName: string;
      /** @enum {string} */
      status: "Not Submitted" | "In Review" | "Needs Translation" | "Approved" | "Rejected" | "Not Needed" | "Completed";
      /** @enum {string} */
      type: "Document" | "Species" | "Questions";
    };
    ApplicationHistoryPayload: {
      feedback?: string;
      /** @description Internal-only comment, if any. Only set if the current user is an internal user. */
      internalComment?: string;
      /** Format: date-time */
      modifiedTime: string;
      /** @enum {string} */
      status: "Accepted" | "Carbon Eligible" | "Failed Pre-screen" | "Issue Active" | "Issue Pending" | "Issue Resolved" | "Needs Follow-up" | "Not Accepted" | "Not Submitted" | "Passed Pre-screen" | "PL Review" | "Pre-check" | "Ready for Review" | "Submitted" | "In Review" | "Waitlist";
    };
    ApplicationModulePayload: {
      /** Format: int64 */
      applicationId?: number;
      /** Format: int64 */
      moduleId: number;
      name: string;
      overview?: string;
      /** @enum {string} */
      phase: "Phase 0 - Due Diligence" | "Phase 1 - Feasibility Study" | "Phase 2 - Plan and Scale" | "Phase 3 - Implement and Monitor" | "Pre-Screen" | "Application";
      /** @enum {string} */
      status?: "Incomplete" | "Complete";
    };
    ApplicationPayload: {
      boundary?: components["schemas"]["MultiPolygon"];
      countryCode?: string;
      /** Format: date-time */
      createdTime: string;
      feedback?: string;
      /** Format: int64 */
      id: number;
      /** @description Internal-only comment, if any. Only set if the current user is an internal user. */
      internalComment?: string;
      /** @description Internal-only reference name of application. Only set if the current user is an internal user. */
      internalName?: string;
      /** Format: date-time */
      modifiedTime?: string;
      /** Format: int64 */
      organizationId: number;
      organizationName: string;
      /** Format: int64 */
      projectId: number;
      projectName: string;
      /** @enum {string} */
      status: "Accepted" | "Carbon Eligible" | "Failed Pre-screen" | "Issue Active" | "Issue Pending" | "Issue Resolved" | "Needs Follow-up" | "Not Accepted" | "Not Submitted" | "Passed Pre-screen" | "PL Review" | "Pre-check" | "Ready for Review" | "Submitted" | "In Review" | "Waitlist";
    };
    AssignParticipantProjectSpeciesPayload: {
      projectIds: number[];
      speciesIds: number[];
    };
    AssignProjectRequestPayload: {
      accessionIds?: number[];
      batchIds?: number[];
      plantingSiteIds?: number[];
    };
    AssignedPlotPayload: {
      boundary: components["schemas"]["Geometry"];
      claimedByName?: string;
      /** Format: int64 */
      claimedByUserId?: number;
      completedByName?: string;
      /** Format: int64 */
      completedByUserId?: number;
      /** Format: date-time */
      completedTime?: string;
      /** @description True if this is the first observation to include the monitoring plot. */
      isFirstObservation: boolean;
      isPermanent: boolean;
      /** Format: int64 */
      observationId: number;
      /** Format: int64 */
      plantingSubzoneId: number;
      plantingSubzoneName: string;
      /** Format: int64 */
      plotId: number;
      plotName: string;
    };
    AutomationPayload: {
      /** @description Human-readable description of this automation. */
      description?: string;
      /** Format: int64 */
      deviceId?: number;
      /** Format: int64 */
      facilityId: number;
      /** Format: int64 */
      id: number;
      /** Format: double */
      lowerThreshold?: number;
      /** @description Short human-readable name of this automation. */
      name: string;
      /** @description Client-defined configuration data for this automation. */
      settings?: {
        [key: string]: unknown;
      };
      timeseriesName?: string;
      type: string;
      /** Format: double */
      upperThreshold?: number;
      /** Format: int32 */
      verbosity: number;
    };
    AutomationTriggerRequestPayload: {
      /** @description Default message to publish if the automation type isn't yet supported by the server. */
      message?: string;
      /**
       * Format: double
       * @description For automations that are triggered by changes to timeseries values, the value that triggered the automation.
       */
      timeseriesValue?: number;
    };
    /** @description A change to the non-quantity-related details of a batch. */
    BatchHistoryDetailsEditedPayload: WithRequired<components["schemas"]["BatchHistoryPayloadCommonProps"] & ({
      notes?: string;
      /**
       * Format: int64
       * @description The ID of the batch's project if the project still exists. If the project was subsequently deleted, this will be null but the project name will still be set.
       */
      projectId?: number;
      /** @description The name of the project at the time the details were edited. If the project was subsequently renamed or deleted, this name remains the same. */
      projectName?: string;
      /** Format: date */
      readyByDate?: string;
      subLocations?: components["schemas"]["BatchHistorySubLocationPayload"][];
      /** @enum {string} */
      substrate?: "MediaMix" | "Soil" | "Sand" | "Moss" | "PerliteVermiculite" | "Other";
      substrateNotes?: string;
      /** @enum {string} */
      treatment?: "Soak" | "Scarify" | "Chemical" | "Stratification" | "Other" | "Light";
      treatmentNotes?: string;
      /** @enum {string} */
      type?: "DetailsEdited";
    }), "createdBy" | "createdTime" | "subLocations" | "type" | "version">;
    /** @description A nursery transfer withdrawal from another batch that added seedlings to this batch. */
    BatchHistoryIncomingWithdrawalPayload: WithRequired<components["schemas"]["BatchHistoryPayloadCommonProps"] & {
      /** Format: int64 */
      fromBatchId?: number;
      /** Format: int32 */
      germinatingQuantityAdded?: number;
      /** Format: int32 */
      notReadyQuantityAdded?: number;
      /** Format: int32 */
      readyQuantityAdded?: number;
      /** @enum {string} */
      type?: "IncomingWithdrawal";
      /** Format: int64 */
      withdrawalId?: number;
      /** Format: date */
      withdrawnDate?: string;
    }, "createdBy" | "createdTime" | "fromBatchId" | "germinatingQuantityAdded" | "notReadyQuantityAdded" | "readyQuantityAdded" | "type" | "version" | "withdrawalId" | "withdrawnDate">;
    /** @description A withdrawal that removed seedlings from this batch. This does not include the full details of the withdrawal; they can be retrieved using the withdrawal ID. */
    BatchHistoryOutgoingWithdrawalPayload: WithRequired<components["schemas"]["BatchHistoryPayloadCommonProps"] & ({
      /** Format: int32 */
      germinatingQuantityWithdrawn?: number;
      /** Format: int32 */
      notReadyQuantityWithdrawn?: number;
      /** @enum {string} */
      purpose?: "Nursery Transfer" | "Dead" | "Out Plant" | "Other" | "Undo";
      /** Format: int32 */
      readyQuantityWithdrawn?: number;
      /** @enum {string} */
      type?: "OutgoingWithdrawal";
      /** Format: int64 */
      withdrawalId?: number;
      /** Format: date */
      withdrawnDate?: string;
    }), "createdBy" | "createdTime" | "germinatingQuantityWithdrawn" | "notReadyQuantityWithdrawn" | "purpose" | "readyQuantityWithdrawn" | "type" | "version" | "withdrawalId" | "withdrawnDate">;
    BatchHistoryPayload: components["schemas"]["BatchHistoryDetailsEditedPayload"] | components["schemas"]["BatchHistoryIncomingWithdrawalPayload"] | components["schemas"]["BatchHistoryOutgoingWithdrawalPayload"] | components["schemas"]["BatchHistoryPhotoCreatedPayload"] | components["schemas"]["BatchHistoryPhotoDeletedPayload"] | components["schemas"]["BatchHistoryQuantityEditedPayload"] | components["schemas"]["BatchHistoryStatusChangedPayload"];
    BatchHistoryPayloadCommonProps: {
      /** Format: int64 */
      createdBy: number;
      /** Format: date-time */
      createdTime: string;
      /** Format: int32 */
      version?: number;
    };
    BatchHistoryPhotoCreatedPayload: WithRequired<components["schemas"]["BatchHistoryPayloadCommonProps"] & {
      /**
       * Format: int64
       * @description ID of the photo if it exists. Null if the photo has been deleted.
       */
      fileId?: number;
      /** @enum {string} */
      type?: "PhotoCreated";
    }, "createdBy" | "createdTime" | "type">;
    BatchHistoryPhotoDeletedPayload: WithRequired<components["schemas"]["BatchHistoryPayloadCommonProps"] & {
      /** @enum {string} */
      type?: "PhotoDeleted";
    }, "createdBy" | "createdTime" | "type">;
    /** @description A manual edit of a batch's remaining quantities. */
    BatchHistoryQuantityEditedPayload: WithRequired<components["schemas"]["BatchHistoryPayloadCommonProps"] & {
      /** Format: int32 */
      germinatingQuantity?: number;
      /** Format: int32 */
      notReadyQuantity?: number;
      /** Format: int32 */
      readyQuantity?: number;
      /** @enum {string} */
      type?: "QuantityEdited";
    }, "createdBy" | "createdTime" | "germinatingQuantity" | "notReadyQuantity" | "readyQuantity" | "type" | "version">;
    /** @description The new quantities resulting from changing the statuses of seedlings in a batch. The values here are the total quantities remaining after the status change, not the number of seedlings whose statuses were changed. */
    BatchHistoryStatusChangedPayload: WithRequired<components["schemas"]["BatchHistoryPayloadCommonProps"] & {
      /** Format: int32 */
      germinatingQuantity?: number;
      /** Format: int32 */
      notReadyQuantity?: number;
      /** Format: int32 */
      readyQuantity?: number;
      /** @enum {string} */
      type?: "StatusChanged";
    }, "createdBy" | "createdTime" | "germinatingQuantity" | "notReadyQuantity" | "readyQuantity" | "type" | "version">;
    BatchHistorySubLocationPayload: {
      /**
       * Format: int64
       * @description The ID of the sub-location if it still exists. If it was subsequently deleted, this will be null but the name will still be present.
       */
      id?: number;
      /** @description The name of the sub-location at the time the details were edited. If the sub-location was subsequently renamed or deleted, this name remains the same. */
      name: string;
    };
    BatchPayload: {
      /**
       * Format: int64
       * @description If this batch was created via a seed withdrawal, the ID of the seed accession it came from.
       */
      accessionId?: number;
      /** @description If this batch was created via a seed withdrawal, the accession number associated to the seed accession it came from. */
      accessionNumber?: string;
      /** Format: date */
      addedDate: string;
      batchNumber: string;
      /** Format: int64 */
      facilityId: number;
      /** Format: int32 */
      germinatingQuantity: number;
      /** Format: int32 */
      germinationRate?: number;
      /** Format: int64 */
      id: number;
      /**
       * Format: int64
       * @description If this batch was created via a nursery transfer from another batch, the ID of the batch it came from.
       */
      initialBatchId?: number;
      /** Format: date-time */
      latestObservedTime: string;
      /** Format: int32 */
      lossRate?: number;
      /** Format: int32 */
      notReadyQuantity: number;
      notes?: string;
      /** Format: int64 */
      projectId?: number;
      /** Format: date */
      readyByDate?: string;
      /** Format: int32 */
      readyQuantity: number;
      /** Format: int64 */
      speciesId: number;
      subLocationIds: number[];
      /** @enum {string} */
      substrate?: "MediaMix" | "Soil" | "Sand" | "Moss" | "PerliteVermiculite" | "Other";
      substrateNotes?: string;
      /** Format: int32 */
      totalWithdrawn: number;
      /** @enum {string} */
      treatment?: "Soak" | "Scarify" | "Chemical" | "Stratification" | "Other" | "Light";
      treatmentNotes?: string;
      /**
       * Format: int32
       * @description Increases every time a batch is updated. Must be passed as a parameter for certain kinds of write operations to detect when a batch has changed since the client last retrieved it.
       */
      version: number;
    };
    BatchPhotoPayload: {
      /** Format: int64 */
      id: number;
    };
    BatchResponsePayload: {
      batch: components["schemas"]["BatchPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    BatchWithdrawalPayload: {
      /** Format: int64 */
      batchId: number;
      /**
       * Format: int32
       * @default 0
       */
      germinatingQuantityWithdrawn?: number;
      /** Format: int32 */
      notReadyQuantityWithdrawn: number;
      /** Format: int32 */
      readyQuantityWithdrawn: number;
    };
    /** @description Coordinate reference system used for X and Y coordinates in this geometry. By default, coordinates are in WGS 84, with longitude and latitude in degrees. In that case, this element is not present. Otherwise, it specifies which coordinate system to use. */
    CRS: {
      properties: components["schemas"]["CRSProperties"];
      /** @enum {string} */
      type: "name";
    };
    CRSProperties: {
      /**
       * @description Name of the coordinate reference system. This must be in the form EPSG:nnnn where nnnn is the numeric identifier of a coordinate system in the EPSG dataset. The default is Longitude/Latitude EPSG:4326, which is the coordinate system +for GeoJSON.
       * @example EPSG:4326
       */
      name: string;
    };
    ChangeBatchStatusRequestPayload: {
      /**
       * @description Which status change to apply.
       * @enum {string}
       */
      operation: "GerminatingToNotReady" | "NotReadyToReady";
      /**
       * Format: int32
       * @description Number of seedlings to move from one status to the next.
       */
      quantity: number;
    };
    CohortListResponsePayload: {
      cohorts: components["schemas"]["CohortPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    CohortModule: {
      /** Format: date */
      endDate: string;
      /** Format: int64 */
      id: number;
      isActive: boolean;
      /** Format: date */
      startDate: string;
      title: string;
    };
    CohortPayload: {
      /** Format: int64 */
      id: number;
      modules: components["schemas"]["CohortModule"][];
      name: string;
      participantIds?: number[];
      /** @enum {string} */
      phase: "Phase 0 - Due Diligence" | "Phase 1 - Feasibility Study" | "Phase 2 - Plan and Scale" | "Phase 3 - Implement and Monitor" | "Pre-Screen" | "Application";
    };
    CohortResponsePayload: {
      cohort: components["schemas"]["CohortPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    CompletePlotObservationRequestPayload: {
      conditions: ("AnimalDamage" | "FastGrowth" | "FavorableWeather" | "Fungus" | "Pests" | "SeedProduction" | "UnfavorableWeather")[];
      notes?: string;
      /**
       * Format: date-time
       * @description Date and time the observation was performed in the field.
       */
      observedTime: string;
      plants: components["schemas"]["RecordedPlantPayload"][];
    };
    CreateAccessionRequestPayloadV2: {
      bagNumbers?: string[];
      /** Format: date */
      collectedDate?: string;
      collectionSiteCity?: string;
      collectionSiteCoordinates?: components["schemas"]["Geolocation"][];
      collectionSiteCountryCode?: string;
      collectionSiteCountrySubdivision?: string;
      collectionSiteLandowner?: string;
      collectionSiteName?: string;
      collectionSiteNotes?: string;
      /** @enum {string} */
      collectionSource?: "Wild" | "Reintroduced" | "Cultivated" | "Other";
      collectors?: string[];
      /** Format: int64 */
      facilityId?: number;
      notes?: string;
      plantId?: string;
      /**
       * Format: int32
       * @description Estimated number of plants the seeds were collected from.
       */
      plantsCollectedFrom?: number;
      /** Format: int64 */
      projectId?: number;
      /** Format: date */
      receivedDate?: string;
      /** @enum {string} */
      source?: "Web" | "Seed Collector App" | "File Import";
      /** Format: int64 */
      speciesId?: number;
      /** @enum {string} */
      state?: "Awaiting Check-In" | "Awaiting Processing" | "Processing" | "Drying" | "In Storage" | "Used Up";
      subLocation?: string;
    };
    CreateAccessionResponsePayloadV2: {
      accession: components["schemas"]["AccessionPayloadV2"];
      status: components["schemas"]["SuccessOrError"];
    };
    CreateApplicationRequestPayload: {
      /** Format: int64 */
      projectId: number;
    };
    CreateApplicationResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateAutomationRequestPayload: {
      description?: string;
      /** Format: int64 */
      deviceId?: number;
      /** Format: int64 */
      facilityId: number;
      /** Format: double */
      lowerThreshold?: number;
      name: string;
      settings?: {
        [key: string]: unknown;
      };
      timeseriesName?: string;
      type: string;
      /** Format: double */
      upperThreshold?: number;
      /** Format: int32 */
      verbosity?: number;
    };
    CreateAutomationResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateBatchPhotoResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateBatchRequestPayload: {
      /** Format: date */
      addedDate: string;
      /** Format: int64 */
      facilityId: number;
      /** Format: int32 */
      germinatingQuantity: number;
      /** Format: int32 */
      notReadyQuantity: number;
      notes?: string;
      /** Format: int64 */
      projectId?: number;
      /** Format: date */
      readyByDate?: string;
      /** Format: int32 */
      readyQuantity: number;
      /** Format: int64 */
      speciesId: number;
      subLocationIds?: number[];
      /** @enum {string} */
      substrate?: "MediaMix" | "Soil" | "Sand" | "Moss" | "PerliteVermiculite" | "Other";
      substrateNotes?: string;
      /** @enum {string} */
      treatment?: "Soak" | "Scarify" | "Chemical" | "Stratification" | "Other" | "Light";
      treatmentNotes?: string;
    };
    CreateCohortRequestPayload: {
      name: string;
      /** @enum {string} */
      phase: "Phase 0 - Due Diligence" | "Phase 1 - Feasibility Study" | "Phase 2 - Plan and Scale" | "Phase 3 - Implement and Monitor" | "Pre-Screen" | "Application";
    };
    CreateDeviceRequestPayload: {
      /**
       * @description Protocol-specific address of device, e.g., an IP address or a Bluetooth device ID.
       * @example 192.168.1.100
       */
      address?: string;
      /**
       * Format: int64
       * @description Identifier of facility where this device is located.
       */
      facilityId: number;
      /**
       * @description Name of device manufacturer.
       * @example InHand Networks
       */
      make: string;
      /**
       * @description Model number or model name of the device.
       * @example IR915L
       */
      model: string;
      /**
       * @description Name of this device.
       * @example BMU-1
       */
      name: string;
      /**
       * Format: int64
       * @description ID of parent device such as a hub or gateway, if any. The parent device must exist.
       */
      parentId?: number;
      /**
       * Format: int32
       * @description Port number if relevant for the protocol.
       * @example 50000
       */
      port?: number;
      /**
       * @description Device manager protocol name.
       * @example modbus
       */
      protocol?: string;
      /** @description Protocol- and device-specific custom settings. This is an arbitrary JSON object; the exact settings depend on the device type. */
      settings?: {
        [key: string]: unknown;
      };
      /**
       * @description High-level type of the device. Device manager may use this in conjunction with the make and model to determine which metrics to report.
       * @example inverter
       */
      type: string;
      /**
       * Format: int32
       * @description Level of diagnostic information to log.
       */
      verbosity?: number;
    };
    CreateDocumentRequestPayload: {
      /** Format: int64 */
      documentTemplateId: number;
      name: string;
      /** Format: int64 */
      ownedBy: number;
      /** Format: int64 */
      projectId: number;
    };
    CreateDocumentResponsePayload: {
      document: components["schemas"]["DocumentPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    CreateDraftPlantingSiteRequestPayload: {
      /** @description In-progress state of the draft. This includes map data and other information needed by the client. It is treated as opaque data by the server. */
      data: {
        [key: string]: unknown;
      };
      description?: string;
      name: string;
      /**
       * Format: int32
       * @description If the user has started defining planting subzones, the number of subzones defined so far.
       */
      numPlantingSubzones?: number;
      /**
       * Format: int32
       * @description If the user has started defining planting zones, the number of zones defined so far.
       */
      numPlantingZones?: number;
      /** Format: int64 */
      organizationId: number;
      /**
       * Format: int64
       * @description If the draft is associated with a project, its ID.
       */
      projectId?: number;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    CreateDraftPlantingSiteResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateFacilityRequestPayload: {
      /** Format: date */
      buildCompletedDate?: string;
      /** Format: date */
      buildStartedDate?: string;
      /**
       * Format: int32
       * @description For nursery facilities, the number of plants this nursery is capable of holding.
       */
      capacity?: number;
      description?: string;
      name: string;
      /** Format: date */
      operationStartedDate?: string;
      /**
       * Format: int64
       * @description Which organization this facility belongs to.
       */
      organizationId: number;
      subLocationNames?: string[];
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
      /** @enum {string} */
      type: "Seed Bank" | "Desalination" | "Reverse Osmosis" | "Nursery";
    };
    CreateFacilityResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateNurseryTransferRequestPayload: {
      /** Format: date */
      date: string;
      /** Format: int64 */
      destinationFacilityId: number;
      /** Format: int32 */
      germinatingQuantity: number;
      /** Format: int32 */
      notReadyQuantity: number;
      notes?: string;
      /** Format: date */
      readyByDate?: string;
      /** Format: int32 */
      readyQuantity: number;
      /**
       * Format: int64
       * @description ID of the user who withdrew the seeds. Default is the current user's ID. If non-null, the current user must have permission to read the referenced user's membership details in the organization.
       */
      withdrawnByUserId?: number;
    };
    CreateNurseryTransferResponsePayload: {
      /** @description Updated accession that includes a withdrawal for the nursery transfer. */
      accession: components["schemas"]["AccessionPayloadV2"];
      /** @description Details of newly-created seedling batch. */
      batch: components["schemas"]["BatchPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    CreateNurseryWithdrawalPhotoResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateNurseryWithdrawalRequestPayload: {
      batchWithdrawals: components["schemas"]["BatchWithdrawalPayload"][];
      /**
       * Format: int64
       * @description If purpose is "Nursery Transfer", the ID of the facility to transfer to. Must be in the same organization as the originating facility. Not allowed for purposes other than "Nursery Transfer".
       */
      destinationFacilityId?: number;
      /** Format: int64 */
      facilityId: number;
      notes?: string;
      /**
       * Format: int64
       * @description If purpose is "Out Plant", the ID of the planting site to which the seedlings were delivered.
       */
      plantingSiteId?: number;
      /**
       * Format: int64
       * @description If purpose is "Out Plant", the ID of the planting subzone to which the seedlings were delivered. Must be specified if the planting site has planting subzones, but must be omitted or set to null if the planting site has no planting subzones.
       */
      plantingSubzoneId?: number;
      /** @enum {string} */
      purpose: "Nursery Transfer" | "Dead" | "Out Plant" | "Other";
      /**
       * Format: date
       * @description If purpose is "Nursery Transfer", the estimated ready-by date to use for the batches that are created at the other nursery.
       */
      readyByDate?: string;
      /** Format: date */
      withdrawnDate: string;
    };
    CreateOrganizationRequestPayload: {
      /**
       * @description ISO 3166 alpha-2 code of organization's country.
       * @example AU
       */
      countryCode?: string;
      /**
       * @description ISO 3166-2 code of organization's country subdivision (state, province, region, etc.) This is the full ISO 3166-2 code including the country prefix. If this is set, countryCode must also be set.
       * @example US-HI
       */
      countrySubdivisionCode?: string;
      description?: string;
      managedLocationTypes?: ("SeedBank" | "Nursery" | "PlantingSite")[];
      name: string;
      /** @enum {string} */
      organizationType?: "Government" | "NGO" | "Arboreta" | "Academia" | "ForProfit" | "Other";
      /** @description Non-empty additional description of organization when type is Other. */
      organizationTypeDetails?: string;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
      /** @description Website of organization, no restrictions on format. */
      website?: string;
    };
    CreateOrganizationUserResponsePayload: {
      /**
       * Format: int64
       * @description The ID of the newly-added user.
       */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateParticipantProjectSpeciesPayload: {
      /** Format: int64 */
      projectId: number;
      rationale?: string;
      /** Format: int64 */
      speciesId: number;
      /** @enum {string} */
      speciesNativeCategory?: "Native" | "Non-native";
    };
    CreateParticipantRequestPayload: {
      /**
       * Format: int64
       * @description Assign the participant to this cohort. If null, the participant will not be assigned to any cohort initially.
       */
      cohortId?: number;
      name: string;
      /** @description Assign these projects to the new participant. If projects are already assigned to other participants, they will be reassigned to the new one. */
      projectIds?: number[];
    };
    CreatePlantingSiteRequestPayload: {
      boundary?: components["schemas"]["MultiPolygon"] | components["schemas"]["Polygon"];
      description?: string;
      exclusion?: components["schemas"]["MultiPolygon"] | components["schemas"]["Polygon"];
      name: string;
      /** Format: int64 */
      organizationId: number;
      plantingSeasons?: components["schemas"]["NewPlantingSeasonPayload"][];
      /** @description List of planting zones to create. If present and not empty, "boundary" must also be specified. */
      plantingZones?: components["schemas"]["NewPlantingZonePayload"][];
      /** Format: int64 */
      projectId?: number;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    CreatePlantingSiteResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateProjectRequestPayload: {
      description?: string;
      name: string;
      /** Format: int64 */
      organizationId: number;
    };
    CreateProjectResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateSavedDocumentVersionRequestPayload: {
      /** @default false */
      isSubmitted?: boolean;
      name: string;
    };
    CreateSavedDocumentVersionResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      version: components["schemas"]["DocumentSavedVersionPayload"];
    };
    CreateSpeciesResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateSubLocationRequestPayload: {
      name: string;
    };
    CreateTimeseriesEntry: {
      /**
       * Format: int32
       * @description Number of significant fractional digits (after the decimal point), if this is a timeseries with non-integer numeric values.
       */
      decimalPlaces?: number;
      /**
       * Format: int64
       * @description ID of device that produces this timeseries.
       */
      deviceId: number;
      /** @description Name of this timeseries. Duplicate timeseries names for the same device aren't allowed, but different devices can have timeseries with the same name. */
      timeseriesName: string;
      /** @enum {string} */
      type: "Numeric" | "Text";
      /**
       * @description Units of measure for values in this timeseries.
       * @example volts
       */
      units?: string;
    };
    CreateTimeseriesRequestPayload: {
      timeseries: components["schemas"]["CreateTimeseriesEntry"][];
    };
    CreateViabilityTestRequestPayload: {
      /** Format: date */
      endDate?: string;
      notes?: string;
      /** @enum {string} */
      seedType?: "Fresh" | "Stored";
      /** Format: int32 */
      seedsCompromised?: number;
      /** Format: int32 */
      seedsEmpty?: number;
      /** Format: int32 */
      seedsFilled?: number;
      /** Format: int32 */
      seedsTested: number;
      /** Format: date */
      startDate?: string;
      /** @enum {string} */
      substrate?: "Nursery Media" | "Agar" | "Paper" | "Other" | "Sand" | "Media Mix" | "Soil" | "Moss" | "Perlite/Vermiculite" | "None";
      testResults?: components["schemas"]["ViabilityTestResultPayload"][];
      /** @enum {string} */
      testType: "Lab" | "Nursery" | "Cut";
      /** @enum {string} */
      treatment?: "Soak" | "Scarify" | "Chemical" | "Stratification" | "Other" | "Light";
      /**
       * Format: int64
       * @description ID of user who withdrew seeds to perform the test. Defaults to the current user. If non-null, the current user must have permission to see the referenced user's membership details in the organization.
       */
      withdrawnByUserId?: number;
    };
    CreateWithdrawalRequestPayload: {
      /** Format: date */
      date?: string;
      notes?: string;
      /** @enum {string} */
      purpose?: "Other" | "Viability Testing" | "Out-planting" | "Nursery";
      /**
       * Format: int64
       * @description ID of the user who withdrew the seeds. Default is the current user's ID. If non-null, the current user must have permission to read the referenced user's membership details in the organization.
       */
      withdrawnByUserId?: number;
      /** @description Quantity of seeds withdrawn. If this quantity is in weight and the remaining quantity of the accession is in seeds or vice versa, the accession must have a subset weight and count. */
      withdrawnQuantity?: components["schemas"]["SeedQuantityPayload"];
    };
    DateVariablePayload: {
      type: "Date";
    } & Omit<components["schemas"]["VariablePayload"], "type">;
    DeleteGlobalRolesRequestPayload: {
      userIds: number[];
    };
    DeleteParticipantProjectSpeciesPayload: {
      participantProjectSpeciesIds: number[];
    };
    DeleteProjectVotesRequestPayload: {
      /** @enum {string} */
      phase: "Phase 0 - Due Diligence" | "Phase 1 - Feasibility Study" | "Phase 2 - Plan and Scale" | "Phase 3 - Implement and Monitor" | "Pre-Screen" | "Application";
      /** @description A safeguard flag that must be set to `true` for deleting all voters in a project phase. */
      phaseDelete?: boolean;
      /**
       * Format: int64
       * @description If set to `null`, all voters in the phase will be removed.
       */
      userId?: number;
    };
    /**
     * @description Operation that deletes a value from a variable. Deletion is non-destructive; this actually creates a new value with its own value ID, where the new value is marked as deleted. This "is deleted" value is included in incremental value query results.
     *
     * If the variable is a list and there are other values with higher list positions, the remaining items will be renumbered such that the list remains contiguously numbered starting at 0.
     *
     * If the variable is a table, or in other words if the value is a table row, any values associated with the row are also deleted. The row itself gets a new value that is marked as deleted, and the new values that are created to delete the row's contents are associated with this newly-created deleted row value.
     */
    DeleteValueOperationPayload: WithRequired<{
      operation: "Delete";
    } & Omit<components["schemas"]["ValueOperationPayload"], "operation"> & {
      /** Format: int64 */
      valueId?: number;
    }, "existingValueId" | "valueId">;
    DeliverablePayload: {
      /** @enum {string} */
      category: "Compliance" | "Financial Viability" | "GIS" | "Carbon Eligibility" | "Stakeholders and Community Impact" | "Proposed Restoration Activities" | "Verra Non-Permanence Risk Tool (NPRT)" | "Supplemental Files";
      /** @description Optional description of the deliverable in HTML form. */
      descriptionHtml?: string;
      documents: components["schemas"]["SubmissionDocumentPayload"][];
      /**
       * Format: date
       * @description If the deliverable has been reviewed, the user-visible feedback from the review.
       */
      dueDate?: string;
      feedback?: string;
      /** Format: int64 */
      id: number;
      /** @description Internal-only comment on the submission. Only present if the current user has accelerator admin privileges. */
      internalComment?: string;
      name: string;
      /** Format: int64 */
      organizationId: number;
      organizationName: string;
      /** Format: int64 */
      participantId?: number;
      participantName?: string;
      /** Format: int64 */
      projectId: number;
      projectName: string;
      /** @enum {string} */
      status: "Not Submitted" | "In Review" | "Needs Translation" | "Approved" | "Rejected" | "Not Needed" | "Completed";
      /** Format: uri */
      templateUrl?: string;
      /** @enum {string} */
      type: "Document" | "Species" | "Questions";
    };
    /** @description If the withdrawal was an outplanting to a planting site, the delivery that was created. Not present for other withdrawal purposes. */
    DeliveryPayload: {
      /** Format: int64 */
      id: number;
      /** Format: int64 */
      plantingSiteId: number;
      plantings: components["schemas"]["PlantingPayload"][];
      /** Format: int64 */
      withdrawalId: number;
    };
    DeviceConfig: {
      /**
       * @description Protocol-specific address of device, e.g., an IP address or a Bluetooth device ID.
       * @example 192.168.1.100
       */
      address?: string;
      /**
       * Format: int64
       * @description Identifier of facility where this device is located.
       */
      facilityId: number;
      /**
       * Format: int64
       * @description Unique identifier of this device.
       */
      id: number;
      /**
       * @description Name of device manufacturer.
       * @example InHand Networks
       */
      make: string;
      /**
       * @description Model number or model name of the device.
       * @example IR915L
       */
      model: string;
      /**
       * @description Name of this device.
       * @example BMU-1
       */
      name: string;
      /**
       * Format: int64
       * @description ID of parent device such as a hub or gateway, if any.
       */
      parentId?: number;
      /**
       * Format: int32
       * @description Port number if relevant for the protocol.
       * @example 50000
       */
      port?: number;
      /**
       * @description Device manager protocol name.
       * @example modbus
       */
      protocol?: string;
      settings?: Record<string, never>;
      /**
       * @description High-level type of the device. Device manager may use this in conjunction with the make and model to determine which metrics to report.
       * @example inverter
       */
      type: string;
      /**
       * Format: int32
       * @description Level of diagnostic information to log.
       */
      verbosity?: number;
    };
    DeviceUnresponsiveRequestPayload: {
      /**
       * Format: int32
       * @description The expected amount of time between updates from the device. Null or absent if there is no fixed update interval.
       */
      expectedIntervalSecs?: number;
      /**
       * Format: date-time
       * @description When the device most recently responded. Null or absent if the device has never responded.
       */
      lastRespondedTime?: string;
    };
    /** @description History entry about the creation of the document. This is always the last element in the reverse-chronological list of history events. It has the same information as the createdBy and createdTime fields in DocumentPayload. */
    DocumentHistoryCreatedPayload: WithRequired<{
      type: "Created";
    } & Omit<components["schemas"]["DocumentHistoryPayload"], "type">, "createdBy" | "createdTime" | "type">;
    /** @description History entry about a document being edited. This represents the most recent edit by the given user; if the same user edits the document multiple times in a row, only the last edit will be listed in the history. */
    DocumentHistoryEditedPayload: WithRequired<{
      type: "Edited";
    } & Omit<components["schemas"]["DocumentHistoryPayload"], "type">, "createdBy" | "createdTime" | "type">;
    DocumentHistoryPayload: {
      /** Format: int64 */
      createdBy: number;
      /** Format: date-time */
      createdTime: string;
      /** @enum {string} */
      type: "Created" | "Edited" | "Saved";
    };
    /** @description History entry about a saved version of a document. The maxVariableValueId and variableManifestId may be used to retrieve the contents of the saved version. */
    DocumentHistorySavedPayload: WithRequired<{
      type: "Saved";
    } & Omit<components["schemas"]["DocumentHistoryPayload"], "type"> & {
      isSubmitted?: boolean;
      /** Format: int64 */
      maxVariableValueId?: number;
      name?: string;
      /** Format: int64 */
      variableManifestId?: number;
      /** Format: int64 */
      versionId?: number;
    }, "createdBy" | "createdTime" | "isSubmitted" | "maxVariableValueId" | "name" | "type" | "variableManifestId" | "versionId">;
    DocumentPayload: {
      /** Format: int64 */
      createdBy: number;
      /** Format: date-time */
      createdTime: string;
      /** Format: int64 */
      documentTemplateId: number;
      /** Format: int64 */
      id: number;
      internalComment?: string;
      /** Format: int64 */
      lastSavedVersionId?: number;
      /** Format: int64 */
      modifiedBy: number;
      /** Format: date-time */
      modifiedTime: string;
      name: string;
      /** Format: int64 */
      ownedBy: number;
      /** Format: int64 */
      projectId: number;
      projectName: string;
      /** @enum {string} */
      status: "Draft" | "Locked" | "Published" | "Ready" | "Submitted";
      /** Format: int64 */
      variableManifestId: number;
    };
    /** @description Information about a saved version of a document. The maxVariableValueId and variableManifestId may be used to retrieve the contents of the saved version. */
    DocumentSavedVersionPayload: {
      /** Format: int64 */
      createdBy: number;
      /** Format: date-time */
      createdTime: string;
      isSubmitted: boolean;
      /** Format: int64 */
      maxVariableValueId: number;
      name: string;
      /** Format: int64 */
      variableManifestId: number;
      /** Format: int64 */
      versionId: number;
    };
    DocumentTemplatePayload: {
      /** Format: int64 */
      id: number;
      name: string;
      /**
       * Format: int64
       * @description ID of the most recent variable manifest for the document template, if any.
       */
      variableManifestId?: number;
    };
    DraftPlantingSitePayload: {
      /**
       * Format: int64
       * @description ID of the user who created this draft. Only that user is allowed to modify or delete the draft.
       */
      createdBy: number;
      /** Format: date-time */
      createdTime: string;
      /** @description In-progress state of the draft. This includes map data and other information needed by the client. It is treated as opaque data by the server. */
      data: {
        [key: string]: unknown;
      };
      description?: string;
      /** Format: int64 */
      id: number;
      /** Format: date-time */
      modifiedTime: string;
      name: string;
      /**
       * Format: int32
       * @description If the user has started defining planting subzones, the number of subzones defined so far.
       */
      numPlantingSubzones?: number;
      /**
       * Format: int32
       * @description If the user has started defining planting zones, the number of zones defined so far.
       */
      numPlantingZones?: number;
      /** Format: int64 */
      organizationId: number;
      /**
       * Format: int64
       * @description If the draft is associated with a project, its ID.
       */
      projectId?: number;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    ErrorDetails: {
      message: string;
    };
    ExistingDateValuePayload: WithRequired<{
      type: "Date";
    } & Omit<components["schemas"]["ExistingValuePayload"], "type"> & {
      /** Format: date */
      dateValue?: string;
    }, "dateValue" | "id" | "listPosition" | "type">;
    /** @description Represents the deletion of an earlier value at the same location. This is only included when you are querying for incremental changes to a document's values. */
    ExistingDeletedValuePayload: WithRequired<{
      type: "Deleted";
    } & Omit<components["schemas"]["ExistingValuePayload"], "type">, "id" | "listPosition" | "type">;
    /** @description Metadata about an image. The actual image data (e.g., the JPEG or PNG file) must be retrieved in a separate request using the value ID in this payload. */
    ExistingImageValuePayload: WithRequired<{
      type: "Image";
    } & Omit<components["schemas"]["ExistingValuePayload"], "type"> & {
      caption?: string;
    }, "id" | "listPosition" | "type">;
    ExistingLinkValuePayload: WithRequired<{
      type: "Link";
    } & Omit<components["schemas"]["ExistingValuePayload"], "type"> & {
      title?: string;
      /** Format: uri */
      url?: string;
    }, "id" | "listPosition" | "type" | "url">;
    ExistingNumberValuePayload: WithRequired<{
      type: "Number";
    } & Omit<components["schemas"]["ExistingValuePayload"], "type"> & {
      numberValue?: number;
    }, "id" | "listPosition" | "numberValue" | "type">;
    ExistingSectionTextValuePayload: WithRequired<{
      type: "SectionText";
    } & Omit<components["schemas"]["ExistingValuePayload"], "type"> & {
      textValue?: string;
    }, "id" | "listPosition" | "textValue" | "type">;
    ExistingSectionVariableValuePayload: WithRequired<{
      type: "SectionVariable";
    } & Omit<components["schemas"]["ExistingValuePayload"], "type"> & ({
      /** @enum {string} */
      displayStyle?: "Inline" | "Block";
      /** @enum {string} */
      usageType?: "Injection" | "Reference";
      /** Format: int64 */
      variableId?: number;
    }), "id" | "listPosition" | "type" | "usageType" | "variableId">;
    ExistingSelectValuePayload: WithRequired<{
      type: "Select";
    } & Omit<components["schemas"]["ExistingValuePayload"], "type"> & {
      optionValues?: number[];
    }, "id" | "listPosition" | "optionValues" | "type">;
    /** @description A row in a table. Each row has its own value ID. ExistingVariableValuesPayload includes this ID for values of variables that are defined as columns of a table. */
    ExistingTableValuePayload: WithRequired<{
      type: "Table";
    } & Omit<components["schemas"]["ExistingValuePayload"], "type">, "id" | "listPosition" | "type">;
    ExistingTextValuePayload: WithRequired<{
      type: "Text";
    } & Omit<components["schemas"]["ExistingValuePayload"], "type"> & {
      textValue?: string;
    }, "id" | "listPosition" | "textValue" | "type">;
    /** @description Values of this variable or this table cell. When getting the full set of values for a document, this will be the complete list of this variable's values in order of list position. When getting incremental changes to a document, this is only the items that have changed, and existing items won't be present. For example, if a variable is a list and has 3 values, and a fourth value is added, the incremental list of values in this payload will have one item and its list position will be 3 (since lists are 0-indexed). */
    ExistingValuePayload: {
      citation?: string;
      /** Format: int64 */
      id: number;
      /** Format: int32 */
      listPosition: number;
      /** @enum {string} */
      type: "Date" | "Deleted" | "Image" | "Link" | "Number" | "SectionText" | "SectionVariable" | "Select" | "Table" | "Text";
    };
    ExistingVariableValuesPayload: {
      /** @description User-visible feedback from reviewer. Not populated for table cell values. */
      feedback?: string;
      /** @description Internal comment from reviewer. Only populated if the current user has permission to read internal comments. Not populated for table cell values. */
      internalComment?: string;
      /**
       * Format: int64
       * @description If this is the value of a table cell, the ID of the row it's part of.
       */
      rowValueId?: number;
      /**
       * @description Current status of this variable. Not populated for table cell values.
       * @enum {string}
       */
      status?: "Not Submitted" | "In Review" | "Needs Translation" | "Approved" | "Rejected" | "Not Needed" | "Incomplete" | "Complete";
      /** @description Values of this variable or this table cell. When getting the full set of values for a document, this will be the complete list of this variable's values in order of list position. When getting incremental changes to a document, this is only the items that have changed, and existing items won't be present. For example, if a variable is a list and has 3 values, and a fourth value is added, the incremental list of values in this payload will have one item and its list position will be 3 (since lists are 0-indexed). */
      values: (components["schemas"]["ExistingDateValuePayload"] | components["schemas"]["ExistingDeletedValuePayload"] | components["schemas"]["ExistingImageValuePayload"] | components["schemas"]["ExistingLinkValuePayload"] | components["schemas"]["ExistingNumberValuePayload"] | components["schemas"]["ExistingSectionTextValuePayload"] | components["schemas"]["ExistingSectionVariableValuePayload"] | components["schemas"]["ExistingSelectValuePayload"] | components["schemas"]["ExistingTableValuePayload"] | components["schemas"]["ExistingTextValuePayload"])[];
      /** Format: int64 */
      variableId: number;
    };
    FacilityPayload: {
      /** Format: date */
      buildCompletedDate?: string;
      /** Format: date */
      buildStartedDate?: string;
      /**
       * Format: int32
       * @description For nursery facilities, the number of plants this nursery is capable of holding.
       */
      capacity?: number;
      /** @enum {string} */
      connectionState: "Not Connected" | "Connected" | "Configured";
      /** Format: date-time */
      createdTime: string;
      description?: string;
      /**
       * Format: int32
       * @description Short numeric identifier for this facility. Facility numbers start at 1 for each facility type in an organization.
       */
      facilityNumber: number;
      /** Format: int64 */
      id: number;
      name: string;
      /** Format: date */
      operationStartedDate?: string;
      /** Format: int64 */
      organizationId: number;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
      /** @enum {string} */
      type: "Seed Bank" | "Desalination" | "Reverse Osmosis" | "Nursery";
    };
    FieldNodePayload: WithRequired<{
      operation: "field";
    } & Omit<components["schemas"]["SearchNodePayload"], "operation"> & ({
      field?: string;
      /** @enum {string} */
      type?: "Exact" | "ExactOrFuzzy" | "Fuzzy" | "PhraseMatch" | "Range";
      /** @description List of values to match. For exact, fuzzy and phrase match searches, a list of at least one value to search for; the list may include null to match accessions where the field does not have a value. For range searches, the list must contain exactly two values, the minimum and maximum; one of the values may be null to search for all values above a minimum or below a maximum. */
      values?: (string | null)[];
    }), "field" | "type" | "values">;
    FieldValuesPayload: {
      /** @description If true, the list of values is too long to return in its entirety and "values" is a partial list. */
      partial: boolean;
      /** @description List of values in the matching accessions. If there are accessions where the field has no value, this list will contain null (an actual null value, not the string "null"). */
      values: (string | null)[];
    };
    Geolocation: {
      accuracy?: number;
      latitude: number;
      longitude: number;
    };
    /** @description GEOMETRY-FIX-TYPE-ON-CLIENT-SIDE */
    Geometry: {
      crs?: components["schemas"]["CRS"];
      /** @enum {string} */
      type: "Point" | "LineString" | "Polygon" | "MultiPoint" | "MultiLineString" | "MultiPolygon" | "GeometryCollection";
    };
    GeometryCollection: WithRequired<{
      type: "GeometryCollection";
    } & Omit<components["schemas"]["Geometry"], "type"> & {
      geometries?: components["schemas"]["Geometry"][];
      /** @enum {string} */
      type?: "GeometryCollection";
    }, "geometries" | "type">;
    GetAccessionHistoryResponsePayload: {
      /** @description History of changes in descending time order (newest first.) */
      history: components["schemas"]["AccessionHistoryEntryPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetAccessionResponsePayloadV2: {
      accession: components["schemas"]["AccessionPayloadV2"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetApplicationDeliverablesResponsePayload: {
      deliverables: components["schemas"]["ApplicationDeliverablePayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetApplicationHistoryResponsePayload: {
      /** @description History of metadata changes in reverse chronological order. */
      history: components["schemas"]["ApplicationHistoryPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetApplicationModulesResponsePayload: {
      modules: components["schemas"]["ApplicationModulePayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetApplicationResponsePayload: {
      application: components["schemas"]["ApplicationPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetAutomationResponsePayload: {
      automation: components["schemas"]["AutomationPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetBatchHistoryResponsePayload: {
      history: components["schemas"]["BatchHistoryPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetCurrentTimeResponsePayload: {
      /** Format: date-time */
      currentTime: string;
      status: components["schemas"]["SuccessOrError"];
    };
    GetDeliverableResponsePayload: {
      deliverable: components["schemas"]["DeliverablePayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetDeliveryResponsePayload: {
      delivery: components["schemas"]["DeliveryPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetDeviceResponsePayload: {
      device: components["schemas"]["DeviceConfig"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetDocumentHistoryResponsePayload: {
      /** @description List of events in the document's history in reverse chronological order. The last element is always the "Created" event. */
      history: (components["schemas"]["DocumentHistoryCreatedPayload"] | components["schemas"]["DocumentHistoryEditedPayload"] | components["schemas"]["DocumentHistorySavedPayload"])[];
      status: components["schemas"]["SuccessOrError"];
    };
    GetDocumentResponsePayload: {
      document: components["schemas"]["DocumentPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetDraftPlantingSiteResponsePayload: {
      site: components["schemas"]["DraftPlantingSitePayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetFacilityResponse: {
      facility: components["schemas"]["FacilityPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetMapboxTokenResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      token: string;
    };
    GetNotificationResponsePayload: {
      notification: components["schemas"]["NotificationPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetNotificationsCountResponsePayload: {
      notifications: components["schemas"]["NotificationCountPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetNotificationsResponsePayload: {
      notifications: components["schemas"]["NotificationPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetNurserySummaryResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      summary: components["schemas"]["NurserySummaryPayload"];
    };
    GetNurseryV1: {
      /** Format: date */
      buildCompletedDate?: string;
      buildCompletedDateEditable: boolean;
      /** Format: date */
      buildStartedDate?: string;
      buildStartedDateEditable: boolean;
      /** Format: int32 */
      capacity?: number;
      /** Format: int64 */
      id: number;
      /** Format: int32 */
      mortalityRate: number;
      name: string;
      notes?: string;
      /** Format: date */
      operationStartedDate?: string;
      operationStartedDateEditable: boolean;
      selected: boolean;
      /** Format: int64 */
      totalPlantsPropagated: number;
      /** Format: int64 */
      totalPlantsPropagatedForProject?: number;
      workers: components["schemas"]["WorkersPayloadV1"];
    };
    GetNurseryWithdrawalResponsePayload: {
      batches: components["schemas"]["BatchPayload"][];
      /** @description If the withdrawal was an outplanting to a planting site, the delivery that was created. Not present for other withdrawal purposes. */
      delivery?: components["schemas"]["DeliveryPayload"];
      status: components["schemas"]["SuccessOrError"];
      withdrawal: components["schemas"]["NurseryWithdrawalPayload"];
    };
    GetObservationResponsePayload: {
      observation: components["schemas"]["ObservationPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetObservationResultsResponsePayload: {
      observation: components["schemas"]["ObservationResultsPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetOrganizationResponsePayload: {
      organization: components["schemas"]["OrganizationPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetOrganizationUserResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      user: components["schemas"]["OrganizationUserPayload"];
    };
    GetParticipantProjectSpeciesResponsePayload: {
      participantProjectSpecies: components["schemas"]["ParticipantProjectSpeciesPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetParticipantProjectsForSpeciesResponsePayload: {
      participantProjectsForSpecies: components["schemas"]["ParticipantProjectForSpeciesPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetParticipantResponsePayload: {
      participant: components["schemas"]["ParticipantPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetPlantingSiteReportedPlantsResponsePayload: {
      site: components["schemas"]["PlantingSiteReportedPlantsPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetPlantingSiteResponsePayload: {
      site: components["schemas"]["PlantingSitePayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetPlantingSiteSpeciesV1: {
      /** Format: int64 */
      id: number;
      /** Format: int32 */
      mortalityRateInField?: number;
      /** Format: int32 */
      totalPlanted?: number;
    };
    GetPlantingSiteV1: {
      /** Format: int64 */
      id: number;
      /** Format: int32 */
      mortalityRate?: number;
      name: string;
      notes?: string;
      selected: boolean;
      species: components["schemas"]["GetPlantingSiteSpeciesV1"][];
      /** Format: int32 */
      totalPlantedArea?: number;
      /** Format: int32 */
      totalPlantingSiteArea?: number;
      /** Format: int32 */
      totalPlantsPlanted?: number;
      /** Format: int32 */
      totalTreesPlanted?: number;
      workers: components["schemas"]["WorkersPayloadV1"];
    };
    GetProjectAcceleratorDetailsResponsePayload: {
      details: components["schemas"]["ProjectAcceleratorDetailsPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetProjectModuleResponsePayload: {
      module: components["schemas"]["ProjectModule"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetProjectModulesResponsePayload: {
      modules: components["schemas"]["ProjectModule"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetProjectResponsePayload: {
      project: components["schemas"]["ProjectPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetProjectScoresResponsePayload: {
      phases: components["schemas"]["PhaseScores"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetProjectVotesResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      votes: components["schemas"]["ProjectVotesPayload"];
    };
    GetReportPayload: {
      /** Format: int64 */
      id: number;
      lockedByName?: string;
      /** Format: int64 */
      lockedByUserId?: number;
      /** Format: date-time */
      lockedTime?: string;
      modifiedByName?: string;
      /** Format: int64 */
      modifiedByUserId?: number;
      /** Format: date-time */
      modifiedTime?: string;
      /** Format: int64 */
      projectId?: number;
      projectName?: string;
      /** Format: int32 */
      quarter: number;
      /** @enum {string} */
      status: "New" | "In Progress" | "Locked" | "Submitted";
      submittedByName?: string;
      /** Format: int64 */
      submittedByUserId?: number;
      /** Format: date-time */
      submittedTime?: string;
      version: string;
      /** Format: int32 */
      year: number;
    };
    GetReportPayloadV1: WithRequired<{
      version: "1";
    } & Omit<components["schemas"]["GetReportPayload"], "version"> & {
      annualDetails?: components["schemas"]["AnnualDetailsPayloadV1"];
      isAnnual?: boolean;
      notes?: string;
      nurseries?: components["schemas"]["GetNurseryV1"][];
      organizationName?: string;
      plantingSites?: components["schemas"]["GetPlantingSiteV1"][];
      seedBanks?: components["schemas"]["GetSeedBankV1"][];
      summaryOfProgress?: string;
      /** Format: int32 */
      totalNurseries?: number;
      /** Format: int32 */
      totalPlantingSites?: number;
      /** Format: int32 */
      totalSeedBanks?: number;
    }, "id" | "isAnnual" | "nurseries" | "organizationName" | "plantingSites" | "quarter" | "seedBanks" | "status" | "totalNurseries" | "totalPlantingSites" | "totalSeedBanks" | "year">;
    GetReportResponsePayload: {
      report: components["schemas"]["GetReportPayloadV1"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetReportSettingsResponsePayload: {
      /** @description If false, settings have not been configured yet and the values in the rest of the payload are the defaults. */
      isConfigured: boolean;
      /** @description If true, organization-level reports are enabled. */
      organizationEnabled: boolean;
      /** @description Per-project report settings. */
      projects: components["schemas"]["ProjectReportSettingsPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetSavedDocumentVersionResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      version: components["schemas"]["DocumentSavedVersionPayload"];
    };
    GetSeedBankV1: {
      /** Format: date */
      buildCompletedDate?: string;
      buildCompletedDateEditable: boolean;
      /** Format: date */
      buildStartedDate?: string;
      buildStartedDateEditable: boolean;
      /** Format: int64 */
      id: number;
      name: string;
      notes?: string;
      /** Format: date */
      operationStartedDate?: string;
      operationStartedDateEditable: boolean;
      selected: boolean;
      /** Format: int64 */
      totalSeedsStored: number;
      /** Format: int64 */
      totalSeedsStoredForProject?: number;
      workers: components["schemas"]["WorkersPayloadV1"];
    };
    GetSpeciesForParticipantProjectsResponsePayload: {
      speciesForParticipantProjects: components["schemas"]["SpeciesForParticipantProjectPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetSpeciesProblemResponsePayload: {
      problem: components["schemas"]["SpeciesProblemElement"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetSpeciesResponsePayload: {
      species: components["schemas"]["SpeciesResponseElement"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetSpeciesSummaryResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      summary: components["schemas"]["SpeciesSummaryPayload"];
    };
    GetSubLocationResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      subLocation: components["schemas"]["SubLocationPayload"];
    };
    GetUploadStatusDetailsPayload: {
      errors?: components["schemas"]["UploadProblemPayload"][];
      /** @description True if the server is finished processing the file, either successfully or not. */
      finished: boolean;
      /** Format: int64 */
      id: number;
      /** @enum {string} */
      status: "Receiving" | "Validating" | "Processing" | "Completed" | "Processing Failed" | "Invalid" | "Receiving Failed" | "Awaiting Validation" | "Awaiting User Action" | "Awaiting Processing";
      warnings?: components["schemas"]["UploadProblemPayload"][];
    };
    GetUploadStatusResponsePayload: {
      details: components["schemas"]["GetUploadStatusDetailsPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetUserDeliverableCategoriesResponsePayload: {
      deliverableCategories: ("Compliance" | "Financial Viability" | "GIS" | "Carbon Eligibility" | "Stakeholders and Community Impact" | "Proposed Restoration Activities" | "Verra Non-Permanence Risk Tool (NPRT)" | "Supplemental Files")[];
      status: components["schemas"]["SuccessOrError"];
    };
    GetUserPreferencesResponsePayload: {
      /** @description The user's preferences, or null if no preferences have been stored yet. */
      preferences?: {
        [key: string]: unknown;
      };
      status: components["schemas"]["SuccessOrError"];
    };
    GetUserResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      user: components["schemas"]["UserProfilePayload"];
    };
    GetViabilityTestPayload: {
      /** Format: int64 */
      accessionId: number;
      /** Format: date */
      endDate?: string;
      /** Format: int64 */
      id: number;
      notes?: string;
      /** @enum {string} */
      seedType?: "Fresh" | "Stored";
      /** Format: int32 */
      seedsCompromised?: number;
      /** Format: int32 */
      seedsEmpty?: number;
      /** Format: int32 */
      seedsFilled?: number;
      /** Format: int32 */
      seedsTested: number;
      /** Format: date */
      startDate?: string;
      /** @enum {string} */
      substrate?: "Nursery Media" | "Agar" | "Paper" | "Other" | "Sand" | "Media Mix" | "Soil" | "Moss" | "Perlite/Vermiculite" | "None";
      testResults?: components["schemas"]["ViabilityTestResultPayload"][];
      /** @enum {string} */
      testType: "Lab" | "Nursery" | "Cut";
      /** Format: int32 */
      totalSeedsGerminated?: number;
      /** @enum {string} */
      treatment?: "Soak" | "Scarify" | "Chemical" | "Stratification" | "Other" | "Light";
      /**
       * Format: int32
       * @description Server-calculated viability percent for this test. For lab and nursery tests, this is based on the total seeds germinated across all test results. For cut tests, it is based on the number of seeds filled.
       */
      viabilityPercent?: number;
      /** @description Full name of user who withdrew seeds to perform the test. */
      withdrawnByName?: string;
      /**
       * Format: int64
       * @description ID of user who withdrew seeds to perform the test.
       */
      withdrawnByUserId?: number;
    };
    GetViabilityTestResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      viabilityTest: components["schemas"]["GetViabilityTestPayload"];
    };
    GetWithdrawalPayload: {
      /** Format: date */
      date: string;
      /**
       * Format: int32
       * @description Number of seeds withdrawn. Calculated by server. This is an estimate if "withdrawnQuantity" is a weight quantity and the accession has subset weight and count data. Absent if "withdrawnQuantity" is a weight quantity and the accession has no subset weight and count.
       */
      estimatedCount?: number;
      /** @description Weight of seeds withdrawn. Calculated by server. This is an estimate if "withdrawnQuantity" is a seed count and the accession has subset weight and count data. Absent if "withdrawnQuantity" is a seed count and the accession has no subset weight and count. */
      estimatedWeight?: components["schemas"]["SeedQuantityPayload"];
      /**
       * Format: int64
       * @description Server-assigned unique ID of this withdrawal.
       */
      id?: number;
      notes?: string;
      /** @enum {string} */
      purpose?: "Other" | "Viability Testing" | "Out-planting" | "Nursery";
      /**
       * Format: int64
       * @description If this withdrawal is of purpose "Viability Testing", the ID of the test it is associated with.
       */
      viabilityTestId?: number;
      /** @description Full name of the person who withdrew the seeds. V1 COMPATIBILITY: This is the "staffResponsible" v1 field, which may not be the name of an organization user. */
      withdrawnByName?: string;
      /**
       * Format: int64
       * @description ID of the user who withdrew the seeds. Only present if the current user has permission to list the users in the organization. V1 COMPATIBILITY: Also absent if the withdrawal was written with the v1 API and we haven't yet written the code to figure out which user ID to assign.
       */
      withdrawnByUserId?: number;
      /** @description Quantity of seeds withdrawn. For viability testing withdrawals, this is always the same as the test's "seedsTested" value. */
      withdrawnQuantity?: components["schemas"]["SeedQuantityPayload"];
    };
    GetWithdrawalResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      withdrawal: components["schemas"]["GetWithdrawalPayload"];
    };
    GetWithdrawalsResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      withdrawals: components["schemas"]["GetWithdrawalPayload"][];
    };
    GlobalRoleUsersListResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      users: components["schemas"]["UserWithGlobalRolesPayload"][];
    };
    GoalProgressPayloadV1: {
      /** @enum {string} */
      goal: "NoPoverty" | "ZeroHunger" | "GoodHealth" | "QualityEducation" | "GenderEquality" | "CleanWater" | "AffordableEnergy" | "DecentWork" | "Industry" | "ReducedInequalities" | "SustainableCities" | "ResponsibleConsumption" | "ClimateAction" | "LifeBelowWater" | "LifeOnLand" | "Peace" | "Partnerships";
      progress?: string;
    };
    ImageVariablePayload: {
      type: "Image";
    } & Omit<components["schemas"]["VariablePayload"], "type">;
    InternalTagPayload: {
      /** Format: int64 */
      id: number;
      /** @description If true, this internal tag is system-defined and may affect the behavior of the application. If falso, the tag is admin-defined and is only used for reporting. */
      isSystem: boolean;
      name: string;
    };
    LineString: WithRequired<{
      type: "LineString";
    } & Omit<components["schemas"]["Geometry"], "type"> & {
      coordinates?: number[][];
      /** @enum {string} */
      type?: "LineString";
    }, "coordinates" | "type">;
    LinkVariablePayload: {
      type: "Link";
    } & Omit<components["schemas"]["VariablePayload"], "type">;
    ListAcceleratorOrganizationsResponsePayload: {
      organizations: components["schemas"]["AcceleratorOrganizationPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListAllInternalTagsResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      tags: components["schemas"]["InternalTagPayload"][];
    };
    ListAllOrganizationInternalTagsResponsePayload: {
      organizations: components["schemas"]["OrganizationInternalTagsPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListApplicationsResponsePayload: {
      applications: components["schemas"]["ApplicationPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListAssignedPlotsResponsePayload: {
      plots: components["schemas"]["AssignedPlotPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListAutomationsResponsePayload: {
      automations: components["schemas"]["AutomationPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListBatchPhotosResponsePayload: {
      photos: components["schemas"]["BatchPhotoPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListDeliverablesElement: {
      /** @enum {string} */
      category: "Compliance" | "Financial Viability" | "GIS" | "Carbon Eligibility" | "Stakeholders and Community Impact" | "Proposed Restoration Activities" | "Verra Non-Permanence Risk Tool (NPRT)" | "Supplemental Files";
      /** @description Optional description of the deliverable in HTML form. */
      descriptionHtml?: string;
      /** Format: date */
      dueDate?: string;
      /** Format: int64 */
      id: number;
      /** Format: int64 */
      moduleId: number;
      moduleName: string;
      moduleTitle?: string;
      name: string;
      /**
       * Format: int32
       * @description Number of documents submitted for this deliverable. Only valid for deliverables of type Document.
       */
      numDocuments?: number;
      /** Format: int64 */
      organizationId: number;
      organizationName: string;
      /** Format: int64 */
      participantId?: number;
      participantName?: string;
      /** Format: int64 */
      projectId: number;
      projectName: string;
      /** @enum {string} */
      status: "Not Submitted" | "In Review" | "Needs Translation" | "Approved" | "Rejected" | "Not Needed" | "Completed";
      /** @enum {string} */
      type: "Document" | "Species" | "Questions";
    };
    ListDeliverablesResponsePayload: {
      deliverables: components["schemas"]["ListDeliverablesElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListDeviceConfigsResponse: {
      devices: components["schemas"]["DeviceConfig"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListDocumentTemplatesResponsePayload: {
      documentTemplates: components["schemas"]["DocumentTemplatePayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListDocumentsResponsePayload: {
      documents: components["schemas"]["DocumentPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListFacilitiesResponse: {
      facilities: components["schemas"]["FacilityPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListFieldValuesRequestPayload: {
      /** Format: int64 */
      facilityId?: number;
      fields: string[];
      /** Format: int64 */
      organizationId?: number;
      search?: components["schemas"]["AndNodePayload"] | components["schemas"]["FieldNodePayload"] | components["schemas"]["NotNodePayload"] | components["schemas"]["OrNodePayload"];
    };
    ListFieldValuesResponsePayload: {
      results: {
        [key: string]: components["schemas"]["FieldValuesPayload"];
      };
      status: components["schemas"]["SuccessOrError"];
    };
    ListObservationResultsResponsePayload: {
      observations: components["schemas"]["ObservationResultsPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListObservationsResponsePayload: {
      observations: components["schemas"]["ObservationPayload"][];
      status: components["schemas"]["SuccessOrError"];
      /**
       * Format: int32
       * @description Total number of monitoring plots that haven't been completed yet across all current observations.
       */
      totalIncompletePlots: number;
      /**
       * Format: int32
       * @description Total number of monitoring plots that haven't been claimed yet across all current observations.
       */
      totalUnclaimedPlots: number;
    };
    ListOrganizationInternalTagsResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      tagIds: number[];
    };
    ListOrganizationRolesResponsePayload: {
      roles: components["schemas"]["OrganizationRolePayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListOrganizationUsersResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      users: components["schemas"]["OrganizationUserPayload"][];
    };
    ListOrganizationsResponsePayload: {
      organizations: components["schemas"]["OrganizationPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListPhotosResponseElement: {
      filename: string;
      /** Format: int64 */
      size: number;
    };
    ListPhotosResponsePayload: {
      photos: components["schemas"]["ListPhotosResponseElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListPlantingSitesResponsePayload: {
      sites: components["schemas"]["PlantingSitePayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListPlantingSubzoneSpeciesResponsePayload: {
      species: components["schemas"]["PlantingSubzoneSpeciesPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListProjectsResponsePayload: {
      projects: components["schemas"]["ProjectPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListReportFilesResponseElement: {
      filename: string;
      /** Format: int64 */
      id: number;
    };
    ListReportFilesResponsePayload: {
      files: components["schemas"]["ListReportFilesResponseElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListReportPhotosResponseElement: {
      caption?: string;
      filename: string;
      /** Format: int64 */
      id: number;
    };
    ListReportPhotosResponsePayload: {
      photos: components["schemas"]["ListReportPhotosResponseElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListReportsResponseElement: {
      /** Format: int64 */
      id: number;
      lockedByName?: string;
      /** Format: int64 */
      lockedByUserId?: number;
      /** Format: date-time */
      lockedTime?: string;
      modifiedByName?: string;
      /** Format: int64 */
      modifiedByUserId?: number;
      /** Format: date-time */
      modifiedTime?: string;
      /** Format: int64 */
      projectId?: number;
      projectName?: string;
      /** Format: int32 */
      quarter: number;
      /** @enum {string} */
      status: "New" | "In Progress" | "Locked" | "Submitted";
      submittedByName?: string;
      /** Format: int64 */
      submittedByUserId?: number;
      /** Format: date-time */
      submittedTime?: string;
      /** Format: int32 */
      year: number;
    };
    ListReportsResponsePayload: {
      reports: components["schemas"]["ListReportsResponseElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListSpeciesResponsePayload: {
      species: components["schemas"]["SpeciesResponseElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListSubLocationsResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      subLocations: components["schemas"]["SubLocationPayload"][];
    };
    ListSupportRequestTypesResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      types: ("Bug Report" | "Feature Request" | "Contact Us")[];
    };
    ListTimeZoneNamesResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      timeZones: components["schemas"]["TimeZonePayload"][];
    };
    ListTimeseriesResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      timeseries: components["schemas"]["TimeseriesPayload"][];
    };
    ListVariableOwnersResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      variables: components["schemas"]["VariableOwnersResponseElement"][];
    };
    ListVariableValuesResponsePayload: {
      /**
       * Format: int64
       * @description The next unused value ID. You can pass this back to the endpoint as the minValueId parameter to poll for newly-updated values.
       */
      nextValueId: number;
      status: components["schemas"]["SuccessOrError"];
      /** @description Variable values organized by variable ID and table row. If you are getting incremental values (that is, you passed minValueId to the endpoint) this list may include values of type "Deleted" to indicate that existing values were deleted and not replaced with new values. */
      values: components["schemas"]["ExistingVariableValuesPayload"][];
    };
    ListVariablesResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      variables: (components["schemas"]["DateVariablePayload"] | components["schemas"]["ImageVariablePayload"] | components["schemas"]["LinkVariablePayload"] | components["schemas"]["NumberVariablePayload"] | components["schemas"]["SectionVariablePayload"] | components["schemas"]["SelectVariablePayload"] | components["schemas"]["TableVariablePayload"] | components["schemas"]["TextVariablePayload"])[];
    };
    ListViabilityTestsResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      viabilityTests: components["schemas"]["GetViabilityTestPayload"][];
    };
    ListWithdrawalPhotosResponsePayload: {
      photos: components["schemas"]["NurseryWithdrawalPhotoPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    MultiLineString: WithRequired<{
      type: "MultiLineString";
    } & Omit<components["schemas"]["Geometry"], "type"> & {
      coordinates?: number[][][];
      /** @enum {string} */
      type?: "MultiLineString";
    }, "coordinates" | "type">;
    MultiPoint: WithRequired<{
      type: "MultiPoint";
    } & Omit<components["schemas"]["Geometry"], "type"> & {
      coordinates?: number[][];
      /** @enum {string} */
      type?: "MultiPoint";
    }, "coordinates" | "type">;
    MultiPolygon: WithRequired<{
      type: "MultiPolygon";
    } & Omit<components["schemas"]["Geometry"], "type"> & {
      coordinates?: number[][][][];
      /** @enum {string} */
      type?: "MultiPolygon";
    }, "coordinates" | "type">;
    NewDateValuePayload: WithRequired<{
      type: "Date";
    } & Omit<components["schemas"]["NewValuePayload"], "type"> & {
      citation?: string;
      /** Format: date */
      dateValue?: string;
    }, "dateValue">;
    /** @description Updated metadata about an image value. May only be used in Update operations, and cannot be used to replace the actual image data. */
    NewImageValuePayload: {
      type: "Image";
    } & Omit<components["schemas"]["NewValuePayload"], "type"> & {
      caption?: string;
      citation?: string;
    };
    NewLinkValuePayload: WithRequired<{
      type: "Link";
    } & Omit<components["schemas"]["NewValuePayload"], "type"> & {
      citation?: string;
      title?: string;
      /** Format: uri */
      url?: string;
    }, "url">;
    NewNumberValuePayload: WithRequired<{
      type: "Number";
    } & Omit<components["schemas"]["NewValuePayload"], "type"> & {
      citation?: string;
      numberValue?: number;
    }, "numberValue">;
    NewPlantingSeasonPayload: {
      /** Format: date */
      endDate: string;
      /** Format: date */
      startDate: string;
    };
    NewPlantingSubzonePayload: {
      boundary: components["schemas"]["MultiPolygon"] | components["schemas"]["Polygon"];
      /** @description Name of this planting subzone. Two subzones in the same planting zone may not have the same name, but using the same subzone name in different planting zones is valid. */
      name: string;
    };
    /** @description List of planting zones to create. If present and not empty, "boundary" must also be specified. */
    NewPlantingZonePayload: {
      boundary: components["schemas"]["MultiPolygon"] | components["schemas"]["Polygon"];
      /** @description Name of this planting zone. Two zones in the same planting site may not have the same name. */
      name: string;
      plantingSubzones?: components["schemas"]["NewPlantingSubzonePayload"][];
      targetPlantingDensity?: number;
    };
    NewSectionTextValuePayload: WithRequired<{
      type: "SectionText";
    } & Omit<components["schemas"]["NewValuePayload"], "type"> & {
      /** @description Citation for this chunk of text. If you want text with multiple citations at different positions, you can split it into multiple text values and put a citation on each of them. */
      citation?: string;
      textValue?: string;
    }, "textValue">;
    NewSectionVariableValuePayload: WithRequired<{
      type: "SectionVariable";
    } & Omit<components["schemas"]["NewValuePayload"], "type"> & ({
      /** @enum {string} */
      displayStyle?: "Inline" | "Block";
      /** @enum {string} */
      usageType?: "Injection" | "Reference";
      /** Format: int64 */
      variableId?: number;
    }), "usageType" | "variableId">;
    NewSelectValuePayload: WithRequired<{
      type: "Select";
    } & Omit<components["schemas"]["NewValuePayload"], "type"> & {
      citation?: string;
      optionIds?: number[];
    }, "optionIds">;
    NewTableValuePayload: {
      type: "Table";
    } & Omit<components["schemas"]["NewValuePayload"], "type"> & {
      /** @description Citations on table values can be used if you want a citation that is associated with the table as a whole rather than with individual cells, or if you want a citation on an empty table: append a row with no column values but with a citation. */
      citation?: string;
    };
    NewTextValuePayload: WithRequired<{
      type: "Text";
    } & Omit<components["schemas"]["NewValuePayload"], "type"> & {
      citation?: string;
      textValue?: string;
    }, "textValue">;
    /** @description Supertype for payloads that represent new variable values. See the descriptions of individual payload types for more details. */
    NewValuePayload: {
      type: string;
    };
    /** @description Search criterion that matches results that do not match a set of search criteria. */
    NotNodePayload: WithRequired<{
      operation: "not";
    } & Omit<components["schemas"]["SearchNodePayload"], "operation"> & {
      child?: components["schemas"]["SearchNodePayload"];
    }, "child">;
    NotificationCountPayload: {
      /** Format: int64 */
      organizationId?: number;
      /** Format: int32 */
      unread: number;
    };
    NotificationPayload: {
      body: string;
      /** Format: date-time */
      createdTime: string;
      /** Format: int64 */
      id: number;
      isRead: boolean;
      /** Format: uri */
      localUrl: string;
      /** @enum {string} */
      notificationCriticality: "Info" | "Warning" | "Error" | "Success";
      /** Format: int64 */
      organizationId?: number;
      title: string;
    };
    NumberVariablePayload: WithRequired<{
      type: "Number";
    } & Omit<components["schemas"]["VariablePayload"], "type"> & {
      /** Format: int32 */
      decimalPlaces?: number;
      maxValue?: number;
      minValue?: number;
    }, "decimalPlaces">;
    NurserySummaryPayload: {
      /** Format: int64 */
      germinatingQuantity: number;
      /** Format: int32 */
      germinationRate?: number;
      /**
       * Format: int32
       * @description Percentage of current and past inventory that was withdrawn due to death.
       */
      lossRate?: number;
      /** Format: int64 */
      notReadyQuantity: number;
      /** Format: int64 */
      readyQuantity: number;
      /** @description Species currently present in the nursery. */
      species: components["schemas"]["NurserySummarySpeciesPayload"][];
      /**
       * Format: int64
       * @description Total number of plants that have been withdrawn due to death.
       */
      totalDead: number;
      /**
       * Format: int64
       * @description Total number of germinated plants currently in inventory.
       */
      totalQuantity: number;
      /**
       * Format: int64
       * @description Total number of plants that have been withdrawn in the past.
       */
      totalWithdrawn: number;
    };
    NurserySummarySpeciesPayload: {
      /** Format: int64 */
      id: number;
      scientificName: string;
    };
    NurseryWithdrawalPayload: {
      batchWithdrawals: components["schemas"]["BatchWithdrawalPayload"][];
      /**
       * Format: int64
       * @description If purpose is "Nursery Transfer", the ID of the facility to which the seedlings were transferred.
       */
      destinationFacilityId?: number;
      /** Format: int64 */
      facilityId: number;
      /** Format: int64 */
      id: number;
      notes?: string;
      /** @enum {string} */
      purpose: "Nursery Transfer" | "Dead" | "Out Plant" | "Other" | "Undo";
      /**
       * Format: int64
       * @description If purpose is "Undo", the ID of the withdrawal this one undoes.
       */
      undoesWithdrawalId?: number;
      /**
       * Format: int64
       * @description If this withdrawal was undone, the ID of the withdrawal that undid it.
       */
      undoneByWithdrawalId?: number;
      /** Format: date */
      withdrawnDate: string;
    };
    NurseryWithdrawalPhotoPayload: {
      /** Format: int64 */
      id: number;
    };
    ObservationMonitoringPlotCoordinatesPayload: {
      gpsCoordinates: components["schemas"]["Point"];
      /** @enum {string} */
      position: "SouthwestCorner" | "SoutheastCorner" | "NortheastCorner" | "NorthwestCorner";
    };
    ObservationMonitoringPlotPhotoPayload: {
      /** Format: int64 */
      fileId: number;
      gpsCoordinates: components["schemas"]["Point"];
      /** @enum {string} */
      position: "SouthwestCorner" | "SoutheastCorner" | "NortheastCorner" | "NorthwestCorner";
    };
    ObservationMonitoringPlotResultsPayload: {
      boundary: components["schemas"]["Polygon"];
      claimedByName?: string;
      /** Format: int64 */
      claimedByUserId?: number;
      /** Format: date-time */
      completedTime?: string;
      /** @description Observed coordinates, if any, up to one per position. */
      coordinates: components["schemas"]["ObservationMonitoringPlotCoordinatesPayload"][];
      /** @description True if this was a permanent monitoring plot in this observation. Clients should not assume that the set of permanent monitoring plots is the same in all observations; the number of permanent monitoring plots can be adjusted over time based on observation results. */
      isPermanent: boolean;
      /** Format: int64 */
      monitoringPlotId: number;
      /** @description Full name of this monitoring plot, including zone and subzone prefixes. */
      monitoringPlotName: string;
      /**
       * Format: int32
       * @description If this is a permanent monitoring plot in this observation, percentage of plants of all species that were dead.
       */
      mortalityRate?: number;
      notes?: string;
      photos: components["schemas"]["ObservationMonitoringPlotPhotoPayload"][];
      /**
       * Format: int32
       * @description Number of live plants per hectare.
       */
      plantingDensity: number;
      species: components["schemas"]["ObservationSpeciesResultsPayload"][];
      /** @enum {string} */
      status: "Outstanding" | "InProgress" | "Completed";
      /**
       * Format: int32
       * @description Total number of plants recorded. Includes all plants, regardless of live/dead status or species.
       */
      totalPlants: number;
      /**
       * Format: int32
       * @description Total number of species observed, not counting dead plants. Includes plants with Known and Other certainties. In the case of Other, each distinct user-supplied species name is counted as a separate species for purposes of this total.
       */
      totalSpecies: number;
    };
    ObservationPayload: {
      /**
       * Format: date
       * @description Date this observation is scheduled to end.
       */
      endDate: string;
      /** Format: int64 */
      id: number;
      /**
       * Format: int32
       * @description Total number of monitoring plots that haven't been completed yet. Includes both claimed and unclaimed plots.
       */
      numIncompletePlots: number;
      /**
       * Format: int32
       * @description Total number of monitoring plots in observation, regardless of status.
       */
      numPlots: number;
      /**
       * Format: int32
       * @description Total number of monitoring plots that haven't been claimed yet.
       */
      numUnclaimedPlots: number;
      /** Format: int64 */
      plantingSiteId: number;
      plantingSiteName: string;
      /** @description If specific subzones were requested for this observation, their IDs. */
      requestedSubzoneIds?: number[];
      /**
       * Format: date
       * @description Date this observation started.
       */
      startDate: string;
      /** @enum {string} */
      state: "Upcoming" | "InProgress" | "Completed" | "Overdue";
    };
    ObservationPlantingSubzoneResultsPayload: {
      monitoringPlots: components["schemas"]["ObservationMonitoringPlotResultsPayload"][];
      /** Format: int64 */
      plantingSubzoneId: number;
    };
    ObservationPlantingZoneResultsPayload: {
      /** @description Area of this planting zone in hectares. */
      areaHa: number;
      /** Format: date-time */
      completedTime?: string;
      /**
       * Format: int32
       * @description Estimated number of plants in planting zone based on estimated planting density and planting zone area. Only present if all the subzones in the zone have been marked as having completed planting.
       */
      estimatedPlants?: number;
      /**
       * Format: int32
       * @description Percentage of plants of all species that were dead in this zone's permanent monitoring plots.
       */
      mortalityRate: number;
      /**
       * Format: int32
       * @description Estimated planting density for the zone based on the observed planting densities of monitoring plots. Only present if all the subzones in the zone have been marked as having completed planting.
       */
      plantingDensity?: number;
      plantingSubzones: components["schemas"]["ObservationPlantingSubzoneResultsPayload"][];
      /** Format: int64 */
      plantingZoneId: number;
      species: components["schemas"]["ObservationSpeciesResultsPayload"][];
      /**
       * Format: int32
       * @description Total number of plants recorded. Includes all plants, regardless of live/dead status or species.
       */
      totalPlants: number;
      /**
       * Format: int32
       * @description Total number of species observed, not counting dead plants. Includes plants with Known and Other certainties. In the case of Other, each distinct user-supplied species name is counted as a separate species for purposes of this total.
       */
      totalSpecies: number;
    };
    ObservationResultsPayload: {
      /** Format: date-time */
      completedTime?: string;
      /**
       * Format: int32
       * @description Estimated total number of live plants at the site, based on the estimated planting density and site size. Only present if all the subzones in the site have been marked as having completed planting.
       */
      estimatedPlants?: number;
      /**
       * Format: int32
       * @description Percentage of plants of all species that were dead in this site's permanent monitoring plots.
       */
      mortalityRate: number;
      /** Format: int64 */
      observationId: number;
      /**
       * Format: int32
       * @description Estimated planting density for the site, based on the observed planting densities of monitoring plots. Only present if all the subzones in the site have been marked as having completed planting.
       */
      plantingDensity?: number;
      /** Format: int64 */
      plantingSiteId: number;
      plantingZones: components["schemas"]["ObservationPlantingZoneResultsPayload"][];
      species: components["schemas"]["ObservationSpeciesResultsPayload"][];
      /** Format: date */
      startDate: string;
      /** @enum {string} */
      state: "Upcoming" | "InProgress" | "Completed" | "Overdue";
      /** Format: int32 */
      totalSpecies: number;
    };
    ObservationSpeciesResultsPayload: {
      /** @enum {string} */
      certainty: "Known" | "Other" | "Unknown";
      /**
       * Format: int32
       * @description Number of dead plants observed in permanent monitoring plots in all observations including this one. 0 if this is a plot-level result for a temporary monitoring plot.
       */
      cumulativeDead: number;
      /**
       * Format: int32
       * @description Percentage of plants in permanent monitoring plots that are dead. If there are no permanent monitoring plots (or if this is a plot-level result for a temporary monitoring plot) this will be null.
       */
      mortalityRate?: number;
      /**
       * Format: int32
       * @description Number of live plants observed in permanent plots in this observation, not including existing plants. 0 if ths is a plot-level result for a temporary monitoring plot.
       */
      permanentLive: number;
      /**
       * Format: int64
       * @description If certainty is Known, the ID of the species. Null if certainty is Other or Unknown.
       */
      speciesId?: number;
      /** @description If certainty is Other, the user-supplied name of the species. Null if certainty is Known or Unknown. */
      speciesName?: string;
      /**
       * Format: int32
       * @description Total number of live and existing plants of this species.
       */
      totalPlants: number;
    };
    /** @description Search criterion that matches results that meet any of a set of other search criteria. That is, if the list of children is x, y, and z, this will require x OR y OR z. */
    OrNodePayload: WithRequired<{
      operation: "or";
    } & Omit<components["schemas"]["SearchNodePayload"], "operation"> & {
      /** @description List of criteria at least one of which must be satisfied */
      children?: components["schemas"]["SearchNodePayload"][];
    }, "children">;
    OrganizationInternalTagsPayload: {
      internalTagIds: number[];
      /** Format: int64 */
      organizationId: number;
      organizationName: string;
    };
    OrganizationPayload: {
      /** @description Whether this organization can submit reports to Terraformation. */
      canSubmitReports: boolean;
      /**
       * @description ISO 3166 alpha-2 code of organization's country.
       * @example AU
       */
      countryCode?: string;
      /**
       * @description ISO 3166-2 code of organization's country subdivision (state, province, region, etc.) This is the full ISO 3166-2 code including the country prefix. If this is set, countryCode will also be set.
       * @example US-HI
       */
      countrySubdivisionCode?: string;
      /** Format: date-time */
      createdTime: string;
      description?: string;
      /** @description This organization's facilities. Only included if depth is "Facility". */
      facilities?: components["schemas"]["FacilityPayload"][];
      /** Format: int64 */
      id: number;
      name: string;
      /** @enum {string} */
      organizationType?: "Government" | "NGO" | "Arboreta" | "Academia" | "ForProfit" | "Other";
      organizationTypeDetails?: string;
      /**
       * @description The current user's role in the organization. Absent if the current user is not a member of the organization but is able to read it thanks to a global role.
       * @enum {string}
       */
      role?: "Contributor" | "Manager" | "Admin" | "Owner" | "Terraformation Contact";
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
      /**
       * Format: int32
       * @description The total number of users in the organization, including the current user.
       */
      totalUsers: number;
      website?: string;
    };
    OrganizationRolePayload: {
      /** @enum {string} */
      role: "Contributor" | "Manager" | "Admin" | "Owner" | "Terraformation Contact";
      /**
       * Format: int32
       * @description Total number of users in the organization with this role.
       */
      totalUsers: number;
    };
    OrganizationUserPayload: {
      /**
       * Format: date-time
       * @description Date and time the user was added to the organization.
       */
      addedTime: string;
      email: string;
      /** @description The user's first name. Not present if the user has been added to the organization but has not signed up for an account yet. */
      firstName?: string;
      /** Format: int64 */
      id: number;
      /** @description The user's last name. Not present if the user has been added to the organization but has not signed up for an account yet. */
      lastName?: string;
      /** @enum {string} */
      role: "Contributor" | "Manager" | "Admin" | "Owner" | "Terraformation Contact";
    };
    ParticipantPayload: {
      /** Format: int64 */
      cohortId?: number;
      cohortName?: string;
      /** @enum {string} */
      cohortPhase?: "Phase 0 - Due Diligence" | "Phase 1 - Feasibility Study" | "Phase 2 - Plan and Scale" | "Phase 3 - Implement and Monitor" | "Pre-Screen" | "Application";
      /** Format: int64 */
      id: number;
      name: string;
      projects: components["schemas"]["ParticipantProjectPayload"][];
    };
    ParticipantProjectForSpeciesPayload: {
      /**
       * Format: int64
       * @description This deliverable ID is associated to the active or most recent cohort module, if available.
       */
      deliverableId?: number;
      /** Format: int64 */
      participantProjectSpeciesId: number;
      /** @enum {string} */
      participantProjectSpeciesNativeCategory?: "Native" | "Non-native";
      /** @enum {string} */
      participantProjectSpeciesSubmissionStatus: "Not Submitted" | "In Review" | "Needs Translation" | "Approved" | "Rejected" | "Not Needed" | "Completed";
      /** Format: int64 */
      projectId: number;
      projectName: string;
      /** Format: int64 */
      speciesId: number;
    };
    ParticipantProjectPayload: {
      /** Format: int64 */
      organizationId: number;
      organizationName: string;
      /** Format: int64 */
      projectId: number;
      projectName: string;
    };
    ParticipantProjectSpeciesPayload: {
      feedback?: string;
      /** Format: int64 */
      id: number;
      internalComment?: string;
      /** Format: int64 */
      projectId: number;
      rationale?: string;
      /** Format: int64 */
      speciesId: number;
      /** @enum {string} */
      speciesNativeCategory?: "Native" | "Non-native";
      /** @enum {string} */
      submissionStatus: "Not Submitted" | "In Review" | "Needs Translation" | "Approved" | "Rejected" | "Not Needed" | "Completed";
    };
    PhaseScores: {
      /** @enum {string} */
      phase: "Phase 0 - Due Diligence" | "Phase 1 - Feasibility Study" | "Phase 2 - Plan and Scale" | "Phase 3 - Implement and Monitor" | "Pre-Screen" | "Application";
      scores: components["schemas"]["Score"][];
      totalScore?: number;
    };
    PhaseVotes: {
      /** @enum {string} */
      decision?: "No" | "Conditional" | "Yes";
      /** @enum {string} */
      phase: "Phase 0 - Due Diligence" | "Phase 1 - Feasibility Study" | "Phase 2 - Plan and Scale" | "Phase 3 - Implement and Monitor" | "Pre-Screen" | "Application";
      votes: components["schemas"]["VoteSelection"][];
    };
    PlantingPayload: {
      /** Format: int64 */
      id: number;
      /** @description If type is "Reassignment To", the reassignment notes, if any. */
      notes?: string;
      /**
       * Format: int32
       * @description Number of plants planted or reassigned. If type is "Reassignment From", this will be negative.
       */
      numPlants: number;
      /** Format: int64 */
      plantingSubzoneId?: number;
      /** Format: int64 */
      speciesId: number;
      /** @enum {string} */
      type: "Delivery" | "Reassignment From" | "Reassignment To" | "Undo";
    };
    PlantingSeasonPayload: {
      /** Format: date */
      endDate: string;
      /** Format: int64 */
      id: number;
      /** Format: date */
      startDate: string;
    };
    PlantingSitePayload: {
      /** @description Area of planting site in hectares. Only present if the site has planting zones. */
      areaHa?: number;
      boundary?: components["schemas"]["MultiPolygon"];
      description?: string;
      exclusion?: components["schemas"]["MultiPolygon"];
      /** Format: int64 */
      id: number;
      name: string;
      /** Format: int64 */
      organizationId: number;
      plantingSeasons: components["schemas"]["PlantingSeasonPayload"][];
      plantingZones?: components["schemas"]["PlantingZonePayload"][];
      /** Format: int64 */
      projectId?: number;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    PlantingSiteReportedPlantsPayload: {
      /** Format: int64 */
      id: number;
      plantingZones: components["schemas"]["PlantingZoneReportedPlantsPayload"][];
      /** Format: int32 */
      plantsSinceLastObservation: number;
      /** Format: int32 */
      progressPercent?: number;
      /** Format: int32 */
      totalPlants: number;
    };
    PlantingSiteValidationProblemPayload: {
      /** @description If the problem is a conflict between two planting zones or two subzones, the list of the conflicting zone or subzone names. */
      conflictsWith?: string[];
      /** @description If the problem relates to a particular subzone, its name. If this is present, plantingZone will also be present and will be the name of the zone that contains this subzone. */
      plantingSubzone?: string;
      /** @description If the problem relates to a particular planting zone, its name. */
      plantingZone?: string;
      /** @enum {string} */
      problemType: "CannotRemovePlantedSubzone" | "CannotSplitSubzone" | "CannotSplitZone" | "DuplicateSubzoneName" | "DuplicateZoneName" | "ExclusionWithoutBoundary" | "SiteTooLarge" | "SubzoneBoundaryChanged" | "SubzoneBoundaryOverlaps" | "SubzoneInExclusionArea" | "SubzoneNotInZone" | "ZoneBoundaryChanged" | "ZoneBoundaryOverlaps" | "ZoneHasNoSubzones" | "ZoneNotInSite" | "ZoneTooSmall" | "ZonesWithoutSiteBoundary";
    };
    PlantingSubzonePayload: {
      /** @description Area of planting subzone in hectares. */
      areaHa: number;
      boundary: components["schemas"]["MultiPolygon"];
      fullName: string;
      /** Format: int64 */
      id: number;
      name: string;
      plantingCompleted: boolean;
      /**
       * Format: date-time
       * @description When planting of the planting subzone was marked as completed.
       */
      plantingCompletedTime?: string;
    };
    PlantingSubzoneReportedPlantsPayload: {
      /** Format: int64 */
      id: number;
      /** Format: int32 */
      totalPlants: number;
    };
    PlantingSubzoneSpeciesPayload: {
      commonName?: string;
      /** Format: int64 */
      id: number;
      scientificName: string;
    };
    PlantingZonePayload: {
      /** @description Area of planting zone in hectares. */
      areaHa: number;
      boundary: components["schemas"]["MultiPolygon"];
      /** Format: int64 */
      id: number;
      name: string;
      plantingSubzones: components["schemas"]["PlantingSubzonePayload"][];
      targetPlantingDensity: number;
    };
    PlantingZoneReportedPlantsPayload: {
      /** Format: int64 */
      id: number;
      plantingSubzones: components["schemas"]["PlantingSubzoneReportedPlantsPayload"][];
      /** Format: int32 */
      plantsSinceLastObservation: number;
      /** Format: int32 */
      progressPercent: number;
      /** Format: int32 */
      totalPlants: number;
    };
    Point: WithRequired<{
      type: "Point";
    } & Omit<components["schemas"]["Geometry"], "type"> & {
      /**
       * @description A single position consisting of X and Y values in the coordinate system specified by the crs field.
       * @example [
       *   120,
       *   -9.53
       * ]
       */
      coordinates?: number[];
      /** @enum {string} */
      type?: "Point";
    }, "coordinates" | "type">;
    Polygon: WithRequired<{
      type: "Polygon";
    } & Omit<components["schemas"]["Geometry"], "type"> & {
      coordinates?: number[][][];
      /** @enum {string} */
      type?: "Polygon";
    }, "coordinates" | "type">;
    ProjectAcceleratorDetailsPayload: {
      annualCarbon?: number;
      applicationReforestableLand?: number;
      carbonCapacity?: number;
      confirmedReforestableLand?: number;
      countryCode?: string;
      dealDescription?: string;
      /** @enum {string} */
      dealStage?: "Phase 0 (Doc Review)" | "Phase 1" | "Phase 2" | "Phase 3" | "Graduated, Finished Planting" | "Non Graduate" | "Application Submitted" | "Project Lead Screening Review" | "Screening Questions Ready for Review" | "Carbon Pre-Check" | "Submission Requires Follow Up" | "Carbon Eligible" | "Closed Lost" | "Issue Active" | "Issue Pending" | "Issue Reesolved";
      dropboxFolderPath?: string;
      failureRisk?: string;
      fileNaming?: string;
      /** Format: uri */
      googleFolderUrl?: string;
      /** Format: uri */
      hubSpotUrl?: string;
      investmentThesis?: string;
      landUseModelTypes: ("Native Forest" | "Monoculture" | "Sustainable Timber" | "Other Timber" | "Mangroves" | "Agroforestry" | "Silvopasture" | "Other Land-Use Model")[];
      maxCarbonAccumulation?: number;
      minCarbonAccumulation?: number;
      /** Format: int32 */
      numCommunities?: number;
      /** Format: int32 */
      numNativeSpecies?: number;
      perHectareBudget?: number;
      /** @enum {string} */
      pipeline?: "Accelerator Projects" | "Carbon Supply" | "Carbon Waitlist";
      /** Format: int64 */
      projectId: number;
      projectLead?: string;
      /** @enum {string} */
      region?: "Antarctica" | ("East Asia & Pacific") | ("Europe & Central Asia") | ("Latin America & Caribbean") | ("Middle East & North Africa") | "North America" | "Oceania" | "South Asia" | "Sub-Saharan Africa";
      totalCarbon?: number;
      totalExpansionPotential?: number;
      whatNeedsToBeTrue?: string;
    };
    ProjectModule: {
      additionalResources?: string;
      /** Format: date */
      endDate: string;
      events: components["schemas"]["ProjectModuleEvent"][];
      /** Format: int64 */
      id: number;
      isActive: boolean;
      name: string;
      overview?: string;
      preparationMaterials?: string;
      /** Format: date */
      startDate: string;
      title: string;
    };
    ProjectModuleEvent: {
      description: string;
      sessions: components["schemas"]["ProjectModuleEventSession"][];
    };
    ProjectModuleEventSession: {
      /** Format: date-time */
      endTime?: string;
      /** Format: int64 */
      id: number;
      /** Format: uri */
      meetingUrl?: string;
      /** Format: uri */
      recordingUrl?: string;
      /** Format: uri */
      slidesUrl?: string;
      /** Format: date-time */
      startTime?: string;
      /** @enum {string} */
      status: "Not Started" | "Starting Soon" | "In Progress" | "Ended";
      /** @enum {string} */
      type: "One-on-One Session" | "Workshop" | "Live Session" | "Recorded Session";
    };
    ProjectPayload: {
      /** Format: int64 */
      cohortId?: number;
      /** @enum {string} */
      cohortPhase?: "Phase 0 - Due Diligence" | "Phase 1 - Feasibility Study" | "Phase 2 - Plan and Scale" | "Phase 3 - Implement and Monitor" | "Pre-Screen" | "Application";
      /** Format: int64 */
      createdBy?: number;
      /** Format: date-time */
      createdTime?: string;
      description?: string;
      /** Format: int64 */
      id: number;
      /** Format: int64 */
      modifiedBy?: number;
      /** Format: date-time */
      modifiedTime?: string;
      name: string;
      /** Format: int64 */
      organizationId: number;
      /** Format: int64 */
      participantId?: number;
    };
    ProjectReportSettingsPayload: {
      /** @description If true, reports are enabled for this project. */
      isEnabled: boolean;
      /** Format: int64 */
      projectId: number;
    };
    ProjectVotesPayload: {
      phases: components["schemas"]["PhaseVotes"][];
    };
    PutNurseryV1: {
      /** Format: date */
      buildCompletedDate?: string;
      /** Format: date */
      buildStartedDate?: string;
      /** Format: int32 */
      capacity?: number;
      /** Format: int64 */
      id: number;
      notes?: string;
      /** Format: date */
      operationStartedDate?: string;
      selected: boolean;
      workers: components["schemas"]["WorkersPayloadV1"];
    };
    PutPlantingSiteSpeciesV1: {
      /** Format: int64 */
      id: number;
      /** Format: int32 */
      mortalityRateInField?: number;
      /** Format: int32 */
      totalPlanted?: number;
    };
    PutPlantingSiteV1: {
      /** Format: int64 */
      id: number;
      /** Format: int32 */
      mortalityRate?: number;
      notes?: string;
      selected: boolean;
      species: components["schemas"]["PutPlantingSiteSpeciesV1"][];
      /** Format: int32 */
      totalPlantedArea?: number;
      /** Format: int32 */
      totalPlantingSiteArea?: number;
      /** Format: int32 */
      totalPlantsPlanted?: number;
      /** Format: int32 */
      totalTreesPlanted?: number;
      workers: components["schemas"]["WorkersPayloadV1"];
    };
    PutReportPayload: {
      version: string;
    };
    PutReportPayloadV1: WithRequired<{
      version: "1";
    } & Omit<components["schemas"]["PutReportPayload"], "version"> & {
      annualDetails?: components["schemas"]["AnnualDetailsPayloadV1"];
      notes?: string;
      nurseries?: components["schemas"]["PutNurseryV1"][];
      plantingSites?: components["schemas"]["PutPlantingSiteV1"][];
      seedBanks?: components["schemas"]["PutSeedBankV1"][];
      summaryOfProgress?: string;
    }, "nurseries" | "plantingSites" | "seedBanks">;
    PutReportRequestPayload: {
      report: components["schemas"]["PutReportPayloadV1"];
    };
    PutSeedBankV1: {
      /** Format: date */
      buildCompletedDate?: string;
      /** Format: date */
      buildStartedDate?: string;
      /** Format: int64 */
      id: number;
      notes?: string;
      /** Format: date */
      operationStartedDate?: string;
      selected: boolean;
      workers: components["schemas"]["WorkersPayloadV1"];
    };
    ReassignDeliveryRequestPayload: {
      reassignments: components["schemas"]["ReassignmentPayload"][];
    };
    ReassignmentPayload: {
      /** Format: int64 */
      fromPlantingId: number;
      notes?: string;
      /**
       * Format: int32
       * @description Number of plants to reassign from the planting's original subzone to the new one. Must be less than or equal to the number of plants in the original planting.
       */
      numPlants: number;
      /** Format: int64 */
      toPlantingSubzoneId: number;
    };
    RecordTimeseriesValuesRequestPayload: {
      timeseries: components["schemas"]["TimeseriesValuesPayload"][];
    };
    /** @description Results of a request to record timeseries values. */
    RecordTimeseriesValuesResponsePayload: {
      error?: components["schemas"]["ErrorDetails"];
      /** @description List of values that the server failed to record. Will not be included if all the values were recorded successfully. */
      failures?: components["schemas"]["TimeseriesValuesErrorPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    RecordedPlantPayload: {
      /** @enum {string} */
      certainty: "Known" | "Other" | "Unknown";
      /** @description GPS coordinates where plant was observed. */
      gpsCoordinates: components["schemas"]["Point"];
      /**
       * Format: int64
       * @description Required if certainty is Known. Ignored if certainty is Other or Unknown.
       */
      speciesId?: number;
      /** @description If certainty is Other, the optional user-supplied name of the species. Ignored if certainty is Known or Unknown. */
      speciesName?: string;
      /** @enum {string} */
      status: "Live" | "Dead" | "Existing";
    };
    ReplaceObservationPlotRequestPayload: {
      /** @enum {string} */
      duration: "Temporary" | "LongTerm";
      justification: string;
    };
    ReplaceObservationPlotResponsePayload: {
      /** @description IDs of monitoring plots that were added to the observation. Empty if no plots were added. */
      addedMonitoringPlotIds: number[];
      /** @description IDs of monitoring plots that were removed from the observation. Will usually include the requested plot ID, but may be empty if the replacement request couldn't be satisfied. */
      removedMonitoringPlotIds: number[];
      status: components["schemas"]["SuccessOrError"];
    };
    /**
     * @description Operation that replaces all the values of a variable with new ones. This is an "upsert" operation: it replaces any existing values, or creates new values if there weren't already any.
     *
     * This operation may not be used with table variables.
     *
     * If the variable is a list and previously had more values than are included in this payload, the existing values with higher-numbered list positions are deleted.
     *
     * If the variable is not a list, it is invalid for this payload to include more than one value.
     */
    ReplaceValuesOperationPayload: WithRequired<{
      operation: "Replace";
    } & Omit<components["schemas"]["ValueOperationPayload"], "operation"> & {
      /**
       * Format: int64
       * @description If the variable is a table column, the value ID of the row whose values should be replaced.
       */
      rowValueId?: number;
      values?: components["schemas"]["NewValuePayload"][];
      /** Format: int64 */
      variableId?: number;
    }, "values" | "variableId">;
    RescheduleObservationRequestPayload: {
      /**
       * Format: date
       * @description The end date for this observation, should be limited to 2 months from the start date .
       */
      endDate: string;
      /**
       * Format: date
       * @description The start date for this observation, can be up to a year from the date this schedule request occurs on.
       */
      startDate: string;
    };
    ResolveUploadRequestPayload: {
      /** @description If true, the data for entries that already exist will be overwritten with the values in the uploaded file. If false, only entries that don't already exist will be imported. */
      overwriteExisting: boolean;
    };
    ReviewApplicationRequestPayload: {
      feedback?: string;
      internalComment?: string;
      /** @enum {string} */
      status: "Not Submitted" | "Failed Pre-screen" | "Passed Pre-screen" | "Submitted" | "PL Review" | "Ready for Review" | "Pre-check" | "Needs Follow-up" | "Carbon Eligible" | "Accepted" | "Issue Active" | "Issue Pending" | "Issue Resolved" | "Not Accepted";
    };
    ScheduleObservationRequestPayload: {
      /**
       * Format: date
       * @description The end date for this observation, should be limited to 2 months from the start date.
       */
      endDate: string;
      /**
       * Format: int64
       * @description Which planting site this observation needs to be scheduled for.
       */
      plantingSiteId: number;
      /** @description If this observation should only cover specific parts of the planting site, the IDs of the subzones it should include. */
      requestedSubzoneIds?: number[];
      /**
       * Format: date
       * @description The start date for this observation, can be up to a year from the date this schedule request occurs on.
       */
      startDate: string;
    };
    ScheduleObservationResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    Score: {
      /** @enum {string} */
      category: "Carbon" | "Finance" | "Forestry" | "Legal" | "Social Impact" | "GIS" | "Climate Impact" | "Expansion Potential" | "Experience and Understanding" | "Operational Capacity" | "Responsiveness and Attention to Detail" | "Values Alignment";
      /** Format: date-time */
      modifiedTime: string;
      qualitative?: string;
      /**
       * Format: int32
       * @description If `null`, a score has not been selected.
       */
      value?: number;
    };
    /** @description A search criterion. The search will return results that match this criterion. The criterion can be composed of other search criteria to form arbitrary Boolean search expressions. TYPESCRIPT-OVERRIDE-TYPE-WITH-ANY */
    SearchNodePayload: {operation: "and" | "field" | "not" | "or"; [key: string]: any;};
    SearchRequestPayload: {
      /**
       * Format: int32
       * @description Maximum number of top-level search results to return. The system may impose a limit on this value. A separate system-imposed limit may also be applied to lists of child objects inside the top-level results. Use a value of 0 to return the maximum number of allowed results.
       * @default 25
       */
      count?: number;
      /** @description Starting point for search results. If present, a previous search will be continued from where it left off. This should be the value of the cursor that was returned in the response to a previous search. */
      cursor?: string;
      /**
       * @description List of fields to return. Field names should be relative to the prefix. They may navigate the data hierarchy using '.' or '_' as delimiters.
       * @example [
       *   "processingStartDate",
       *   "viabilityTests.seedsTested",
       *   "facility_name"
       * ]
       */
      fields: string[];
      /**
       * @description Prefix for field names. This determines how field names are interpreted, and also how results are structured. Each element in the "results" array in the response will be an instance of whatever entity the prefix points to. Always evaluated starting from the "organizations" level. If not present, the search will return a list of organizations.
       * @example facilities.accessions
       */
      prefix?: string;
      search?: components["schemas"]["AndNodePayload"] | components["schemas"]["FieldNodePayload"] | components["schemas"]["NotNodePayload"] | components["schemas"]["OrNodePayload"];
      /** @description How to sort the search results. This controls both the order of the top-level results and the order of any lists of child objects. */
      sortOrder?: components["schemas"]["SearchSortOrderElement"][];
    };
    SearchResponsePayload: {
      cursor?: string;
      results: {
          [key: string]: unknown;
        }[];
    };
    SearchSortOrderElement: {
      /**
       * @default Ascending
       * @enum {string}
       */
      direction?: "Ascending" | "Descending";
      field: string;
    };
    SearchValuesResponsePayload: {
      results: {
        [key: string]: components["schemas"]["FieldValuesPayload"];
      };
    };
    SectionVariablePayload: WithRequired<{
      type: "Section";
    } & Omit<components["schemas"]["VariablePayload"], "type"> & {
      children?: components["schemas"]["SectionVariablePayload"][];
      /** @description IDs of variables that this section recommends. */
      recommends?: number[];
      renderHeading?: boolean;
    }, "children" | "recommends" | "renderHeading">;
    SeedCountSummaryPayload: {
      /**
       * Format: int64
       * @description Total number of seeds remaining in accessions whose quantities are measured in seeds.
       */
      subtotalBySeedCount: number;
      /**
       * Format: int64
       * @description Estimated total number of seeds remaining in accessions whose quantities are measured by weight. This estimate is based on the subset weight and count. Accessions measured by weight that don't have subset weights and counts are not included in this estimate.
       */
      subtotalByWeightEstimate: number;
      /**
       * Format: int64
       * @description Total number of seeds remaining. The sum of subtotalBySeedCount and subtotalByWeightEstimate.
       */
      total: number;
      /**
       * Format: int32
       * @description Number of accessions that are measured by weight and don't have subset weight and count data. The system cannot estimate how many seeds they have.
       */
      unknownQuantityAccessions: number;
    };
    /** @description Represents a quantity of seeds, measured either in individual seeds or by weight. */
    SeedQuantityPayload: {
      /** @description If this quantity is a weight measurement, the weight in grams. This is not set if the "units" field is "Seeds". This is always calculated on the server side and is ignored on input. */
      grams?: number;
      /** @description Number of units of seeds. If "units" is "Seeds", this is the number of seeds and must be an integer. Otherwise it is a measurement in the weight units specified in the "units" field, and may have a fractional part. */
      quantity: number;
      /** @enum {string} */
      units: "Seeds" | "Grams" | "Milligrams" | "Kilograms" | "Ounces" | "Pounds";
    };
    SelectOptionPayload: {
      description?: string;
      /** Format: int64 */
      id: number;
      name: string;
      renderedText?: string;
    };
    SelectVariablePayload: WithRequired<{
      type: "Select";
    } & Omit<components["schemas"]["VariablePayload"], "type"> & {
      isMultiple?: boolean;
      options?: components["schemas"]["SelectOptionPayload"][];
    }, "isMultiple" | "options">;
    SendFacilityAlertRequestPayload: {
      /** @description Alert body in plain text. HTML alerts are not supported yet. */
      body: string;
      subject: string;
    };
    SimpleErrorResponsePayload: {
      error: components["schemas"]["ErrorDetails"];
      status: components["schemas"]["SuccessOrError"];
    };
    SimpleSuccessResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
    };
    SpeciesForParticipantProjectPayload: {
      participantProjectSpecies: components["schemas"]["ParticipantProjectSpeciesPayload"];
      project: components["schemas"]["ProjectPayload"];
      species: components["schemas"]["SpeciesResponseElement"];
    };
    SpeciesLookupCommonNamePayload: {
      /** @description ISO 639-1 two-letter language code indicating the name's language. Some common names in the server's taxonomic database are not tagged with languages; this value will not be present for those names. */
      language?: string;
      name: string;
    };
    SpeciesLookupDetailsResponsePayload: {
      /** @description List of known common names for the species, if any. */
      commonNames?: components["schemas"]["SpeciesLookupCommonNamePayload"][];
      /**
       * @description IUCN Red List conservation category code.
       * @enum {string}
       */
      conservationCategory?: "CR" | "DD" | "EN" | "EW" | "EX" | "LC" | "NE" | "NT" | "VU";
      familyName: string;
      /**
       * @description If this is not the accepted name for the species, the type of problem the name has. Currently, this will always be "Name Is Synonym".
       * @enum {string}
       */
      problemType?: "Name Misspelled" | "Name Not Found" | "Name Is Synonym";
      scientificName: string;
      /** @description If this is not the accepted name for the species, the name to suggest as an alternative. */
      suggestedScientificName?: string;
    };
    SpeciesLookupNamesResponsePayload: {
      names: string[];
      /** @description True if there were more matching names than could be included in the response. */
      partial: boolean;
      status: components["schemas"]["SuccessOrError"];
    };
    SpeciesProblemElement: {
      /** @enum {string} */
      field: "Scientific Name";
      /** Format: int64 */
      id: number;
      /** @description Value for the field in question that would correct the problem. Absent if the system is unable to calculate a corrected value. */
      suggestedValue?: string;
      /** @enum {string} */
      type: "Name Misspelled" | "Name Not Found" | "Name Is Synonym";
    };
    SpeciesRequestPayload: {
      averageWoodDensity?: number;
      commonName?: string;
      /**
       * @description IUCN Red List conservation category code.
       * @enum {string}
       */
      conservationCategory?: "CR" | "DD" | "EN" | "EW" | "EX" | "LC" | "NE" | "NT" | "VU";
      dbhSource?: string;
      dbhValue?: number;
      ecologicalRoleKnown?: string;
      ecosystemTypes?: ("Boreal forests/Taiga" | "Deserts and xeric shrublands" | "Flooded grasslands and savannas" | "Mangroves" | "Mediterranean forests, woodlands and scrubs" | "Montane grasslands and shrublands" | "Temperate broad leaf and mixed forests" | "Temperate coniferous forest" | "Temperate grasslands, savannas and shrublands" | "Tropical and subtropical coniferous forests" | "Tropical and subtropical dry broad leaf forests" | "Tropical and subtropical grasslands, savannas and shrublands" | "Tropical and subtropical moist broad leaf forests" | "Tundra")[];
      familyName?: string;
      growthForms?: ("Tree" | "Shrub" | "Forb" | "Graminoid" | "Fern" | "Fungus" | "Lichen" | "Moss" | "Vine" | "Liana" | "Shrub/Tree" | "Subshrub" | "Multiple Forms" | "Mangrove" | "Herb")[];
      heightAtMaturitySource?: string;
      heightAtMaturityValue?: number;
      localUsesKnown?: string;
      nativeEcosystem?: string;
      /**
       * Format: int64
       * @description Which organization's species list to update.
       */
      organizationId: number;
      otherFacts?: string;
      plantMaterialSourcingMethods?: (("Seed collection & germination") | ("Seed purchase & germination") | "Mangrove propagules" | "Vegetative propagation" | "Wildling harvest" | "Seedling purchase" | "Other")[];
      rare?: boolean;
      scientificName: string;
      /** @enum {string} */
      seedStorageBehavior?: "Orthodox" | "Recalcitrant" | "Intermediate" | "Unknown" | "Likely Orthodox" | "Likely Recalcitrant" | "Likely Intermediate" | "Intermediate - Cool Temperature Sensitive" | "Intermediate - Partial Desiccation Tolerant" | "Intermediate - Short Lived";
      successionalGroups?: ("Pioneer" | "Early secondary" | "Late secondary" | "Mature")[];
      /** @enum {string} */
      woodDensityLevel?: "Species" | "Genus" | "Family";
    };
    SpeciesResponseElement: {
      averageWoodDensity?: number;
      commonName?: string;
      /**
       * @description IUCN Red List conservation category code.
       * @enum {string}
       */
      conservationCategory?: "CR" | "DD" | "EN" | "EW" | "EX" | "LC" | "NE" | "NT" | "VU";
      dbhSource?: string;
      dbhValue?: number;
      ecologicalRoleKnown?: string;
      ecosystemTypes?: ("Boreal forests/Taiga" | "Deserts and xeric shrublands" | "Flooded grasslands and savannas" | "Mangroves" | "Mediterranean forests, woodlands and scrubs" | "Montane grasslands and shrublands" | "Temperate broad leaf and mixed forests" | "Temperate coniferous forest" | "Temperate grasslands, savannas and shrublands" | "Tropical and subtropical coniferous forests" | "Tropical and subtropical dry broad leaf forests" | "Tropical and subtropical grasslands, savannas and shrublands" | "Tropical and subtropical moist broad leaf forests" | "Tundra")[];
      familyName?: string;
      growthForms?: ("Tree" | "Shrub" | "Forb" | "Graminoid" | "Fern" | "Fungus" | "Lichen" | "Moss" | "Vine" | "Liana" | "Shrub/Tree" | "Subshrub" | "Multiple Forms" | "Mangrove" | "Herb")[];
      heightAtMaturitySource?: string;
      heightAtMaturityValue?: number;
      /** Format: int64 */
      id: number;
      localUsesKnown?: string;
      nativeEcosystem?: string;
      otherFacts?: string;
      plantMaterialSourcingMethods?: (("Seed collection & germination") | ("Seed purchase & germination") | "Mangrove propagules" | "Vegetative propagation" | "Wildling harvest" | "Seedling purchase" | "Other")[];
      problems?: components["schemas"]["SpeciesProblemElement"][];
      rare?: boolean;
      scientificName: string;
      /** @enum {string} */
      seedStorageBehavior?: "Orthodox" | "Recalcitrant" | "Intermediate" | "Unknown" | "Likely Orthodox" | "Likely Recalcitrant" | "Likely Intermediate" | "Intermediate - Cool Temperature Sensitive" | "Intermediate - Partial Desiccation Tolerant" | "Intermediate - Short Lived";
      successionalGroups?: ("Pioneer" | "Early secondary" | "Late secondary" | "Mature")[];
      /** @enum {string} */
      woodDensityLevel?: "Species" | "Genus" | "Family";
    };
    SpeciesSummaryNurseryPayload: {
      /** Format: int64 */
      facilityId: number;
      name: string;
    };
    SpeciesSummaryPayload: {
      /** Format: int64 */
      germinatingQuantity: number;
      /** Format: int32 */
      germinationRate?: number;
      /**
       * Format: int32
       * @description Percentage of current and past inventory that was withdrawn due to death.
       */
      lossRate?: number;
      /** Format: int64 */
      notReadyQuantity: number;
      nurseries: components["schemas"]["SpeciesSummaryNurseryPayload"][];
      /** Format: int64 */
      readyQuantity: number;
      /** Format: int64 */
      speciesId: number;
      /**
       * Format: int64
       * @description Total number of germinated plants that have been withdrawn due to death.
       */
      totalDead: number;
      /**
       * Format: int64
       * @description Total number of germinated plants currently in inventory.
       */
      totalQuantity: number;
      /**
       * Format: int64
       * @description Total number of germinated plants that have been withdrawn in the past.
       */
      totalWithdrawn: number;
    };
    SubLocationPayload: {
      /**
       * Format: int32
       * @description If this sub-location is at a seed bank, the number of active accessions stored there.
       */
      activeAccessions?: number;
      /**
       * Format: int32
       * @description If this sub-location is at a nursery, the number of batches stored there that have seedlings.
       */
      activeBatches?: number;
      /** Format: int64 */
      facilityId: number;
      /** Format: int64 */
      id: number;
      name: string;
    };
    SubmissionDocumentPayload: {
      /** Format: date-time */
      createdTime: string;
      description?: string;
      /** @enum {string} */
      documentStore: "Dropbox" | "Google";
      /** Format: int64 */
      id: number;
      name: string;
      originalName?: string;
    };
    SubmitApplicationResponsePayload: {
      application: components["schemas"]["ApplicationPayload"];
      /** @description If the application failed any of the pre-screening checks, a list of the reasons why. Empty if the application passed pre-screening. */
      problems: string[];
      status: components["schemas"]["SuccessOrError"];
    };
    SubmitSupportRequestPayload: {
      attachmentComment?: string;
      attachmentIds?: string[];
      description: string;
      /** @enum {string} */
      requestType: "Bug Report" | "Feature Request" | "Contact Us";
      summary: string;
    };
    SubmitSupportRequestResponsePayload: {
      issueKey: string;
      status: components["schemas"]["SuccessOrError"];
    };
    /**
     * @description Indicates of success or failure of the requested operation.
     * @enum {string}
     */
    SuccessOrError: "ok" | "error";
    SuccessResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
    };
    SummarizeAccessionSearchRequestPayload: {
      search?: components["schemas"]["AndNodePayload"] | components["schemas"]["FieldNodePayload"] | components["schemas"]["NotNodePayload"] | components["schemas"]["OrNodePayload"];
    };
    SummarizeAccessionSearchResponsePayload: {
      /** Format: int32 */
      accessions: number;
      seedsRemaining: components["schemas"]["SeedCountSummaryPayload"];
      /** Format: int32 */
      species: number;
      status: components["schemas"]["SuccessOrError"];
    };
    /** @description Summary of important statistics about the seed bank for the Summary page. */
    SummaryResponsePayload: {
      /** @description Number of accessions in each state. */
      accessionsByState: {
        [key: string]: number;
      };
      /** Format: int32 */
      activeAccessions: number;
      /** @description Summary of the number of seeds remaining across all active accessions. */
      seedsRemaining: components["schemas"]["SeedCountSummaryPayload"];
      /** Format: int32 */
      species: number;
      status: components["schemas"]["SuccessOrError"];
    };
    TableColumnPayload: {
      isHeader: boolean;
      variable: components["schemas"]["VariablePayload"];
    };
    TableVariablePayload: WithRequired<{
      type: "Table";
    } & Omit<components["schemas"]["VariablePayload"], "type"> & ({
      columns?: components["schemas"]["TableColumnPayload"][];
      /** @enum {string} */
      tableStyle?: "Horizontal" | "Vertical";
    }), "columns" | "tableStyle">;
    TemporaryAttachment: {
      filename: string;
      temporaryAttachmentId: string;
    };
    TextVariablePayload: WithRequired<{
      type: "Text";
    } & Omit<components["schemas"]["VariablePayload"], "type"> & ({
      /** @enum {string} */
      textType?: "SingleLine" | "MultiLine";
    }), "textType">;
    TimeZonePayload: {
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      id: string;
      /**
       * @description Long name of time zone, possibly including a city name. This name is guaranteed to be unique across all zones.
       * @example Central European Time - Berlin
       */
      longName: string;
    };
    TimeseriesPayload: {
      /**
       * Format: int32
       * @description Number of significant fractional digits (after the decimal point), if this is a timeseries with non-integer numeric values.
       */
      decimalPlaces?: number;
      /**
       * Format: int64
       * @description ID of device that produces this timeseries.
       */
      deviceId: number;
      /** @description If any values have been recorded for the timeseries, the latest one. */
      latestValue?: components["schemas"]["TimeseriesValuePayload"];
      timeseriesName: string;
      /** @enum {string} */
      type: "Numeric" | "Text";
      /**
       * @description Units of measure for values in this timeseries.
       * @example volts
       */
      units?: string;
    };
    TimeseriesValuePayload: {
      /** Format: date-time */
      timestamp: string;
      /** @description Value to record. If the timeseries is of type Numeric, this must be a decimal or integer value in string form. If the timeseries is of type Text, this can be an arbitrary string. */
      value: string;
    };
    TimeseriesValuesErrorPayload: {
      /**
       * Format: int64
       * @description Device ID as specified in the failing request.
       */
      deviceId: number;
      /** @description Human-readable details about the failure. */
      message: string;
      /** @description Name of timeseries as specified in the failing request. */
      timeseriesName: string;
      /** @description Values that the server was not able to successfully record. */
      values: components["schemas"]["TimeseriesValuePayload"][];
    };
    TimeseriesValuesPayload: {
      /**
       * Format: int64
       * @description ID of device that produced this value.
       */
      deviceId: number;
      /** @description Name of timeseries. This must be the name of a timeseries that has already been created for the device. */
      timeseriesName: string;
      values: components["schemas"]["TimeseriesValuePayload"][];
    };
    UpdateAccessionRequestPayloadV2: {
      bagNumbers?: string[];
      /** Format: date */
      collectedDate?: string;
      collectionSiteCity?: string;
      collectionSiteCoordinates?: components["schemas"]["Geolocation"][];
      collectionSiteCountryCode?: string;
      collectionSiteCountrySubdivision?: string;
      collectionSiteLandowner?: string;
      collectionSiteName?: string;
      collectionSiteNotes?: string;
      /** @enum {string} */
      collectionSource?: "Wild" | "Reintroduced" | "Cultivated" | "Other";
      collectors?: string[];
      /** Format: date */
      dryingEndDate?: string;
      /** Format: int64 */
      facilityId?: number;
      notes?: string;
      plantId?: string;
      /**
       * Format: int32
       * @description Estimated number of plants the seeds were collected from.
       */
      plantsCollectedFrom?: number;
      /** Format: int64 */
      projectId?: number;
      /** Format: date */
      receivedDate?: string;
      /** @description Quantity of seeds remaining in the accession. If this is different than the existing value, it is considered a new observation, and the new value will override any previously-calculated remaining quantities. */
      remainingQuantity?: components["schemas"]["SeedQuantityPayload"];
      /** @description Notes associated with remaining quantity updates if any. */
      remainingQuantityNotes?: string;
      /** Format: int64 */
      speciesId?: number;
      /** @enum {string} */
      state?: "Awaiting Check-In" | "Awaiting Processing" | "Processing" | "Drying" | "In Storage" | "Used Up";
      subLocation?: string;
      /** Format: int32 */
      subsetCount?: number;
      /** @description Weight of subset of seeds. Units must be a weight measurement, not "Seeds". */
      subsetWeight?: components["schemas"]["SeedQuantityPayload"];
      /** Format: int32 */
      viabilityPercent?: number;
    };
    UpdateAccessionResponsePayloadV2: {
      accession: components["schemas"]["AccessionPayloadV2"];
      status: components["schemas"]["SuccessOrError"];
    };
    UpdateApplicationBoundaryRequestPayload: {
      boundary: components["schemas"]["MultiPolygon"] | components["schemas"]["Polygon"];
    };
    UpdateAutomationRequestPayload: {
      description?: string;
      /** Format: int64 */
      deviceId?: number;
      /** Format: double */
      lowerThreshold?: number;
      name: string;
      settings?: {
        [key: string]: unknown;
      };
      timeseriesName?: string;
      type: string;
      /** Format: double */
      upperThreshold?: number;
      /** Format: int32 */
      verbosity?: number;
    };
    UpdateBatchQuantitiesRequestPayload: {
      /** Format: int32 */
      germinatingQuantity: number;
      /** Format: int32 */
      notReadyQuantity: number;
      /** Format: int32 */
      readyQuantity: number;
      /** Format: int32 */
      version: number;
    };
    UpdateBatchRequestPayload: {
      notes?: string;
      /** Format: int64 */
      projectId?: number;
      /** Format: date */
      readyByDate?: string;
      subLocationIds?: number[];
      /** @enum {string} */
      substrate?: "MediaMix" | "Soil" | "Sand" | "Moss" | "PerliteVermiculite" | "Other";
      substrateNotes?: string;
      /** @enum {string} */
      treatment?: "Soak" | "Scarify" | "Chemical" | "Stratification" | "Other" | "Light";
      treatmentNotes?: string;
      /** Format: int32 */
      version: number;
    };
    UpdateCohortRequestPayload: {
      name: string;
      /** @enum {string} */
      phase: "Phase 0 - Due Diligence" | "Phase 1 - Feasibility Study" | "Phase 2 - Plan and Scale" | "Phase 3 - Implement and Monitor" | "Pre-Screen" | "Application";
    };
    UpdateDeviceRequestPayload: {
      /**
       * @description Protocol-specific address of device, e.g., an IP address or a Bluetooth device ID.
       * @example 192.168.1.100
       */
      address?: string;
      /**
       * @description Name of device manufacturer.
       * @example InHand Networks
       */
      make: string;
      /**
       * @description Model number or model name of the device.
       * @example IR915L
       */
      model: string;
      /**
       * @description Name of this device.
       * @example BMU-1
       */
      name: string;
      /**
       * Format: int64
       * @description ID of parent device such as a hub or gateway, if any. The parent device must exist.
       */
      parentId?: number;
      /**
       * Format: int32
       * @description Port number if relevant for the protocol.
       * @example 50000
       */
      port?: number;
      /**
       * @description Device manager protocol name.
       * @example modbus
       */
      protocol?: string;
      /** @description Protocol- and device-specific custom settings. This is an arbitrary JSON object; the exact settings depend on the device type. */
      settings?: {
        [key: string]: unknown;
      };
      /**
       * @description High-level type of the device. Device manager may use this in conjunction with the make and model to determine which metrics to report.
       * @example inverter
       */
      type: string;
      /**
       * Format: int32
       * @description Level of diagnostic information to log.
       */
      verbosity?: number;
    };
    UpdateDocumentRequestPayload: {
      internalComment?: string;
      name: string;
      /** Format: int64 */
      ownedBy: number;
    };
    UpdateDraftPlantingSiteRequestPayload: {
      /** @description In-progress state of the draft. This includes map data and other information needed by the client. It is treated as opaque data by the server. */
      data: {
        [key: string]: unknown;
      };
      description?: string;
      name: string;
      /**
       * Format: int32
       * @description If the user has started defining planting subzones, the number of subzones defined so far.
       */
      numPlantingSubzones?: number;
      /**
       * Format: int32
       * @description If the user has started defining planting zones, the number of zones defined so far.
       */
      numPlantingZones?: number;
      /**
       * Format: int64
       * @description If the draft is associated with a project, its ID.
       */
      projectId?: number;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    UpdateFacilityRequestPayload: {
      /** Format: date */
      buildCompletedDate?: string;
      /** Format: date */
      buildStartedDate?: string;
      /**
       * Format: int32
       * @description For nursery facilities, the number of plants this nursery is capable of holding.
       */
      capacity?: number;
      description?: string;
      name: string;
      /** Format: date */
      operationStartedDate?: string;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    UpdateGlobalRolesRequestPayload: {
      globalRoles: ("Super-Admin" | "Accelerator Admin" | "TF Expert" | "Read Only")[];
    };
    UpdateNotificationRequestPayload: {
      read: boolean;
    };
    UpdateNotificationsRequestPayload: {
      /** Format: int64 */
      organizationId?: number;
      read: boolean;
    };
    UpdateOrganizationInternalTagsRequestPayload: {
      tagIds: number[];
    };
    UpdateOrganizationRequestPayload: {
      /**
       * @description ISO 3166 alpha-2 code of organization's country.
       * @example AU
       */
      countryCode?: string;
      /**
       * @description ISO 3166-2 code of organization's country subdivision (state, province, region, etc.) This is the full ISO 3166-2 code including the country prefix. If this is set, countryCode must also be set.
       * @example US-HI
       */
      countrySubdivisionCode?: string;
      description?: string;
      name: string;
      /** @enum {string} */
      organizationType?: "Government" | "NGO" | "Arboreta" | "Academia" | "ForProfit" | "Other";
      /** @description Non-empty additional description of organization when type is Other. */
      organizationTypeDetails?: string;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
      website?: string;
    };
    UpdateOrganizationUserRequestPayload: {
      /** @enum {string} */
      role: "Contributor" | "Manager" | "Admin" | "Owner" | "Terraformation Contact";
    };
    UpdateParticipantProjectSpeciesPayload: {
      feedback?: string;
      internalComment?: string;
      rationale?: string;
      /** @enum {string} */
      speciesNativeCategory?: "Native" | "Non-native";
      /** @enum {string} */
      submissionStatus: "Not Submitted" | "In Review" | "Needs Translation" | "Approved" | "Rejected" | "Not Needed" | "Completed";
    };
    UpdateParticipantRequestPayload: {
      /**
       * Format: int64
       * @description Assign the participant to this cohort. If null, remove the participant from its current cohort, if any.
       */
      cohortId?: number;
      name: string;
      /** @description Set the participant's list of assigned projects to this. If projects are currently assigned to the participant but aren't included in this list, they will be removed from the participant. */
      projectIds: number[];
    };
    UpdatePlantingSiteRequestPayload: {
      /** @description Site boundary. Ignored if this is a detailed planting site. */
      boundary?: components["schemas"]["MultiPolygon"];
      description?: string;
      name: string;
      plantingSeasons?: components["schemas"]["UpdatedPlantingSeasonPayload"][];
      /** Format: int64 */
      projectId?: number;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    UpdatePlantingSubzoneRequestPayload: {
      plantingCompleted: boolean;
    };
    UpdatePlotObservationRequestPayload: {
      /** @description Observed coordinates, if any, up to one per position. */
      coordinates: components["schemas"]["ObservationMonitoringPlotCoordinatesPayload"][];
    };
    UpdateProjectAcceleratorDetailsRequestPayload: {
      annualCarbon?: number;
      applicationReforestableLand?: number;
      carbonCapacity?: number;
      confirmedReforestableLand?: number;
      countryCode?: string;
      dealDescription?: string;
      /** @enum {string} */
      dealStage?: "Phase 0 (Doc Review)" | "Phase 1" | "Phase 2" | "Phase 3" | "Graduated, Finished Planting" | "Non Graduate" | "Application Submitted" | "Project Lead Screening Review" | "Screening Questions Ready for Review" | "Carbon Pre-Check" | "Submission Requires Follow Up" | "Carbon Eligible" | "Closed Lost" | "Issue Active" | "Issue Pending" | "Issue Reesolved";
      /** @description Path on Dropbox to use for sensitive document storage. Ignored if the user does not have permission to update project document settings. */
      dropboxFolderPath?: string;
      failureRisk?: string;
      fileNaming?: string;
      /**
       * Format: uri
       * @description URL of Google Drive folder to use for non-sensitive document storage. Ignored if the user does not have permission to update project document settings.
       */
      googleFolderUrl?: string;
      /** Format: uri */
      hubSpotUrl?: string;
      investmentThesis?: string;
      landUseModelTypes: ("Native Forest" | "Monoculture" | "Sustainable Timber" | "Other Timber" | "Mangroves" | "Agroforestry" | "Silvopasture" | "Other Land-Use Model")[];
      maxCarbonAccumulation?: number;
      minCarbonAccumulation?: number;
      /** Format: int32 */
      numCommunities?: number;
      /** Format: int32 */
      numNativeSpecies?: number;
      perHectareBudget?: number;
      /** @enum {string} */
      pipeline?: "Accelerator Projects" | "Carbon Supply" | "Carbon Waitlist";
      projectLead?: string;
      totalCarbon?: number;
      totalExpansionPotential?: number;
      whatNeedsToBeTrue?: string;
    };
    UpdateProjectRequestPayload: {
      description?: string;
      name: string;
    };
    UpdateReportPhotoRequestPayload: {
      caption?: string;
    };
    UpdateReportSettingsRequestPayload: {
      /** @description If true, enable organization-level reports. */
      organizationEnabled: boolean;
      /** Format: int64 */
      organizationId: number;
      /** @description Per-project report settings. If a project is missing from this list, its settings will revert to the defaults. */
      projects: components["schemas"]["ProjectReportSettingsPayload"][];
    };
    UpdateSavedDocumentVersionRequestPayload: {
      isSubmitted: boolean;
    };
    UpdateSubLocationRequestPayload: {
      name: string;
    };
    UpdateSubmissionRequestPayload: {
      feedback?: string;
      internalComment?: string;
      /** @enum {string} */
      status: "Not Submitted" | "In Review" | "Needs Translation" | "Approved" | "Rejected" | "Not Needed" | "Completed";
    };
    UpdateUserCookieConsentRequestPayload: {
      /** @description If true, the user consents to the use of analytics cookies. If false, they decline. */
      cookiesConsented: boolean;
    };
    UpdateUserDeliverableCategoriesRequestPayload: {
      /** @description New set of category assignments. Existing assignments that aren't included here will be removed from the user. */
      deliverableCategories: ("Compliance" | "Financial Viability" | "GIS" | "Carbon Eligibility" | "Stakeholders and Community Impact" | "Proposed Restoration Activities" | "Verra Non-Permanence Risk Tool (NPRT)" | "Supplemental Files")[];
    };
    UpdateUserPreferencesRequestPayload: {
      /**
       * Format: int64
       * @description If present, update the user's per-organization preferences for this organization. If not present, update the user's global preferences.
       */
      organizationId?: number;
      preferences: {
        [key: string]: unknown;
      };
    };
    UpdateUserRequestPayload: {
      /**
       * @description Two-letter code of the user's country.
       * @example US
       */
      countryCode?: string;
      /** @description If true, the user wants to receive all the notifications for their organizations via email. This does not apply to certain kinds of notifications such as "You've been added to a new organization." If null, leave the existing value as-is. */
      emailNotificationsEnabled?: boolean;
      firstName: string;
      lastName: string;
      /**
       * @description IETF locale code containing user's preferred language.
       * @example en
       */
      locale?: string;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    /**
     * @description Operation that replaces a single existing value with a new one. The new value will have the same list position as the existing one.
     *
     * This operation may not be used with table variables.
     *
     * If the variable is a table column, the new value will be contained in the same row as the existing one.
     */
    UpdateValueOperationPayload: WithRequired<{
      operation: "Update";
    } & Omit<components["schemas"]["ValueOperationPayload"], "operation"> & {
      value?: components["schemas"]["NewValuePayload"];
      /** Format: int64 */
      valueId?: number;
    }, "existingValueId" | "value" | "valueId">;
    UpdateVariableOwnerRequestPayload: {
      /**
       * Format: int64
       * @description New owner of the variable, or null if the variable should have no owner.
       */
      ownedBy?: number;
    };
    UpdateVariableValuesRequestPayload: {
      /** @description List of operations to perform on the document's values. The operations are applied in order, and atomically: if any of them fail, none of them will be applied. */
      operations: (components["schemas"]["AppendValueOperationPayload"] | components["schemas"]["DeleteValueOperationPayload"] | components["schemas"]["ReplaceValuesOperationPayload"] | components["schemas"]["UpdateValueOperationPayload"])[];
    };
    UpdateVariableWorkflowDetailsRequestPayload: {
      feedback?: string;
      internalComment?: string;
      /** @enum {string} */
      status: "Not Submitted" | "In Review" | "Needs Translation" | "Approved" | "Rejected" | "Not Needed" | "Incomplete" | "Complete";
    };
    UpdateViabilityTestRequestPayload: {
      /** Format: date */
      endDate?: string;
      notes?: string;
      /** @enum {string} */
      seedType?: "Fresh" | "Stored";
      /** Format: int32 */
      seedsCompromised?: number;
      /** Format: int32 */
      seedsEmpty?: number;
      /** Format: int32 */
      seedsFilled?: number;
      /** Format: int32 */
      seedsTested: number;
      /** Format: date */
      startDate?: string;
      /** @enum {string} */
      substrate?: "Nursery Media" | "Agar" | "Paper" | "Other" | "Sand" | "Media Mix" | "Soil" | "Moss" | "Perlite/Vermiculite" | "None";
      testResults?: components["schemas"]["ViabilityTestResultPayload"][];
      /** @enum {string} */
      treatment?: "Soak" | "Scarify" | "Chemical" | "Stratification" | "Other" | "Light";
      /**
       * Format: int64
       * @description ID of user who withdrew seeds to perform the test. If non-null, the current user must have permission to see the referenced user's membership details in the organization. If absent or null, the existing value is left unchanged.
       */
      withdrawnByUserId?: number;
    };
    UpdateWithdrawalRequestPayload: {
      /** Format: date */
      date?: string;
      notes?: string;
      /** @enum {string} */
      purpose?: "Other" | "Viability Testing" | "Out-planting" | "Nursery";
      /**
       * Format: int64
       * @description ID of the user who withdrew the seeds. Default is the withdrawal's existing user ID. If non-null, the current user must have permission to read the referenced user's membership details in the organization.
       */
      withdrawnByUserId?: number;
      /** @description Quantity of seeds withdrawn. For viability testing withdrawals, this is always the same as the test's "seedsTested" value. Otherwise, it is a user-supplied value. If this quantity is in weight and the remaining quantity of the accession is in seeds or vice versa, the accession must have a subset weight and count. */
      withdrawnQuantity?: components["schemas"]["SeedQuantityPayload"];
    };
    UpdatedPlantingSeasonPayload: {
      /** Format: date */
      endDate: string;
      /**
       * Format: int64
       * @description If present, the start and end dates of an existing planting season will be updated. Otherwise a new planting season will be created.
       */
      id?: number;
      /** Format: date */
      startDate: string;
    };
    UpgradeManifestRequestPayload: {
      /**
       * Format: int64
       * @description ID of manifest to upgrade the document to. This must be greater than the document's current manifest ID (downgrades are not supported) and must be for the same document template as the current manifest.
       */
      variableManifestId: number;
    };
    UploadAttachmentResponsePayload: {
      attachments: components["schemas"]["TemporaryAttachment"][];
      status: components["schemas"]["SuccessOrError"];
    };
    UploadDeliverableDocumentResponsePayload: {
      /** Format: int64 */
      documentId: number;
      status: components["schemas"]["SuccessOrError"];
    };
    UploadFileResponsePayload: {
      /**
       * Format: int64
       * @description ID of uploaded file. This may be used to poll for the file's status.
       */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    UploadImageFileResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      /** Format: int64 */
      valueId: number;
    };
    UploadPlotPhotoRequestPayload: {
      gpsCoordinates: components["schemas"]["Point"];
      /** @enum {string} */
      position: "SouthwestCorner" | "SoutheastCorner" | "NortheastCorner" | "NorthwestCorner";
    };
    UploadPlotPhotoResponsePayload: {
      /** Format: int64 */
      fileId: number;
      status: components["schemas"]["SuccessOrError"];
    };
    /** @description List of conditions that might cause the user to want to cancel the upload but that can be automatically resolved if desired. */
    UploadProblemPayload: {
      /** @description Name of the field with the problem. Absent if the problem isn't specific to a single field. */
      fieldName?: string;
      /** @description Human-readable description of the problem. */
      message?: string;
      /**
       * Format: int32
       * @description Position (row number) of the record with the problem.
       */
      position?: number;
      /** @enum {string} */
      type: "Unrecognized Value" | "Missing Required Value" | "Duplicate Value" | "Malformed Value";
      /** @description The value that caused the problem. Absent if the problem wasn't caused by a specific field value. */
      value?: string;
    };
    UploadReportFileResponsePayload: {
      /** Format: int64 */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    UpsertProjectScoresRequestPayload: {
      /** @enum {string} */
      phase: "Phase 0 - Due Diligence" | "Phase 1 - Feasibility Study" | "Phase 2 - Plan and Scale" | "Phase 3 - Implement and Monitor" | "Pre-Screen" | "Application";
      scores: components["schemas"]["UpsertScore"][];
    };
    UpsertProjectVotesRequestPayload: {
      /** @enum {string} */
      phase: "Phase 0 - Due Diligence" | "Phase 1 - Feasibility Study" | "Phase 2 - Plan and Scale" | "Phase 3 - Implement and Monitor" | "Pre-Screen" | "Application";
      votes: components["schemas"]["UpsertVoteSelection"][];
    };
    UpsertScore: {
      /** @enum {string} */
      category: "Carbon" | "Finance" | "Forestry" | "Legal" | "Social Impact" | "GIS" | "Climate Impact" | "Expansion Potential" | "Experience and Understanding" | "Operational Capacity" | "Responsiveness and Attention to Detail" | "Values Alignment";
      qualitative?: string;
      /**
       * Format: int32
       * @description If set to `null`, remove the selected score.
       */
      value?: number;
    };
    UpsertVoteSelection: {
      conditionalInfo?: string;
      /** Format: int64 */
      userId: number;
      /**
       * @description If set to `null`, remove the vote the user has previously selected.
       * @enum {string}
       */
      voteOption?: "No" | "Conditional" | "Yes";
    };
    UserProfilePayload: {
      /** @description If true, the user has consented to the use of analytics cookies. If false, the user has declined. If null, the user has not made a consent selection yet. */
      cookiesConsented?: boolean;
      /**
       * Format: date-time
       * @description If the user has selected whether or not to consent to analytics cookies, the date and time of the selection.
       */
      cookiesConsentedTime?: string;
      /**
       * @description Two-letter code of the user's country.
       * @example US
       */
      countryCode?: string;
      email: string;
      /** @description If true, the user wants to receive all the notifications for their organizations via email. This does not apply to certain kinds of notifications such as "You've been added to a new organization." */
      emailNotificationsEnabled: boolean;
      firstName?: string;
      globalRoles: ("Super-Admin" | "Accelerator Admin" | "TF Expert" | "Read Only")[];
      /**
       * Format: int64
       * @description User's unique ID. This should not be shown to the user, but is a required input to some API endpoints.
       */
      id: number;
      lastName?: string;
      /**
       * @description IETF locale code containing user's preferred language.
       * @example en
       */
      locale?: string;
      /**
       * @description Time zone name in IANA tz database format
       * @example America/New_York
       */
      timeZone?: string;
    };
    UserWithGlobalRolesPayload: {
      /** Format: date-time */
      createdTime: string;
      deliverableCategories: ("Compliance" | "Financial Viability" | "GIS" | "Carbon Eligibility" | "Stakeholders and Community Impact" | "Proposed Restoration Activities" | "Verra Non-Permanence Risk Tool (NPRT)" | "Supplemental Files")[];
      email: string;
      firstName?: string;
      globalRoles: ("Super-Admin" | "Accelerator Admin" | "TF Expert" | "Read Only")[];
      /** Format: int64 */
      id: number;
      lastName?: string;
    };
    ValidatePlantingSiteResponsePayload: {
      /** @description True if the request was valid. */
      isValid: boolean;
      /** @description List of validation problems found, if any. Empty if the request is valid. */
      problems: components["schemas"]["PlantingSiteValidationProblemPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    /** @description Supertype of the payloads that describe which operations to perform on a variable's value(s). See the descriptions of the individual operations for details. */
    ValueOperationPayload: {
      /** Format: int64 */
      existingValueId?: number;
      operation: string;
    };
    VariableOwnersResponseElement: {
      /** Format: int64 */
      ownedBy: number;
      /** Format: int64 */
      variableId: number;
    };
    VariablePayload: {
      /** Format: int64 */
      deliverableId?: number;
      deliverableQuestion?: string;
      /** @enum {string} */
      dependencyCondition?: "eq" | "gt" | "gte" | "lt" | "lte" | "neq";
      dependencyValue?: string;
      dependencyVariableStableId?: string;
      description?: string;
      /** Format: int64 */
      id: number;
      isList: boolean;
      isRequired: boolean;
      name: string;
      /** Format: int32 */
      position?: number;
      /** @description IDs of sections that recommend this variable. */
      recommendedBy?: number[];
      stableId: string;
      /** @enum {string} */
      type: "Number" | "Text" | "Date" | "Image" | "Select" | "Table" | "Link" | "Section";
    };
    VersionsEntryPayload: {
      appName: string;
      minimumVersion: string;
      platform: string;
      recommendedVersion: string;
    };
    VersionsResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
      versions: components["schemas"]["VersionsEntryPayload"][];
    };
    ViabilityTestResultPayload: {
      /** Format: date */
      recordingDate: string;
      /** Format: int32 */
      seedsGerminated: number;
    };
    VoteSelection: {
      conditionalInfo?: string;
      /** @description The vote the user has selected. Can be yes/no/conditional or `null` if a vote is not yet selected. */
      email: string;
      firstName?: string;
      lastName?: string;
      /** Format: int64 */
      userId: number;
      /** @enum {string} */
      voteOption?: "No" | "Conditional" | "Yes";
    };
    WorkersPayloadV1: {
      /** Format: int32 */
      femalePaidWorkers?: number;
      /** Format: int32 */
      paidWorkers?: number;
      /** Format: int32 */
      volunteers?: number;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * List all the applications with optional search criteria
   * @description Only applications visible to the current user are returned.
   */
  listApplications: {
    parameters: {
      query?: {
        /** @description If present, only list applications for this organization. */
        organizationId?: number;
        /** @description If present, only list applications for this project. A project can only have one application, so this will either return an empty result or a result with a single element. */
        projectId?: number;
        /** @description If true, list all applications for all projects. Only allowed for internal users. */
        listAll?: boolean;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListApplicationsResponsePayload"];
        };
      };
    };
  };
  /** Create a new application */
  createApplication: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateApplicationRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateApplicationResponsePayload"];
        };
      };
    };
  };
  /** Get information about an application */
  getApplication: {
    parameters: {
      path: {
        applicationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetApplicationResponsePayload"];
        };
      };
    };
  };
  /** Update an application's boundary */
  updateApplicationBoundary: {
    parameters: {
      path: {
        applicationId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateApplicationBoundaryRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Update an application's boundary using an uploaded file */
  uploadApplicationBoundary: {
    parameters: {
      path: {
        applicationId: number;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Get deliverables for an application */
  getApplicationDeliverables: {
    parameters: {
      path: {
        applicationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetApplicationDeliverablesResponsePayload"];
        };
      };
    };
  };
  /** Get the history of changes to the metadata of an application */
  getApplicationHistory: {
    parameters: {
      path: {
        applicationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetApplicationHistoryResponsePayload"];
        };
      };
    };
  };
  /** Get modules for an application */
  getApplicationModules: {
    parameters: {
      path: {
        applicationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetApplicationModulesResponsePayload"];
        };
      };
    };
  };
  /** Get deliverables for an application module */
  getApplicationModuleDeliverables: {
    parameters: {
      path: {
        applicationId: number;
        moduleId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetApplicationDeliverablesResponsePayload"];
        };
      };
    };
  };
  /**
   * Restart a previously-submitted application
   * @description If the application has not been submitted yet, this is a no-op.
   */
  restartApplication: {
    parameters: {
      path: {
        applicationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Update an application's metadata to reflect a review
   * @description This is an internal-user-only operation.
   */
  reviewApplication: {
    parameters: {
      path: {
        applicationId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ReviewApplicationRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Submit an application for review
   * @description If the application has already been submitted, this is a no-op.
   */
  submitApplication: {
    parameters: {
      path: {
        applicationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SubmitApplicationResponsePayload"];
        };
      };
    };
  };
  /** Gets the list of cohorts. */
  listCohorts: {
    parameters: {
      query: {
        /** @description If specified, retrieve associated entities to the supplied depth. For example, 'participant' depth will return the participants associated to the cohort. */
        cohortDepth: "Cohort" | "Participant";
        cohortModuleDepth: "Cohort" | "Module";
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["CohortListResponsePayload"];
        };
      };
    };
  };
  /** Creates a new cohort. */
  createCohort: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateCohortRequestPayload"];
      };
    };
    responses: {
      /** @description The cohort was created successfully. */
      200: {
        content: {
          "application/json": components["schemas"]["CohortResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a single cohort. */
  getCohort: {
    parameters: {
      query: {
        /** @description If specified, retrieve associated entities to the supplied depth. For example, 'participant' depth will return the participants associated to the cohort. */
        cohortDepth: "Cohort" | "Participant";
        cohortModuleDepth: "Cohort" | "Module";
      };
      path: {
        cohortId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["CohortResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Updates the information within a single cohort. */
  updateCohort: {
    parameters: {
      path: {
        cohortId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateCohortRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["CohortResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Deletes a single cohort. */
  deleteCohort: {
    parameters: {
      path: {
        cohortId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Lists the deliverables for accelerator projects
   * @description The list may optionally be filtered based on certain criteria as specified in the query string. If no filter parameters are supplied, lists all the deliverables in all the participants and projects that are visible to the user. For users with accelerator admin privileges, this will be the full list of all deliverables for all accelerator projects.
   */
  listDeliverables: {
    parameters: {
      query?: {
        /** @description Filter deliverables by modules. Can be used with other request params. */
        moduleId?: number;
        /** @description List deliverables for projects belonging to this organization. Ignored if participantId or projectId is specified. */
        organizationId?: number;
        /** @description List deliverables for all projects in this participant. Ignored if projectId is specified. */
        participantId?: number;
        /** @description List deliverables for this project only. */
        projectId?: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["ListDeliverablesResponsePayload"];
        };
      };
    };
  };
  /** Uploads a new document to satisfy a deliverable. */
  uploadDeliverableDocument: {
    parameters: {
      path: {
        deliverableId: number;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          description: string;
          /** Format: binary */
          file: string;
          projectId: string;
        };
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["UploadDeliverableDocumentResponsePayload"];
        };
      };
      /** @description The server is unable to store the uploaded file. This response indicates a condition that triggers the system to create a customer support ticket; clients can inform users of that fact. */
      507: {
        content: {
          "application/json": components["schemas"]["UploadDeliverableDocumentResponsePayload"];
        };
      };
    };
  };
  /** Gets a single submission document from a deliverable. */
  getDeliverableDocument: {
    parameters: {
      path: {
        deliverableId: number;
        documentId: number;
      };
    };
    responses: {
      /** @description If the current user has permission to view the document, redirects to the document on the document store. Depending on the document store, the redirect URL may or may not be valid for only a limited time. */
      307: {
        headers: {
          /** @description URL of document in document store. */
          Location?: unknown;
        };
        content: {
          "application/json": string;
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets the details of a single deliverable and its submission documents, if any. */
  getDeliverable: {
    parameters: {
      path: {
        deliverableId: number;
        projectId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetDeliverableResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Updates the state of a submission from a project.
   * @description Only permitted for users with accelerator admin privileges.
   */
  updateSubmission: {
    parameters: {
      path: {
        deliverableId: number;
        projectId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateSubmissionRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Marks a submission from a project as completed. */
  completeSubmission: {
    parameters: {
      path: {
        deliverableId: number;
        projectId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Lists organizations with the Accelerator internal tag and their projects.
   * @description By default, only lists tagged organizations that have projects that have not been assigned to participants yet.
   */
  listAcceleratorOrganizations: {
    parameters: {
      query?: {
        /** @description Whether to also include projects that have been assigned to participants. */
        includeParticipants?: boolean;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListAcceleratorOrganizationsResponsePayload"];
        };
      };
    };
  };
  /** Creates a new participant. */
  createParticipant: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateParticipantRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetParticipantResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a participant and its assigned projects. */
  getParticipant: {
    parameters: {
      path: {
        participantId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetParticipantResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Updates a participant's information. */
  updateParticipant: {
    parameters: {
      path: {
        participantId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateParticipantRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Deletes a participant that has no projects. */
  deleteParticipant: {
    parameters: {
      path: {
        participantId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description There are projects associated with the participant. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Creates a new participant project species entry. */
  createParticipantProjectSpecies: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateParticipantProjectSpeciesPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetParticipantProjectSpeciesResponsePayload"];
        };
      };
    };
  };
  /** Deletes participant project species entries. */
  deleteParticipantProjectSpecies: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeleteParticipantProjectSpeciesPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Creates a new participant project species entry for every project ID and species ID pairing. */
  assignParticipantProjectSpecies: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["AssignParticipantProjectSpeciesPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a participant project species. */
  getParticipantProjectSpecies: {
    parameters: {
      path: {
        participantProjectSpeciesId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetParticipantProjectSpeciesResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Updates a participant project species entry. */
  updateParticipantProjectSpecies: {
    parameters: {
      path: {
        participantProjectSpeciesId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateParticipantProjectSpeciesPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Gets the accelerator-related details for a project.
   * @description Does not include information such as project name that's available via the non-accelerator projects API.
   */
  getProjectAcceleratorDetails: {
    parameters: {
      path: {
        projectId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetProjectAcceleratorDetailsResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Updates the accelerator-related details for a project. */
  updateProjectAcceleratorDetails: {
    parameters: {
      path: {
        projectId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateProjectAcceleratorDetailsRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets score selections for a single project. */
  getProjectScores: {
    parameters: {
      path: {
        projectId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetProjectScoresResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Upserts score selections for a single project.
   * @description Update the scores for the project phase. If the (project, phase, category) does not exist, a new entry is created. Setting a `score` to `null` removes the score.
   */
  upsertProjectScores: {
    parameters: {
      path: {
        projectId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpsertProjectScoresRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets all species associated to a participant project. */
  getSpeciesForProject: {
    parameters: {
      path: {
        projectId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesForParticipantProjectsResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Creates a new participant project species entry. */
  getParticipantProjectSpeciesSnapshot: {
    parameters: {
      path: {
        projectId: number;
        deliverableId: number;
      };
    };
    responses: {
      /** @description The file was successfully retrieved. */
      200: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  /**
   * Gets vote selections for a single project.
   * @description List every vote selection for this project, organized by phases. Each phase will contain a list of eligible voters and their selections.
   */
  getProjectVotes: {
    parameters: {
      path: {
        projectId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetProjectVotesResponsePayload"];
        };
      };
      /** @description Attempting to read votes without sufficient privilege */
      403: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Upserts vote selections for a single project.
   * @description Update the user's vote for the project phase. If the (user, project, phase) does not exist, a new entry is created. Setting a `voteOption` to `null` removes the vote.
   */
  upsertProjectVotes: {
    parameters: {
      path: {
        projectId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpsertProjectVotesRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description Attempting to delete votes without sufficient privilege */
      403: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description Attempting to upsert a vote in an inactive phase */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Remove one or more voters from the project/phase.
   * @description Remove the voters from the project phase, making them ineligible from voting. This is different from undoing a vote (by setting the `voteOption` to `null`). To remove voters from the entire project phase, set `userId` to `null`, and set `phaseDelete` to `true`
   */
  deleteProjectVotes: {
    parameters: {
      path: {
        projectId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeleteProjectVotesRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description Attempting to delete a phase of votes without safeguard */
      400: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description Attempting to delete votes without sufficient privilege */
      403: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description Attempting to delete a vote in an inactive phase */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets all participant projects associated to a species with active deliverable information if applicable. */
  getProjectsForSpecies: {
    parameters: {
      path: {
        speciesId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetParticipantProjectsForSpeciesResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets a list of automations for a device or facility. */
  listAutomations: {
    parameters: {
      query?: {
        deviceId?: number;
        facilityId?: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListAutomationsResponsePayload"];
        };
      };
    };
  };
  /** Creates a new automation for a device or facility. */
  createAutomation: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateAutomationRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateAutomationResponsePayload"];
        };
      };
    };
  };
  /** Gets the details of a single automation for a device or facility. */
  getAutomation: {
    parameters: {
      path: {
        automationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetAutomationResponsePayload"];
        };
      };
    };
  };
  /** Updates an existing automation for a device or facility. */
  updateAutomation: {
    parameters: {
      path: {
        automationId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateAutomationRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Deletes an existing automation from a device or facility. */
  deleteAutomation: {
    parameters: {
      path: {
        automationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Reports that an automation has been triggered. */
  postAutomationTrigger: {
    parameters: {
      path: {
        automationId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AutomationTriggerRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Registers a new device a facility's device manager. */
  createDevice: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateDeviceRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Gets the configuration of a single device. */
  getDevice: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description Device configuration retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["GetDeviceResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Updates the configuration of an existing device. */
  updateDevice: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateDeviceRequestPayload"];
      };
    };
    responses: {
      /** @description Device configuration updated. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Marks a device as unresponsive.
   * @description Notifies the appropriate users so they can troubleshoot the problem.
   */
  deviceUnresponsive: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeviceUnresponsiveRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets a list of all the documents. */
  listDocuments: {
    parameters: {
      query?: {
        /** @description If present, only list documents for this project. */
        projectId?: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListDocumentsResponsePayload"];
        };
      };
    };
  };
  /** Creates a new document. */
  createDocument: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateDocumentRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateDocumentResponsePayload"];
        };
      };
    };
  };
  /**
   * Upgrades a document to a newer manifest.
   * @description The manifest must be for the same document template as the existing manifest.
   */
  upgradeManifest: {
    parameters: {
      path: {
        documentId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpgradeManifestRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The document does not exist or the requested manifest does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The requested manifest is for a different document template than the current one. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Saves a version of a document. */
  createSavedDocumentVersion: {
    parameters: {
      path: {
        documentId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateSavedDocumentVersionRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["CreateSavedDocumentVersionResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The document has no values to save. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets details of a specific saved version of a document. */
  getSavedDocumentVersion: {
    parameters: {
      path: {
        documentId: number;
        versionId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetSavedDocumentVersionResponsePayload"];
        };
      };
    };
  };
  /** Updates a saved version of a document. */
  updateSavedDocumentVersion: {
    parameters: {
      path: {
        documentId: number;
        versionId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateSavedDocumentVersionRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Gets a document. */
  getDocument: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetDocumentResponsePayload"];
        };
      };
    };
  };
  /** Updates a document. */
  updateDocument: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateDocumentRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Gets the history of a document. This includes both information about document edits and information about saved versions. */
  getDocumentHistory: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetDocumentHistoryResponsePayload"];
        };
      };
    };
  };
  /** Save an image to a new variable value. */
  uploadProjectImageValue: {
    parameters: {
      path: {
        projectId: number;
      };
    };
    requestBody?: {
      content: {
        "application/json": {
          caption?: string;
          citation?: string;
          /** Format: binary */
          file: string;
          /**
           * Format: int32
           * @description If the variable is a list, which list position to use for the value. If not specified, the server will use the next available list position if the variable is a list, or will replace any existing image if the variable is not a list.
           */
          listPosition?: number;
          /**
           * Format: int64
           * @description If the variable is a table column, value ID of the row the value should belong to.
           */
          rowValueId?: number;
          /** Format: int64 */
          variableId: number;
        };
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UploadImageFileResponsePayload"];
        };
      };
    };
  };
  /**
   * Gets the contents of an image variable value.
   * @description Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio.
   */
  getProjectImageValue: {
    parameters: {
      query?: {
        /** @description Maximum desired width in pixels. If neither this nor maxHeight is specified, the full-sized original image will be returned. If this is specified, an image no wider than this will be returned. The image may be narrower than this value if needed to preserve the aspect ratio of the original. */
        maxWidth?: string;
        /** @description Maximum desired height in pixels. If neither this nor maxWidth is specified, the full-sized original image will be returned. If this is specified, an image no taller than this will be returned. The image may be shorter than this value if needed to preserve the aspect ratio of the original. */
        maxHeight?: string;
      };
      path: {
        projectId: number;
        valueId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": string;
          "image/jpeg": string;
          "image/png": string;
        };
      };
    };
  };
  /**
   * List the owners of a project's variables.
   * @description Only variables that actually have owners are returned.
   */
  listVariableOwners: {
    parameters: {
      path: {
        projectId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListVariableOwnersResponsePayload"];
        };
      };
    };
  };
  /** Update or remove the owner of a variable in a project. */
  updateVariableOwner: {
    parameters: {
      path: {
        projectId: number;
        variableId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateVariableOwnerRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Get the values of the variables in a project.
   * @description This may be used to fetch the full set of current values (the default behavior), the values from a saved version (if maxValueId is specified), or to poll for recent edits (if minValueId is specified).
   */
  listProjectVariableValues: {
    parameters: {
      query?: {
        /** @description If specified, only return values that belong to variables that are associated to the given ID */
        deliverableId?: number;
        /** @description If specified, only return values with this ID or higher. Use this to poll for incremental updates to a document. Incremental results may include values of type 'Deleted' in cases where, e.g., elements have been removed from a list. */
        minValueId?: number;
        /** @description If specified, only return values with this ID or lower. Use this to retrieve saved document versions. */
        maxValueId?: number;
      };
      path: {
        projectId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListVariableValuesResponsePayload"];
        };
      };
    };
  };
  /**
   * Update the values of the variables in a project.
   * @description Make a list of changes to a project's variable values. The changes are applied in order and are treated as an atomic unit. That is, the changes will either all succeed or all fail; there won't be a case where some of the changes are applied and some aren't. See the payload descriptions for more details about the operations you can perform on values.
   */
  updateProjectVariableValues: {
    parameters: {
      path: {
        projectId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateVariableValuesRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Update the workflow details for a variable in a project. */
  updateVariableWorkflowDetails: {
    parameters: {
      path: {
        projectId: number;
        variableId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateVariableWorkflowDetailsRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Gets a list of all the valid document templates. */
  listDocumentTemplates: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListDocumentTemplatesResponsePayload"];
        };
      };
    };
  };
  /** List the variables, optionally filtered by a given manifest or deliverable. Variables returned for a manifest include all section hierarchies and variables injected into section text. */
  listVariables: {
    parameters: {
      query?: {
        deliverableId?: number;
        documentId?: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListVariablesResponsePayload"];
        };
      };
    };
  };
  /** Lists all accessible facilities. */
  listAllFacilities: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListFacilitiesResponse"];
        };
      };
    };
  };
  /** Creates a new facility. */
  createFacility: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateFacilityRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateFacilityResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a single facility. */
  getFacility: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetFacilityResponse"];
        };
      };
    };
  };
  /** Updates information about a facility. */
  updateFacility: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateFacilityRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Sends an alert to the facility's configured alert recipients. */
  sendFacilityAlert: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SendFacilityAlertRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The request was received, but the user is still configuring or placing sensors, so no notification has been generated. */
      202: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Marks a facility as fully configured.
   * @description After connecting a device manager and finishing any necessary configuration of the facility's devices, send this request to enable processing of timeseries values and alerts from the device manager. Only valid if the facility's connection state is `Connected`.
   */
  postConfigured: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The facility's device manager was not in the process of being configured. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Lists the configurations of all the devices at a facility. */
  listFacilityDevices: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** @description Successfully listed the facility's devices. */
      200: {
        content: {
          "application/json": components["schemas"]["ListDeviceConfigsResponse"];
        };
      };
      /** @description The facility does not exist or is not accessible by the current user. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets a list of sub-locations at a facility. */
  listSubLocations: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListSubLocationsResponsePayload"];
        };
      };
    };
  };
  /** Creates a new sub-location at a facility. */
  createSubLocation: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateSubLocationRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetSubLocationResponsePayload"];
        };
      };
      /** @description A sub-location with the requested name already exists at the facility. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a specific sub-location at a facility. */
  getSubLocation: {
    parameters: {
      path: {
        facilityId: number;
        subLocationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetSubLocationResponsePayload"];
        };
      };
    };
  };
  /** Updates the name of a sub-location at a facility. */
  updateSubLocation: {
    parameters: {
      path: {
        facilityId: number;
        subLocationId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateSubLocationRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description A sub-location with the requested name already exists at the facility. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Deletes a sub-location from a facility.
   * @description The sub-location must not be in use.
   */
  deleteSubLocation: {
    parameters: {
      path: {
        facilityId: number;
        subLocationId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The sub-location is in use, e.g., there are seeds or seedlings stored there. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Lists the configurations of all the devices at a facility. */
  listFacilityDevices_1: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** @description Successfully listed the facility's devices. */
      200: {
        content: {
          "application/json": components["schemas"]["ListDeviceConfigsResponse"];
        };
      };
      /** @description The facility does not exist or is not accessible by the current user. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets the list of users that have global roles. */
  listGlobalRoles: {
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GlobalRoleUsersListResponsePayload"];
        };
      };
    };
  };
  /** Remove global roles from the supplied users. */
  deleteGlobalRoles: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeleteGlobalRolesRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets a list of supported time zones and their names. */
  listTimeZoneNames: {
    parameters: {
      query?: {
        /**
         * @description Language code and optional country code suffix. If not specified, the preferred locale from the Accept-Language header is used if supported; otherwise US English is the default.
         * @example zh-CN
         */
        locale?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListTimeZoneNamesResponsePayload"];
        };
      };
    };
  };
  /** List all the available internal tags */
  listAllInternalTags: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListAllInternalTagsResponsePayload"];
        };
      };
    };
  };
  /**
   * List the internal tags assigned to all organizations
   * @description This includes organizations with no internal tags, whose list of tags will be empty.
   */
  listAllOrganizationInternalTags: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListAllOrganizationInternalTagsResponsePayload"];
        };
      };
    };
  };
  /** List the internal tags assigned to an organization */
  listOrganizationInternalTags: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListOrganizationInternalTagsResponsePayload"];
        };
      };
    };
  };
  /** Replace the list of internal tags assigned to an organization */
  updateOrganizationInternalTags: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateOrganizationInternalTagsRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Redirects to a login page.
   * @description For interactive web applications, this can be used to redirect the user to a login page to allow the application to make other API requests. The login process will set a cookie that will authenticate to the API, and will then redirect back to the application. One approach is to use this in error response handlers: if an API request returns HTTP 401 Unauthorized, set location.href to this endpoint and set "redirect" to the URL of the page the user was on so they'll return there after logging in.
   */
  login: {
    parameters: {
      query: {
        /** @description URL to redirect to after login. The list of valid redirect URLs is restricted; this must be the URL of a Terraware web application. */
        redirect: string;
      };
    };
    responses: {
      /** @description Redirects to a login page. After login, the user will be redirected back to the URL specified in the "redirect" parameter. */
      302: {
        content: never;
      };
    };
  };
  /** Retrieve all notifications for current user scoped to an organization. */
  readAll: {
    parameters: {
      query?: {
        /** @description If set, return notifications relevant to that organization. */
        organizationId?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNotificationsResponsePayload"];
        };
      };
    };
  };
  /** Update notifications as read or unread */
  markAllRead: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateNotificationsRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Retrieve notifications count by organization for current user. */
  count: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNotificationsCountResponsePayload"];
        };
      };
    };
  };
  /** Retrieve a notification by its id. */
  read: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNotificationResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Update a single notification as read or unread */
  markRead: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateNotificationRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Creates a new seedling batch at a nursery. */
  createBatch: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateBatchRequestPayload"];
      };
    };
    responses: {
      /** @description The batch was created successfully. Response includes fields populated by the server, including the batch ID. */
      200: {
        content: {
          "application/json": components["schemas"]["BatchResponsePayload"];
        };
      };
    };
  };
  /**
   * Uploads a list of seedling batches to add to the nursery.
   * @description The uploaded file must be in CSV format. A template with the correct headers may be downloaded from the `/api/v1/nursery/batches/uploads/template` endpoint.
   */
  uploadSeedlingBatchesList: {
    parameters: {
      query: {
        facilityId: number;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
    responses: {
      /** @description The file has been successfully received. It will be processed asynchronously; use the ID returned in the response payload to poll for its status using the `/api/v1/nursery/batches/uploads/{uploadId}` GET endpoint. */
      200: {
        content: {
          "application/json": components["schemas"]["UploadFileResponsePayload"];
        };
      };
    };
  };
  /** Gets a template file that contains the required header row for seedling batch uploads. */
  getSeedlingBatchesUploadTemplate: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": string;
        };
      };
    };
  };
  /**
   * Gets the status of a seedling batches list uploaded previously.
   * @description Clients may poll this endpoint to monitor the progress of the file.
   */
  getSeedlingBatchesListUploadStatus: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetUploadStatusResponsePayload"];
        };
      };
    };
  };
  /**
   * Gets the history of changes to a seedling batch.
   * @description Each event includes a version number. For events such as details edits that are snapshots of the values at a particular time, clients can compare against the event with the previous version number to see what has changed, e.g., to show a delta or a diff view.
   */
  getBatchHistory: {
    parameters: {
      path: {
        batchId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetBatchHistoryResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Lists all the photos of a seedling batch. */
  listBatchPhotos: {
    parameters: {
      path: {
        batchId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListBatchPhotosResponsePayload"];
        };
      };
      /** @description The batch does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Creates a new photo of a seedling batch. */
  createBatchPhoto: {
    parameters: {
      path: {
        batchId: number;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateBatchPhotoResponsePayload"];
        };
      };
    };
  };
  /**
   * Retrieves a specific photo from a seedling batch.
   * @description Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio.
   */
  getBatchPhoto: {
    parameters: {
      query?: {
        /** @description Maximum desired width in pixels. If neither this nor maxHeight is specified, the full-sized original image will be returned. If this is specified, an image no wider than this will be returned. The image may be narrower than this value if needed to preserve the aspect ratio of the original. */
        maxWidth?: string;
        /** @description Maximum desired height in pixels. If neither this nor maxWidth is specified, the full-sized original image will be returned. If this is specified, an image no taller than this will be returned. The image may be shorter than this value if needed to preserve the aspect ratio of the original. */
        maxHeight?: string;
      };
      path: {
        batchId: number;
        photoId: number;
      };
    };
    responses: {
      /** @description The photo was successfully retrieved. */
      200: {
        content: {
          "image/jpeg": string;
          "image/png": string;
        };
      };
      /** @description The batch does not exist, or does not have a photo with the requested ID. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Deletes a photo from a seedling batch. */
  deleteBatchPhoto: {
    parameters: {
      path: {
        batchId: number;
        photoId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The batch does not exist, or does not have a photo with the requested ID. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a single seedling batch. */
  getBatch: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["BatchResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Updates non-quantity-related details about a batch. */
  updateBatch: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateBatchRequestPayload"];
      };
    };
    responses: {
      /** @description The batch was updated successfully. Response includes fields populated or modified by the server as a result of the update. */
      200: {
        content: {
          "application/json": components["schemas"]["BatchResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The requested resource has a newer version and was not updated. */
      412: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Deletes an existing seedling batch from a nursery. */
  deleteBatch: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Changes the statuses of seedlings in a batch.
   * @description There must be enough seedlings available to move to the next status.
   */
  changeBatchStatuses: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ChangeBatchStatusRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["BatchResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The requested resource has a newer version and was not updated. */
      412: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Updates the remaining quantities in a seedling batch.
   * @description This should not be used to record withdrawals; use the withdrawal API for that.
   */
  updateBatchQuantities: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateBatchQuantitiesRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["BatchResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The requested resource has a newer version and was not updated. */
      412: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets a summary of the numbers of plants in a nursery. */
  getNurserySummary: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNurserySummaryResponsePayload"];
        };
      };
    };
  };
  /** Gets a summary of the numbers of plants of each species in all nurseries. */
  getSpeciesSummary: {
    parameters: {
      path: {
        speciesId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesSummaryResponsePayload"];
        };
      };
    };
  };
  /** Withdraws seedlings from one or more seedling batches at a nursery. */
  createBatchWithdrawal: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateNurseryWithdrawalRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNurseryWithdrawalResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a specific nursery withdrawal. */
  getNurseryWithdrawal: {
    parameters: {
      path: {
        withdrawalId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNurseryWithdrawalResponsePayload"];
        };
      };
    };
  };
  /** Lists all the photos of a withdrawal. */
  listWithdrawalPhotos: {
    parameters: {
      path: {
        withdrawalId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListWithdrawalPhotosResponsePayload"];
        };
      };
      /** @description The withdrawal does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Creates a new photo of a seedling batch withdrawal. */
  uploadWithdrawalPhoto: {
    parameters: {
      path: {
        withdrawalId: number;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateNurseryWithdrawalPhotoResponsePayload"];
        };
      };
    };
  };
  /**
   * Retrieves a specific photo from a withdrawal.
   * @description Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio.
   */
  getWithdrawalPhoto: {
    parameters: {
      query?: {
        /** @description Maximum desired width in pixels. If neither this nor maxHeight is specified, the full-sized original image will be returned. If this is specified, an image no wider than this will be returned. The image may be narrower than this value if needed to preserve the aspect ratio of the original. */
        maxWidth?: string;
        /** @description Maximum desired height in pixels. If neither this nor maxWidth is specified, the full-sized original image will be returned. If this is specified, an image no taller than this will be returned. The image may be shorter than this value if needed to preserve the aspect ratio of the original. */
        maxHeight?: string;
      };
      path: {
        withdrawalId: number;
        photoId: number;
      };
    };
    responses: {
      /** @description The photo was successfully retrieved. */
      200: {
        content: {
          "image/jpeg": string;
          "image/png": string;
        };
      };
      /** @description The withdrawal does not exist, or does not have a photo with the requested ID. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Undoes a withdrawal.
   * @description The withdrawal's plants will be returned to their original batches. Nursery transfers may not be undone. If the withdrawal was an outplanting to a planting site, the plants will be removed from the planting site's plant totals. This does not delete the original withdrawal.
   */
  undoBatchWithdrawal: {
    parameters: {
      path: {
        withdrawalId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The withdrawal does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The withdrawal is not eligible for undo, e.g., because it has already been undone or because it is a nursery transfer. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Lists all organizations.
   * @description Lists all organizations the user can access.
   */
  listOrganizations: {
    parameters: {
      query?: {
        /** @description Return this level of information about the organization's contents. */
        depth?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListOrganizationsResponsePayload"];
        };
      };
    };
  };
  /** Creates a new organization. */
  createOrganization: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateOrganizationRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetOrganizationResponsePayload"];
        };
      };
    };
  };
  /** Gets information about an organization. */
  getOrganization: {
    parameters: {
      query?: {
        /** @description Return this level of information about the organization's contents. */
        depth?: string;
      };
      path: {
        /** @description ID of organization to get. User must be a member of the organization. */
        organizationId: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetOrganizationResponsePayload"];
        };
      };
    };
  };
  /** Updates an existing organization. */
  updateOrganization: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateOrganizationRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Deletes an existing organization.
   * @description Organizations can only be deleted if they have no members other than the current user.
   */
  deleteOrganization: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The organization has other members and cannot be deleted. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Lists the roles in an organization. */
  listOrganizationRoles: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListOrganizationRolesResponsePayload"];
        };
      };
    };
  };
  /** Lists the users in an organization. */
  listOrganizationUsers: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListOrganizationUsersResponsePayload"];
        };
      };
    };
  };
  /** Adds a user to an organization. */
  addOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AddOrganizationUserRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateOrganizationUserResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a user's membership in an organization. */
  getOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
        userId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetOrganizationUserResponsePayload"];
        };
      };
    };
  };
  /**
   * Updates the user's organization information.
   * @description Only includes organization-level information that can be modified by organization administrators.
   */
  updateOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
        userId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateOrganizationUserRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The user is not a member of the organization. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description An organization must have at least one owner; cannot change the role of an organization's only owner. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Removes a user from an organization.
   * @description Does not remove any data created by the user.
   */
  deleteOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
        userId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The user is not a member of the organization. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The user is the organization's only owner and an organization must have at least one owner. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Lists accessible projects. */
  listProjects: {
    parameters: {
      query?: {
        /** @description If specified, list projects in this organization. If absent, list projects in all the user's organizations. */
        organizationId?: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListProjectsResponsePayload"];
        };
      };
    };
  };
  /** Creates a new project. */
  createProject: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateProjectRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateProjectResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a specific project. */
  getProject: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetProjectResponsePayload"];
        };
      };
    };
  };
  /** Updates information about an existing project. */
  updateProject: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateProjectRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Deletes an existing project.
   * @description Any accessions, seedling batches, or planting sites that were assigned to the project will no longer be assigned to any project.
   */
  deleteProject: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Assigns multiple entities to a project.
   * @description Overwrites any existing project assignments.
   */
  assignProject: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AssignProjectRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Gets modules for a project. */
  listModules: {
    parameters: {
      path: {
        projectId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetProjectModulesResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets one module for a project. */
  getModule: {
    parameters: {
      path: {
        projectId: number;
        moduleId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetProjectModuleResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Lists an organization's reports. */
  listReports: {
    parameters: {
      query: {
        organizationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListReportsResponsePayload"];
        };
      };
    };
  };
  /** Gets the report settings for an organization. */
  getReportSettings: {
    parameters: {
      query: {
        organizationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetReportSettingsResponsePayload"];
        };
      };
    };
  };
  /** Updates the report settings for an organization. */
  updateReportSettings: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateReportSettingsRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Retrieves the contents of a report. */
  getReport: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetReportResponsePayload"];
        };
      };
    };
  };
  /**
   * Updates a report.
   * @description The report must be locked by the current user.
   */
  updateReport: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PutReportRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The report is not locked by the current user. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Lists the files associated with a report. */
  listReportFiles: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListReportFilesResponsePayload"];
        };
      };
    };
  };
  /**
   * Locks a report.
   * @description Only succeeds if the report is not currently locked or if it is locked by the current user.
   */
  lockReport: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description The report is now locked by the current user. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The report was already locked by another user. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Locks a report even if it is locked by another user already. */
  forceLockReport: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description The report is now locked by the current user. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Lists the photos associated with a report. */
  listReportPhotos: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListReportPhotosResponsePayload"];
        };
      };
    };
  };
  /**
   * Submits a report.
   * @description The report must be locked by the current user. Submitting a report releases the lock. Once a report is submitted, it may no longer be locked or updated.
   */
  submitReport: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The report is missing required information and can't be submitted. */
      400: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The report is not locked by the current user or has already been submitted. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Releases the lock on a report. */
  unlockReport: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description The report is no longer locked. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The report is locked by another user. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Uploads a file to associate with a report. */
  uploadReportFile: {
    parameters: {
      path: {
        reportId: number;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UploadReportFileResponsePayload"];
        };
      };
    };
  };
  /** Downloads a file associated with a report. */
  downloadReportFile: {
    parameters: {
      path: {
        reportId: number;
        fileId: number;
      };
    };
    responses: {
      /** @description The file was successfully retrieved. */
      200: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  /** Deletes a file from a report. */
  deleteReportFile: {
    parameters: {
      path: {
        reportId: number;
        fileId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Uploads a photo to include with a report. */
  uploadReportPhoto: {
    parameters: {
      path: {
        reportId: number;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UploadReportFileResponsePayload"];
        };
      };
    };
  };
  /**
   * Gets the contents of a photo.
   * @description Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio.
   */
  getReportPhoto: {
    parameters: {
      query?: {
        /** @description Maximum desired width in pixels. If neither this nor maxHeight is specified, the full-sized original image will be returned. If this is specified, an image no wider than this will be returned. The image may be narrower than this value if needed to preserve the aspect ratio of the original. */
        maxWidth?: string;
        /** @description Maximum desired height in pixels. If neither this nor maxWidth is specified, the full-sized original image will be returned. If this is specified, an image no taller than this will be returned. The image may be shorter than this value if needed to preserve the aspect ratio of the original. */
        maxHeight?: string;
      };
      path: {
        reportId: number;
        photoId: number;
      };
    };
    responses: {
      /** @description The photo was successfully retrieved. */
      200: {
        content: {
          "image/jpeg": string;
          "image/png": string;
        };
      };
    };
  };
  /** Updates a photo's caption. */
  updateReportPhoto: {
    parameters: {
      path: {
        reportId: number;
        photoId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateReportPhotoRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Deletes a photo from a report. */
  deleteReportPhoto: {
    parameters: {
      path: {
        reportId: number;
        photoId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Exports selected fields from data matching a set of search criteria.
   * @description If a sublist field has multiple values, they are separated with line breaks in the exported file.
   */
  search_1: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SearchRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SearchResponsePayload"];
          "text/csv": string;
        };
      };
    };
  };
  /** Search for distinct values from data matching a set of search criteria. */
  searchDistinctValues: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SearchRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SearchValuesResponsePayload"];
        };
      };
    };
  };
  /** Deletes an existing accession. */
  delete: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Marks an accession as checked in. */
  checkIn: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets the history of changes to an accession. */
  getAccessionHistory: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetAccessionHistoryResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** List all the available photos for an accession. */
  listPhotos: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description The accession's photos are listed in the response. */
      200: {
        content: {
          "application/json": components["schemas"]["ListPhotosResponsePayload"];
        };
      };
      /** @description The accession does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Retrieve a specific photo from an accession.
   * @description Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio.
   */
  getPhoto: {
    parameters: {
      query?: {
        /** @description Maximum desired width in pixels. If neither this nor maxHeight is specified, the full-sized original image will be returned. If this is specified, an image no wider than this will be returned. The image may be narrower than this value if needed to preserve the aspect ratio of the original. */
        maxWidth?: string;
        /** @description Maximum desired height in pixels. If neither this nor maxWidth is specified, the full-sized original image will be returned. If this is specified, an image no taller than this will be returned. The image may be shorter than this value if needed to preserve the aspect ratio of the original. */
        maxHeight?: string;
      };
      path: {
        id: number;
        photoFilename: string;
      };
    };
    responses: {
      /** @description The photo was successfully retrieved. */
      200: {
        content: {
          "image/jpeg": string;
          "image/png": string;
        };
      };
      /** @description The accession does not exist, or does not have a photo with the requested filename. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Upload a new photo for an accession.
   * @description If there was already a photo with the specified filename, replaces it.
   */
  uploadPhoto: {
    parameters: {
      path: {
        id: number;
        photoFilename: string;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The specified accession does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Delete one photo for an accession. */
  deletePhoto: {
    parameters: {
      path: {
        id: number;
        photoFilename: string;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The accession does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Get the server's current date and time.
   * @description In test environments, the clock can be advanced artificially, which will cause it to differ from the real-world date and time.
   */
  getCurrentTime: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetCurrentTimeResponsePayload"];
        };
      };
    };
  };
  /** Records a log message from a device at a seed bank. */
  recordLogMessage: {
    parameters: {
      path: {
        /**
         * @description Source of the log message.
         * @example seedbank-app
         */
        tag: string;
      };
    };
    requestBody: {
      content: {
        "application/json": string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: never;
      };
    };
  };
  /** Get summary statistics about a specific seed bank or all seed banks within an organization. */
  getSeedBankSummary: {
    parameters: {
      query?: {
        /** @description If set, return summary on all seedbanks for that organization. */
        organizationId?: string;
        /** @description If set, return summary on that specific seedbank. */
        facilityId?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SummaryResponsePayload"];
        };
      };
    };
  };
  /** Get summary statistics about accessions that match a specified set of search criteria. */
  summarizeAccessionSearch: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SummarizeAccessionSearchRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SummarizeAccessionSearchResponsePayload"];
        };
      };
    };
  };
  /** List the values of a set of search fields for a set of accessions matching certain filter criteria. */
  listFieldValues: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ListFieldValuesRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListFieldValuesResponsePayload"];
        };
      };
    };
  };
  /** Lists all the species available in an organization. */
  listSpecies: {
    parameters: {
      query: {
        /** @description Organization whose species should be listed. */
        organizationId: string;
        /** @description Only list species that are currently used in the organization's inventory, accessions or planting sites. */
        inUse?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListSpeciesResponsePayload"];
        };
      };
    };
  };
  /** Creates a new species. */
  createSpecies: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SpeciesRequestPayload"];
      };
    };
    responses: {
      /** @description Species created. */
      200: {
        content: {
          "application/json": components["schemas"]["CreateSpeciesResponsePayload"];
        };
      };
      /** @description A species with the requested name already exists. */
      409: {
        content: {
          "application/json": components["schemas"]["CreateSpeciesResponsePayload"];
        };
      };
    };
  };
  /** Gets more information about a species with a particular scientific name. */
  getSpeciesDetails: {
    parameters: {
      query: {
        /** @description Exact scientific name to look up. This name is case-sensitive. */
        scientificName: string;
        /**
         * @description If specified, only return common names in this language or whose language is unknown. Names with unknown languages are always included. This is a two-letter ISO 639-1 language code.
         * @example en
         */
        language?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SpeciesLookupDetailsResponsePayload"];
        };
      };
      /** @description The scientific name was not found in the server's taxonomic database. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** @description Gets a list of known scientific names whose words begin with particular letters. */
  listSpeciesNames: {
    parameters: {
      query: {
        /**
         * @description Space-delimited list of word prefixes to search for. Non-alphabetic characters are ignored, and matches are case-insensitive. The order of prefixes is significant; "ag sc" will match "Aglaonema schottianum" but won't match "Scabiosa agrestis".
         * @example ag sc
         */
        search: string;
        /** @description Maximum number of results to return. */
        maxResults?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SpeciesLookupNamesResponsePayload"];
        };
      };
    };
  };
  /** @description Returns details about a problem with a species. */
  getSpeciesProblem: {
    parameters: {
      path: {
        problemId: number;
      };
    };
    responses: {
      /** @description Problem retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesProblemResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Applies suggested changes to fix a problem with a species.
   * @description Only valid for problems that include suggested changes.
   */
  acceptProblemSuggestion: {
    parameters: {
      path: {
        problemId: number;
      };
    };
    responses: {
      /** @description Suggestion applied. Response contains the updated species information. */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description There is no suggested change for this problem. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Deletes information about a problem with a species without applying any suggested changes. */
  deleteProblem: {
    parameters: {
      path: {
        problemId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Uploads a list of species to add to the organization.
   * @description The uploaded file must be in CSV format. A template with the correct headers may be downloaded from the `/api/v1/species/uploads/template` endpoint.
   */
  uploadSpeciesList: {
    parameters: {
      query: {
        organizationId: number;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
    responses: {
      /** @description The file has been successfully received. It will be processed asynchronously; use the ID returned in the response payload to poll for its status using the `/api/v1/species/uploads/{uploadId}` GET endpoint. */
      200: {
        content: {
          "application/json": components["schemas"]["UploadFileResponsePayload"];
        };
      };
    };
  };
  /** Gets a template file that contains the required header row for species list uploads. */
  getSpeciesListUploadTemplate: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": string;
        };
      };
    };
  };
  /**
   * Gets the status of a species list uploaded previously.
   * @description Clients may poll this endpoint to monitor the progress of the file.
   */
  getSpeciesListUploadStatus: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetUploadStatusResponsePayload"];
        };
      };
    };
  };
  /**
   * Deletes a species list upload that is awaiting user action.
   * @description This may only be called if the status of the upload is "Awaiting User Action".
   */
  deleteSpeciesListUpload: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The upload was not awaiting user action. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Resolves the problems with a species list that is awaiting user action.
   * @description This may only be called if the status of the upload is "Awaiting User Action".
   */
  resolveSpeciesListUpload: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ResolveUploadRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The upload was not awaiting user action. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a single species. */
  getSpecies: {
    parameters: {
      query: {
        /** @description Organization whose information about the species should be returned. */
        organizationId: string;
      };
      path: {
        speciesId: number;
      };
    };
    responses: {
      /** @description Species retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Updates an existing species. */
  updateSpecies: {
    parameters: {
      path: {
        speciesId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SpeciesRequestPayload"];
      };
    };
    responses: {
      /** @description Species updated or merged with an existing species. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Deletes an existing species.
   * @description The species will no longer appear in the organization's list of species, but existing data (plants, seeds, etc.) that refer to the species will still refer to it.
   */
  deleteSpecies: {
    parameters: {
      path: {
        speciesId: number;
      };
    };
    responses: {
      /** @description Species deleted. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description Cannot delete the species because it is currently in use. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Lists support request types. */
  listRequestTypes: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListSupportRequestTypesResponsePayload"];
        };
      };
    };
  };
  /** Submit support request types. */
  submitRequest: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SubmitSupportRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SubmitSupportRequestResponsePayload"];
        };
      };
    };
  };
  /**
   * Upload a temporary attachment.
   * @description Uploads an attachment, which can be assigned to a support request during submission.
   */
  uploadAttachment: {
    requestBody?: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UploadAttachmentResponsePayload"];
        };
      };
      /** @description The request was too large. */
      413: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The media type is not supported. */
      415: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Lists the timeseries for one or more devices. */
  listTimeseries: {
    parameters: {
      query: {
        deviceId: number[];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListTimeseriesResponsePayload"];
        };
      };
    };
  };
  /**
   * Defines a list of timeseries for one or more devices.
   * @description If there are existing timeseries with the same names, the old definitions will be overwritten.
   */
  createMultipleTimeseries: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateTimeseriesRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Records new values for one or more timeseries. */
  recordTimeseriesValues: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["RecordTimeseriesValuesRequestPayload"];
      };
    };
    responses: {
      /** @description Successfully processed the request. Note that this status will be returned even if the server was unable to record some of the values. In that case, the failed values will be returned in the response payload. */
      200: {
        content: {
          "application/json": components["schemas"]["RecordTimeseriesValuesResponsePayload"];
        };
      };
      /** @description The request was valid, but the user is still configuring or placing sensors, so the timeseries values have not been recorded. */
      202: {
        content: {
          "application/json": components["schemas"]["RecordTimeseriesValuesResponsePayload"];
        };
      };
      /** @description The request had more than 1000 values. */
      413: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a specific delivery of seedlings to a planting site. */
  getDelivery: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetDeliveryResponsePayload"];
        };
      };
    };
  };
  /** Reassigns some of the seedlings from a delivery to a different planting subzone. */
  reassignDelivery: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ReassignDeliveryRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Saves a draft of an in-progress planting site. */
  createDraftPlantingSite: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateDraftPlantingSiteRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateDraftPlantingSiteResponsePayload"];
        };
      };
    };
  };
  /** Gets the details of a saved draft of a planting site. */
  getDraftPlantingSite: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetDraftPlantingSiteResponsePayload"];
        };
      };
    };
  };
  /** Updates an existing draft of an in-progress planting site. */
  updateDraftPlantingSite: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateDraftPlantingSiteRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Deletes an existing draft of an in-progress planting site. */
  deleteDraftPlantingSite: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Gets an API token to use for displaying Mapbox maps.
   * @description Mapbox API tokens are short-lived; when a token expires, request a new one.
   */
  getMapboxToken: {
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetMapboxTokenResponsePayload"];
        };
      };
      /** @description The server is not configured to return Mapbox tokens. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The server is temporarily unable to generate a new Mapbox token. */
      503: {
        content: {
          "application/json": components["schemas"]["GetMapboxTokenResponsePayload"];
        };
      };
    };
  };
  /** Gets a list of observations of planting sites. */
  listObservations: {
    parameters: {
      query?: {
        /** @description Limit results to observations of planting sites in a specific organization. Ignored if plantingSiteId is specified. */
        organizationId?: string;
        /** @description Limit results to observations of a specific planting site. Required if organizationId is not specified. */
        plantingSiteId?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListObservationsResponsePayload"];
        };
      };
    };
  };
  /** Schedules a new observation. */
  scheduleObservation: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ScheduleObservationRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ScheduleObservationResponsePayload"];
        };
      };
    };
  };
  /** Gets a list of the results of observations. */
  listObservationResults: {
    parameters: {
      query?: {
        organizationId?: number;
        plantingSiteId?: number;
        /** @description Maximum number of results to return. Results are always returned in order of completion time, newest first, so setting this to 1 will return the results of the most recently completed observation. */
        limit?: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListObservationResultsResponsePayload"];
        };
      };
    };
  };
  /** Gets information about a single observation. */
  getObservation: {
    parameters: {
      path: {
        observationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetObservationResponsePayload"];
        };
      };
    };
  };
  /** Reschedules an existing observation. */
  rescheduleObservation: {
    parameters: {
      path: {
        observationId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RescheduleObservationRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Gets a list of monitoring plots assigned to an observation. */
  listAssignedPlots: {
    parameters: {
      path: {
        observationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListAssignedPlotsResponsePayload"];
        };
      };
    };
  };
  /** Updates information about the observation of a plot. */
  updatePlotObservation: {
    parameters: {
      path: {
        observationId: number;
        plotId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdatePlotObservationRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Stores the results of a completed observation of a plot. */
  completePlotObservation: {
    parameters: {
      path: {
        observationId: number;
        plotId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CompletePlotObservationRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The observation of the plot was already completed. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Claims a monitoring plot.
   * @description A plot may only be claimed by one user at a time.
   */
  claimMonitoringPlot: {
    parameters: {
      path: {
        observationId: number;
        plotId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The plot is already claimed by someone else. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Uploads a photo of a monitoring plot. */
  uploadPlotPhoto: {
    parameters: {
      path: {
        observationId: number;
        plotId: number;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
          payload: components["schemas"]["UploadPlotPhotoRequestPayload"];
        };
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UploadPlotPhotoResponsePayload"];
        };
      };
    };
  };
  /**
   * Retrieves a specific photo from an observation of a monitoring plot.
   * @description Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio.
   */
  getPlotPhoto: {
    parameters: {
      query?: {
        /** @description Maximum desired width in pixels. If neither this nor maxHeight is specified, the full-sized original image will be returned. If this is specified, an image no wider than this will be returned. The image may be narrower than this value if needed to preserve the aspect ratio of the original. */
        maxWidth?: number;
        /** @description Maximum desired height in pixels. If neither this nor maxWidth is specified, the full-sized original image will be returned. If this is specified, an image no taller than this will be returned. The image may be shorter than this value if needed to preserve the aspect ratio of the original. */
        maxHeight?: number;
      };
      path: {
        observationId: number;
        plotId: number;
        fileId: number;
      };
    };
    responses: {
      /** @description The photo was successfully retrieved. */
      200: {
        content: {
          "image/jpeg": string;
          "image/png": string;
        };
      };
      /** @description The plot observation does not exist, or does not have a photo with the requested ID. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Releases the claim on a monitoring plot. */
  releaseMonitoringPlot: {
    parameters: {
      path: {
        observationId: number;
        plotId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description You don't have a claim on the plot. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Requests that a monitoring plot be replaced with a new one.
   * @description Additional monitoring plots may be replaced as well, e.g., if the requested plot is part of a permanent cluster. In some cases, the requested plot will be removed from the observation but not replaced with a different one.
   */
  replaceObservationPlot: {
    parameters: {
      path: {
        observationId: number;
        plotId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ReplaceObservationPlotRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["ReplaceObservationPlotResponsePayload"];
        };
      };
      /** @description The observation does not exist or does not have the requested monitoring plot. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description The observation of the monitoring plot has already been completed and the plot cannot be replaced. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Gets the results of an observation of a planting site.
   * @description Some information is only available once all plots have been completed.
   */
  getObservationResults: {
    parameters: {
      path: {
        observationId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetObservationResultsResponsePayload"];
        };
      };
    };
  };
  /**
   * Gets a list of an organization's planting sites.
   * @description The list can optionally contain information about planting zones and subzones.
   */
  listPlantingSites: {
    parameters: {
      query: {
        organizationId: number;
        /** @description If true, include planting zones and subzones for each site. */
        full?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListPlantingSitesResponsePayload"];
        };
      };
    };
  };
  /** Creates a new planting site. */
  createPlantingSite: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreatePlantingSiteRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreatePlantingSiteResponsePayload"];
        };
      };
    };
  };
  /** Validates the definition of a new planting site. */
  validatePlantingSite: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreatePlantingSiteRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ValidatePlantingSiteResponsePayload"];
        };
      };
    };
  };
  /**
   * Gets information about a specific planting site.
   * @description Includes information about the site's planting zones and subzones.
   */
  getPlantingSite: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetPlantingSiteResponsePayload"];
        };
      };
    };
  };
  /** Updates information about an existing planting site. */
  updatePlantingSite: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdatePlantingSiteRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Deletes a planting site.
   * @description Planting site should not have any plantings.
   */
  deletePlantingSite: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The planting site is in use, e.g., there are plantings allocated to the site. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Gets the total number of plants planted at a planting site and in each planting zone.
   * @description The totals are based on nursery withdrawals.
   */
  getPlantingSiteReportedPlants: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetPlantingSiteReportedPlantsResponsePayload"];
        };
      };
    };
  };
  /** Updates information about a planting subzone. */
  updatePlantingSubzone: {
    parameters: {
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdatePlantingSubzoneRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Gets a list of the species that have been planted in a specific planting subzone.
   * @description The list is based on nursery withdrawals.
   */
  listPlantingSubzoneSpecies: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListPlantingSubzoneSpeciesResponsePayload"];
        };
      };
    };
  };
  /** Gets a user by some criteria, for now only email is available */
  searchUsers: {
    parameters: {
      query: {
        /** @description The email to use when searching for a user */
        email: string;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetUserResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets information about the current user. */
  getMyself: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetUserResponsePayload"];
        };
      };
    };
  };
  /** Updates information about the current user. */
  updateMyself: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateUserRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /**
   * Deletes the current user's account.
   * @description WARNING! This operation is not reversible.
   */
  deleteMyself: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Updates the current user's cookie consent selection. */
  updateCookieConsent: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateUserCookieConsentRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Gets the current user's preferences. */
  getUserPreferences: {
    parameters: {
      query?: {
        /** @description If present, get the user's per-organization preferences for this organization. If not present, get the user's global preferences. */
        organizationId?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetUserPreferencesResponsePayload"];
        };
      };
    };
  };
  /** Updates the current user's preferences. */
  updateUserPreferences: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateUserPreferencesRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Get a user by ID, if they exist, only ordinary users are supported. */
  getUser: {
    parameters: {
      path: {
        userId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetUserResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Get the list of deliverable categories assigned to a user. */
  getUserDeliverableCategories: {
    parameters: {
      path: {
        userId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["GetUserDeliverableCategoriesResponsePayload"];
        };
      };
    };
  };
  /** Update which deliverable categories are assigned to a user. */
  updateUserDeliverableCategories: {
    parameters: {
      path: {
        userId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateUserDeliverableCategoriesRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** Apply the supplied global roles to the user. */
  updateGlobalRoles: {
    parameters: {
      path: {
        userId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateGlobalRolesRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponsePayload"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets the minimum and recommended versions for Terraware's client applications. */
  getVersions: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["VersionsResponsePayload"];
        };
      };
    };
  };
  /** Creates a new accession. */
  createAccession: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateAccessionRequestPayloadV2"];
      };
    };
    responses: {
      /** @description The accession was created successfully. Response includes fields populated by the server, including the accession number and ID. */
      200: {
        content: {
          "application/json": components["schemas"]["CreateAccessionResponsePayloadV2"];
        };
      };
    };
  };
  /**
   * Uploads a list of accessions to add to the facility.
   * @description The uploaded file must be in CSV format. A template with the correct headers may be downloaded from the `/api/v2/seedbank/accessions/uploads/template` endpoint.
   */
  uploadAccessionsList: {
    parameters: {
      query: {
        facilityId: number;
      };
    };
    requestBody?: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          file: string;
        };
      };
    };
    responses: {
      /** @description The file has been successfully received. It will be processed asynchronously; use the ID returned in the response payload to poll for its status using the `/api/v2/seedbank/accessions/uploads/{uploadId}` GET endpoint. */
      200: {
        content: {
          "application/json": components["schemas"]["UploadFileResponsePayload"];
        };
      };
    };
  };
  /** Gets a template file that contains the required header row for accessions list uploads. */
  getAccessionsListUploadTemplate: {
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": string;
        };
      };
    };
  };
  /**
   * Gets the status of an accessions list uploaded previously.
   * @description Clients may poll this endpoint to monitor the progress of the file.
   */
  getAccessionsListUploadStatus: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetUploadStatusResponsePayload"];
        };
      };
    };
  };
  /**
   * Deletes an accessions list upload that is awaiting user action.
   * @description This may only be called if the status of the upload is "Awaiting User Action".
   */
  deleteAccessionsListUpload: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The upload was not awaiting user action. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /**
   * Resolves the problems with an accessions list that is awaiting user action.
   * @description This may only be called if the status of the upload is "Awaiting User Action".
   */
  resolveAccessionsListUpload: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ResolveUploadRequestPayload"];
      };
    };
    responses: {
      /** @description The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** @description The upload was not awaiting user action. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Transfers seeds to a nursery. */
  createNurseryTransferWithdrawal: {
    parameters: {
      path: {
        accessionId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateNurseryTransferRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateNurseryTransferResponsePayload"];
        };
      };
    };
  };
  /** List all of the accession's viability tests. */
  listViabilityTests: {
    parameters: {
      path: {
        accessionId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListViabilityTestsResponsePayload"];
        };
      };
    };
  };
  /**
   * Create a new viability test on an existing accession.
   * @description May cause the accession's remaining quantity to change.
   */
  createViabilityTest: {
    parameters: {
      path: {
        accessionId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateViabilityTestRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
  };
  /** Get a single viability test. */
  getViabilityTest: {
    parameters: {
      path: {
        accessionId: number;
        viabilityTestId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetViabilityTestResponsePayload"];
        };
      };
    };
  };
  /**
   * Update the details of an existing viability test.
   * @description May cause the accession's remaining quantity to change.
   */
  updateViabilityTest: {
    parameters: {
      path: {
        accessionId: number;
        viabilityTestId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateViabilityTestRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
  };
  /**
   * Delete an existing viability test.
   * @description May cause the accession's remaining quantity to change.
   */
  deleteViabilityTest: {
    parameters: {
      path: {
        accessionId: number;
        viabilityTestId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
  };
  /** List all the withdrawals from an accession. */
  listWithdrawals: {
    parameters: {
      path: {
        accessionId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetWithdrawalsResponsePayload"];
        };
      };
    };
  };
  /**
   * Create a new withdrawal on an existing accession.
   * @description May cause the accession's remaining quantity to change.
   */
  createWithdrawal: {
    parameters: {
      path: {
        accessionId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateWithdrawalRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
  };
  /** Get a single withdrawal. */
  getWithdrawal: {
    parameters: {
      path: {
        accessionId: number;
        withdrawalId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetWithdrawalResponsePayload"];
        };
      };
    };
  };
  /**
   * Update the details of an existing withdrawal.
   * @description May cause the accession's remaining quantity to change.
   */
  updateWithdrawal: {
    parameters: {
      path: {
        accessionId: number;
        withdrawalId: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateWithdrawalRequestPayload"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
  };
  /**
   * Delete an existing withdrawal.
   * @description May cause the accession's remaining quantity to change.
   */
  deleteWithdrawal: {
    parameters: {
      path: {
        accessionId: number;
        withdrawalId: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
  };
  /** Retrieve an existing accession. */
  getAccession: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetAccessionResponsePayloadV2"];
        };
      };
      /** @description The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Update an existing accession. */
  updateAccession: {
    parameters: {
      query?: {
        /** @description If true, do not actually save the accession; just return the result that would have been returned if it had been saved. */
        simulate?: string;
      };
      path: {
        id: number;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateAccessionRequestPayloadV2"];
      };
    };
    responses: {
      /** @description The accession was updated successfully. Response includes fields populated or modified by the server as a result of the update. */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
      /** @description The specified accession doesn't exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** @description One of the requested changes couldn't be made because the accession is in a state that doesn't allow the change. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
}
