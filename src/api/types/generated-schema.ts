/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/api/v1/automations": {
    get: operations["listAutomations_2"];
    post: operations["createAutomation_2"];
  };
  "/api/v1/automations/{automationId}": {
    get: operations["getAutomation_2"];
    put: operations["updateAutomation_2"];
    delete: operations["deleteAutomation_2"];
  };
  "/api/v1/automations/{automationId}/trigger": {
    post: operations["postAutomationTrigger"];
  };
  "/api/v1/devices": {
    post: operations["createDevice"];
  };
  "/api/v1/devices/managers": {
    get: operations["getDeviceManagers"];
  };
  "/api/v1/devices/managers/{deviceManagerId}": {
    get: operations["getDeviceManager"];
  };
  "/api/v1/devices/managers/{deviceManagerId}/connect": {
    post: operations["connectDeviceManager"];
  };
  "/api/v1/devices/templates": {
    get: operations["listDeviceTemplates"];
  };
  "/api/v1/devices/{id}": {
    get: operations["getDevice"];
    put: operations["updateDevice"];
  };
  "/api/v1/devices/{id}/unresponsive": {
    /** Notifies the appropriate users so they can troubleshoot the problem. */
    post: operations["deviceUnresponsive"];
  };
  "/api/v1/facilities": {
    get: operations["listAllFacilities_1"];
    post: operations["createFacility_1"];
  };
  "/api/v1/facilities/{facilityId}": {
    get: operations["getFacility"];
    put: operations["updateFacility"];
  };
  "/api/v1/facilities/{facilityId}/alert/send": {
    post: operations["sendFacilityAlert"];
  };
  "/api/v1/facilities/{facilityId}/automations": {
    get: operations["listAutomations_1"];
    post: operations["createAutomation_1"];
  };
  "/api/v1/facilities/{facilityId}/automations/{automationId}": {
    get: operations["getAutomation_1"];
    put: operations["updateAutomation_1"];
    delete: operations["deleteAutomation_1"];
  };
  "/api/v1/facilities/{facilityId}/configured": {
    /** After connecting a device manager and finishing any necessary configuration of the facility's devices, send this request to enable processing of timeseries values and alerts from the device manager. Only valid if the facility's connection state is `Connected`. */
    post: operations["postConfigured_1"];
  };
  "/api/v1/facilities/{facilityId}/devices": {
    get: operations["listFacilityDevices"];
  };
  "/api/v1/facility": {
    get: operations["listAllFacilities"];
    post: operations["createFacility"];
  };
  "/api/v1/facility/{facilityId}": {
    get: operations["getFacility_1"];
    put: operations["updateFacility_1"];
  };
  "/api/v1/facility/{facilityId}/alert/send": {
    post: operations["sendFacilityAlert_1"];
  };
  "/api/v1/facility/{facilityId}/automations": {
    get: operations["listAutomations"];
    post: operations["createAutomation"];
  };
  "/api/v1/facility/{facilityId}/automations/{automationId}": {
    get: operations["getAutomation"];
    put: operations["updateAutomation"];
    delete: operations["deleteAutomation"];
  };
  "/api/v1/facility/{facilityId}/configured": {
    /** After connecting a device manager and finishing any necessary configuration of the facility's devices, send this request to enable processing of timeseries values and alerts from the device manager. Only valid if the facility's connection state is `Connected`. */
    post: operations["postConfigured"];
  };
  "/api/v1/facility/{facilityId}/devices": {
    get: operations["listFacilityDevices_1"];
  };
  "/api/v1/login": {
    /** For interactive web applications, this can be used to redirect the user to a login page to allow the application to make other API requests. The login process will set a cookie that will authenticate to the API, and will then redirect back to the application. One approach is to use this in error response handlers: if an API request returns HTTP 401 Unauthorized, set location.href to this endpoint and set "redirect" to the URL of the page the user was on so they'll return there after logging in. */
    get: operations["login"];
  };
  "/api/v1/notifications": {
    get: operations["readAll"];
    put: operations["markAllRead"];
  };
  "/api/v1/notifications/count": {
    get: operations["count"];
  };
  "/api/v1/notifications/{id}": {
    get: operations["read_1"];
    put: operations["markRead"];
  };
  "/api/v1/organizations": {
    /** Lists all organizations the user can access. */
    get: operations["listOrganizations"];
    post: operations["createOrganization"];
  };
  "/api/v1/organizations/{organizationId}": {
    get: operations["getOrganization"];
    put: operations["updateOrganization"];
    /** Organizations can only be deleted if they have no members other than the current user. */
    delete: operations["deleteOrganization"];
  };
  "/api/v1/organizations/{organizationId}/roles": {
    get: operations["listOrganizationRoles"];
  };
  "/api/v1/organizations/{organizationId}/users": {
    get: operations["listOrganizationUsers"];
    post: operations["addOrganizationUser"];
  };
  "/api/v1/organizations/{organizationId}/users/{userId}": {
    get: operations["getOrganizationUser"];
    /** Only includes organization-level information that can be modified by organization administrators. */
    put: operations["updateOrganizationUser"];
    /** Does not remove any data created by the user. */
    delete: operations["deleteOrganizationUser"];
  };
  "/api/v1/search": {
    post: operations["search_1"];
  };
  "/api/v1/seedbank/accessions": {
    post: operations["create"];
  };
  "/api/v1/seedbank/accessions/{id}": {
    get: operations["read"];
    put: operations["update"];
    delete: operations["delete"];
  };
  "/api/v1/seedbank/accessions/{id}/checkIn": {
    post: operations["checkIn"];
  };
  "/api/v1/seedbank/accessions/{id}/history": {
    get: operations["getAccessionHistory"];
  };
  "/api/v1/seedbank/accessions/{id}/photos": {
    get: operations["listPhotos"];
  };
  "/api/v1/seedbank/accessions/{id}/photos/{photoFilename}": {
    /** Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio. */
    get: operations["getPhoto"];
    post: operations["uploadPhoto"];
  };
  "/api/v1/seedbank/clock": {
    /** In test environments, the clock can be advanced artificially, which will cause it to differ from the real-world date and time. */
    get: operations["getCurrentTime"];
  };
  "/api/v1/seedbank/log/{tag}": {
    post: operations["recordLogMessage"];
  };
  "/api/v1/seedbank/summary": {
    get: operations["getSeedBankSummary"];
    post: operations["summarizeAccessionSearch"];
  };
  "/api/v1/seedbank/values": {
    post: operations["listFieldValues"];
  };
  "/api/v1/seedbank/values/all": {
    post: operations["listAllFieldValues"];
  };
  "/api/v1/seedbank/values/storageLocation/{facilityId}": {
    get: operations["getStorageLocations"];
  };
  "/api/v1/species": {
    get: operations["listSpecies"];
    post: operations["createSpecies"];
  };
  "/api/v1/species/lookup/details": {
    get: operations["getSpeciesDetails"];
  };
  "/api/v1/species/lookup/names": {
    /** Gets a list of known scientific names whose words begin with particular letters. */
    get: operations["listSpeciesNames"];
  };
  "/api/v1/species/problems/{problemId}": {
    /** Returns details about a problem with a species. */
    get: operations["getSpeciesProblem"];
    /** Only valid for problems that include suggested changes. */
    post: operations["acceptProblemSuggestion"];
    delete: operations["deleteProblem"];
  };
  "/api/v1/species/uploads": {
    /** The uploaded file must be in CSV format. A template with the correct headers may be downloaded from the `/api/v1/species/uploads/template` endpoint. */
    post: operations["uploadSpeciesList"];
  };
  "/api/v1/species/uploads/template": {
    get: operations["getSpeciesListUploadTemplate"];
  };
  "/api/v1/species/uploads/{uploadId}": {
    /** Clients may poll this endpoint to monitor the progress of the file. */
    get: operations["getSpeciesListUploadStatus"];
    /** This may only be called if the status of the upload is "Awaiting User Action". */
    delete: operations["deleteSpeciesListUpload"];
  };
  "/api/v1/species/uploads/{uploadId}/resolve": {
    /** This may only be called if the status of the upload is "Awaiting User Action". */
    post: operations["resolveSpeciesListUpload"];
  };
  "/api/v1/species/{speciesId}": {
    get: operations["getSpecies"];
    put: operations["updateSpecies"];
    /** The species will no longer appear in the organization's list of species, but existing data (plants, seeds, etc.) that refer to the species will still refer to it. */
    delete: operations["deleteSpecies"];
  };
  "/api/v1/timeseries": {
    get: operations["listTimeseries"];
  };
  "/api/v1/timeseries/create": {
    /** If there are existing timeseries with the same names, the old definitions will be overwritten. */
    post: operations["createMultipleTimeseries"];
  };
  "/api/v1/timeseries/history": {
    post: operations["getTimeseriesHistory"];
  };
  "/api/v1/timeseries/values": {
    post: operations["recordTimeseriesValues"];
  };
  "/api/v1/users/me": {
    get: operations["getMyself"];
    put: operations["updateMyself"];
  };
  "/api/v1/users/me/preferences": {
    get: operations["getUserPreferences"];
    put: operations["updateUserPreferences"];
  };
  "/api/v2/seedbank/accessions": {
    post: operations["createAccession"];
  };
  "/api/v2/seedbank/accessions/{accessionId}/viabilityTests": {
    get: operations["listViabilityTests"];
    /** May cause the accession's remaining quantity to change. */
    post: operations["createViabilityTest"];
  };
  "/api/v2/seedbank/accessions/{accessionId}/viabilityTests/{viabilityTestId}": {
    get: operations["getViabilityTest"];
    /** May cause the accession's remaining quantity to change. */
    put: operations["updateViabilityTest"];
    /** May cause the accession's remaining quantity to change. */
    delete: operations["deleteViabilityTest"];
  };
  "/api/v2/seedbank/accessions/{accessionId}/withdrawals": {
    get: operations["listWithdrawals"];
    /** May cause the accession's remaining quantity to change. */
    post: operations["createWithdrawal"];
  };
  "/api/v2/seedbank/accessions/{accessionId}/withdrawals/{withdrawalId}": {
    get: operations["getWithdrawal"];
    /** May cause the accession's remaining quantity to change. */
    put: operations["updateWithdrawal"];
    /** May cause the accession's remaining quantity to change. */
    delete: operations["deleteWithdrawal"];
  };
  "/api/v2/seedbank/accessions/{id}": {
    get: operations["getAccession"];
    put: operations["updateAccession"];
  };
}

export interface components {
  schemas: {
    AccessionHistoryEntryPayload: {
      date: string;
      /** Human-readable description of the event. Does not include date or userName. */
      description: string;
      /** Full name of the person responsible for the event, if known. */
      fullName?: string;
      type:
        | "Created"
        | "QuantityUpdated"
        | "StateChanged"
        | "ViabilityTesting"
        | "Withdrawal";
    };
    AccessionPayload: {
      /** Server-generated human-readable identifier for the accession. This is unique within a single seed bank, but different seed banks may have accessions with the same number. */
      accessionNumber: string;
      /** Server-calculated active indicator. This is based on the accession's state. */
      active: "Inactive" | "Active";
      bagNumbers?: string[];
      checkedInTime?: string;
      collectedDate?: string;
      collectionSiteCity?: string;
      collectionSiteCountryCode?: string;
      collectionSiteCountrySubdivision?: string;
      collectionSiteLandowner?: string;
      collectionSiteName?: string;
      collectionSiteNotes?: string;
      collectionSource?: "Wild" | "Reintroduced" | "Cultivated" | "Other";
      /** Names of the people who collected the seeds. */
      collectors?: string[];
      cutTestSeedsCompromised?: number;
      cutTestSeedsEmpty?: number;
      cutTestSeedsFilled?: number;
      dryingEndDate?: string;
      dryingMoveDate?: string;
      dryingStartDate?: string;
      endangered?: "No" | "Yes" | "Unsure";
      /** @deprecated Backward-compatibility alias for collectionSiteNotes */
      environmentalNotes?: string;
      estimatedSeedCount?: number;
      facilityId: number;
      family?: string;
      fieldNotes?: string;
      founderId?: string;
      geolocations?: components["schemas"]["Geolocation"][];
      /** Server-generated unique identifier for the accession. This is unique across all seed banks, but is not suitable for display to end users. */
      id: number;
      /** Initial size of accession. The units of this value must match the measurement type in "processingMethod". */
      initialQuantity?: components["schemas"]["SeedQuantityPayload"];
      /** @deprecated Backward-compatibility alias for collectionSiteLandowner */
      landowner?: string;
      latestViabilityPercent?: number;
      latestViabilityTestDate?: string;
      numberOfTrees?: number;
      nurseryStartDate?: string;
      photoFilenames?: string[];
      processingMethod?: "Count" | "Weight";
      processingNotes?: string;
      processingStaffResponsible?: string;
      processingStartDate?: string;
      rare?: "No" | "Yes" | "Unsure";
      receivedDate?: string;
      /** Number or weight of seeds remaining for withdrawal and testing. Calculated by the server when the accession's total size is known. */
      remainingQuantity?: components["schemas"]["SeedQuantityPayload"];
      /** @deprecated Backward-compatibility alias for collectionSiteName */
      siteLocation?: string;
      /** Which application this accession originally came from. This is currently based on the presence of the deviceInfo field. */
      source?: "Web" | "Seed Collector App" | "File Import";
      sourcePlantOrigin?: "Wild" | "Outplant";
      /** Scientific name of the species. */
      species?: string;
      /** Common name of the species, if defined. */
      speciesCommonName?: string;
      /** Server-generated unique ID of the species. */
      speciesId?: number;
      /** Server-calculated accession state. Can change due to modifications to accession data or based on passage of time. */
      state:
        | "Awaiting Check-In"
        | "Pending"
        | "Awaiting Processing"
        | "Processing"
        | "Cleaning"
        | "Processed"
        | "Drying"
        | "Dried"
        | "In Storage"
        | "Withdrawn"
        | "Used Up"
        | "Nursery";
      storageCondition?: "Refrigerator" | "Freezer";
      storageLocation?: string;
      storagePackets?: number;
      storageNotes?: string;
      storageStaffResponsible?: string;
      storageStartDate?: string;
      subsetCount?: number;
      /** Weight of subset of seeds. Units must be a weight measurement, not "Seeds". */
      subsetWeight?: components["schemas"]["SeedQuantityPayload"];
      targetStorageCondition?: "Refrigerator" | "Freezer";
      /** Total quantity of all past withdrawals, including viability tests. */
      totalPastWithdrawalQuantity?: components["schemas"]["SeedQuantityPayload"];
      /** Total quantity of scheduled withdrawals, not counting viability tests. */
      totalScheduledNonTestQuantity?: components["schemas"]["SeedQuantityPayload"];
      /** Total quantity of scheduled withdrawals for viability tests. */
      totalScheduledTestQuantity?: components["schemas"]["SeedQuantityPayload"];
      /** Total quantity of scheduled withdrawals, including viability tests. */
      totalScheduledWithdrawalQuantity?: components["schemas"]["SeedQuantityPayload"];
      totalViabilityPercent?: number;
      /** Total quantity of all past and scheduled withdrawals, including viability tests. */
      totalWithdrawalQuantity?: components["schemas"]["SeedQuantityPayload"];
      viabilityTests?: components["schemas"]["ViabilityTestPayload"][];
      withdrawals?: components["schemas"]["WithdrawalPayload"][];
    };
    AccessionPayloadV2: {
      /** Server-generated human-readable identifier for the accession. This is unique within a single seed bank, but different seed banks may have accessions with the same number. */
      accessionNumber: string;
      /** Server-calculated active indicator. This is based on the accession's state. */
      active: "Inactive" | "Active";
      bagNumbers?: string[];
      collectedDate?: string;
      collectionSiteCity?: string;
      collectionSiteCoordinates?: components["schemas"]["Geolocation"][];
      collectionSiteCountryCode?: string;
      collectionSiteCountrySubdivision?: string;
      collectionSiteLandowner?: string;
      collectionSiteName?: string;
      collectionSiteNotes?: string;
      collectionSource?: "Wild" | "Reintroduced" | "Cultivated" | "Other";
      /** Names of the people who collected the seeds. */
      collectors?: string[];
      dryingEndDate?: string;
      /** Estimated number of seeds remaining. Absent if there isn't enough information to calculate an estimate. */
      estimatedCount?: number;
      estimatedWeight?: components["schemas"]["SeedQuantityPayload"];
      facilityId: number;
      family?: string;
      founderId?: string;
      /** Server-generated unique identifier for the accession. This is unique across all seed banks, but is not suitable for display to end users. */
      id: number;
      latestObservedQuantity?: components["schemas"]["SeedQuantityPayload"];
      /** Time of most recent user observation of seeds remaining in the accession. This is updated by the server whenever the "remainingQuantity" field is edited. */
      latestObservedTime?: string;
      notes?: string;
      photoFilenames?: string[];
      /** Estimated number of plants the seeds were collected from. */
      plantsCollectedFrom?: number;
      receivedDate?: string;
      remainingQuantity?: components["schemas"]["SeedQuantityPayload"];
      /** Which source of data this accession originally came from. */
      source?: "Web" | "Seed Collector App" | "File Import";
      /** Scientific name of the species. */
      speciesScientificName?: string;
      /** Common name of the species, if defined. */
      speciesCommonName?: string;
      /** Server-generated unique ID of the species. */
      speciesId?: number;
      state:
        | "Awaiting Check-In"
        | "Pending"
        | "Awaiting Processing"
        | "Processing"
        | "Cleaning"
        | "Processed"
        | "Drying"
        | "Dried"
        | "In Storage"
        | "Withdrawn"
        | "Used Up"
        | "Nursery";
      storageLocation?: string;
      subsetCount?: number;
      subsetWeight?: components["schemas"]["SeedQuantityPayload"];
      viabilityPercent?: number;
      viabilityTests?: components["schemas"]["GetViabilityTestPayload"][];
      withdrawals?: components["schemas"]["GetWithdrawalPayload"][];
    };
    AddOrganizationUserRequestPayload: {
      email: string;
      role: "Contributor" | "Manager" | "Admin" | "Owner";
    };
    AllFieldValuesPayload: {
      /** All the values this field could possibly have, whether or not any accessions have them. For fields that allow the user to enter arbitrary values, this is equivalent to querying the list of values without any filter criteria, that is, it's a list of all the user-entered values. */
      values: string[];
      /** If true, the list of values is too long to return in its entirety and "values" is a partial list. */
      partial: boolean;
    };
    /** Search criterion that matches results that meet all of a set of other search criteria. That is, if the list of children is x, y, and z, this will require x AND y AND z. */
    AndNodePayload: components["schemas"]["SearchNodePayload"] & {
      children?: components["schemas"]["SearchNodePayload"][];
    } & {
      children: unknown;
    };
    AutomationPayload: {
      id: number;
      facilityId: number;
      /** Short human-readable name of this automation. */
      name: string;
      /** Human-readable description of this automation. */
      description?: string;
      /** Client-defined configuration data for this automation. */
      configuration?: { [key: string]: unknown };
    };
    AutomationTriggerRequestPayload: {
      /** For automations that are triggered by changes to timeseries values, the value that triggered the automation. */
      timeseriesValue?: number;
      /** Default message to publish if the automation type isn't yet supported by the server. */
      message?: string;
    };
    ConnectDeviceManagerRequestPayload: {
      facilityId: number;
    };
    CreateAccessionRequestPayload: {
      bagNumbers?: string[];
      collectedDate?: string;
      collectionSiteCity?: string;
      collectionSiteCountryCode?: string;
      collectionSiteCountrySubdivision?: string;
      collectionSiteLandowner?: string;
      collectionSiteName?: string;
      collectionSiteNotes?: string;
      collectionSource?: "Wild" | "Reintroduced" | "Cultivated" | "Other";
      collectors?: string[];
      endangered?: "No" | "Yes" | "Unsure";
      /** @deprecated Backward-compatibility alias for collectionSiteNotes */
      environmentalNotes?: string;
      facilityId?: number;
      family?: string;
      fieldNotes?: string;
      founderId?: string;
      geolocations?: components["schemas"]["Geolocation"][];
      /** @deprecated Backward-compatibility alias for collectionSiteLandowner */
      landowner?: string;
      numberOfTrees?: number;
      rare?: "No" | "Yes" | "Unsure";
      receivedDate?: string;
      /** @deprecated Backward-compatibility alias for collectionSiteName */
      siteLocation?: string;
      source?: "Web" | "Seed Collector App" | "File Import";
      sourcePlantOrigin?: "Wild" | "Outplant";
      species?: string;
    };
    CreateAccessionRequestPayloadV2: {
      bagNumbers?: string[];
      collectedDate?: string;
      collectionSiteCity?: string;
      collectionSiteCoordinates?: components["schemas"]["Geolocation"][];
      collectionSiteCountryCode?: string;
      collectionSiteCountrySubdivision?: string;
      collectionSiteLandowner?: string;
      collectionSiteName?: string;
      collectionSiteNotes?: string;
      collectionSource?: "Wild" | "Reintroduced" | "Cultivated" | "Other";
      collectors?: string[];
      facilityId?: number;
      founderId?: string;
      notes?: string;
      /** Estimated number of plants the seeds were collected from. */
      plantsCollectedFrom?: number;
      receivedDate?: string;
      source?: "Web" | "Seed Collector App" | "File Import";
      speciesId?: number;
      state?:
        | "Awaiting Check-In"
        | "Pending"
        | "Awaiting Processing"
        | "Processing"
        | "Cleaning"
        | "Processed"
        | "Drying"
        | "Dried"
        | "In Storage"
        | "Withdrawn"
        | "Used Up"
        | "Nursery";
      storageLocation?: string;
    };
    CreateAccessionResponsePayload: {
      accession: components["schemas"]["AccessionPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    CreateAccessionResponsePayloadV2: {
      accession: components["schemas"]["AccessionPayloadV2"];
      status: components["schemas"]["SuccessOrError"];
    };
    CreateAutomationRequestPayload: {
      facilityId: number;
      type: string;
      name: string;
      description?: string;
      deviceId?: number;
      timeseriesName?: string;
      verbosity?: number;
      lowerThreshold?: number;
      upperThreshold?: number;
      settings?: { [key: string]: { [key: string]: unknown } };
    };
    CreateAutomationResponsePayload: {
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateDeviceRequestPayload: {
      /** Identifier of facility where this device is located. */
      facilityId: number;
      /** Name of this device. */
      name: string;
      /** High-level type of the device. Device manager may use this in conjunction with the make and model to determine which metrics to report. */
      type: string;
      /** Name of device manufacturer. */
      make: string;
      /** Model number or model name of the device. */
      model: string;
      /** Device manager protocol name. */
      protocol?: string;
      /** Protocol-specific address of device, e.g., an IP address or a Bluetooth device ID. */
      address?: string;
      /** Port number if relevant for the protocol. */
      port?: number;
      /** Protocol- and device-specific custom settings. This is an arbitrary JSON object; the exact settings depend on the device type. */
      settings?: { [key: string]: unknown };
      /** Level of diagnostic information to log. */
      verbosity?: number;
      /** ID of parent device such as a hub or gateway, if any. The parent device must exist. */
      parentId?: number;
    };
    CreateFacilityRequestPayload: {
      description?: string;
      /** Which organization this facility belongs to. */
      organizationId: number;
      name: string;
      type: "Seed Bank" | "Desalination" | "Reverse Osmosis";
    };
    CreateFacilityResponsePayload: {
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateOrganizationRequestPayload: {
      /** ISO 3166 alpha-2 code of organization's country. */
      countryCode?: string;
      /** ISO 3166-2 code of organization's country subdivision (state, province, region, etc.) This is the full ISO 3166-2 code including the country prefix. If this is set, countryCode must also be set. */
      countrySubdivisionCode?: string;
      description?: string;
      name: string;
    };
    CreateOrganizationUserResponsePayload: {
      /** The ID of the newly-added user. */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateSpeciesResponsePayload: {
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateTimeseriesEntry: {
      /** ID of device that produces this timeseries. */
      deviceId: number;
      /** Name of this timeseries. Duplicate timeseries names for the same device aren't allowed, but different devices can have timeseries with the same name. */
      timeseriesName: string;
      type: "Numeric" | "Text";
      /** Number of significant fractional digits (after the decimal point), if this is a timeseries with non-integer numeric values. */
      decimalPlaces?: number;
      /** Units of measure for values in this timeseries. */
      units?: string;
    };
    CreateTimeseriesRequestPayload: {
      timeseries: components["schemas"]["CreateTimeseriesEntry"][];
    };
    CreateViabilityTestRequestPayload: {
      endDate?: string;
      notes?: string;
      seedsTested?: number;
      seedType?: "Fresh" | "Stored";
      startDate?: string;
      substrate?:
        | "Nursery Media"
        | "Agar"
        | "Paper"
        | "Other"
        | "Sand"
        | "Media Mix"
        | "Soil"
        | "Moss"
        | "Perlite/Vermiculite";
      testingStaffUserId?: number;
      testType?: "Lab" | "Nursery" | "Cut";
      treatment?:
        | "Soak"
        | "Scarify"
        | "Chemical"
        | "Stratification"
        | "Other"
        | "Light";
    };
    CreateWithdrawalRequestPayload: {
      date?: string;
      purpose?:
        | "Propagation"
        | "Outreach or Education"
        | "Research"
        | "Broadcast"
        | "Share with Another Site"
        | "Other"
        | "Viability Testing"
        | "Out-planting"
        | "Nursery";
      notes?: string;
      /** ID of the user who withdrew the seeds. Default for new withdrawals is the current user; for existing withdrawals, default is the withdrawal's existing user ID. Ignored if the current user does not have permission to list organization users. V1 COMPATIBILITY: If this is null and the withdrawal doesn't have a user ID, the existing "staffResponsible" value will be preserved. */
      withdrawnByUserId?: number;
      withdrawnQuantity?: components["schemas"]["SeedQuantityPayload"];
    };
    DeviceConfig: {
      /** Unique identifier of this device. */
      id: number;
      /** Identifier of facility where this device is located. */
      facilityId: number;
      /** Name of this device. */
      name: string;
      /** High-level type of the device. Device manager may use this in conjunction with the make and model to determine which metrics to report. */
      type: string;
      /** Name of device manufacturer. */
      make: string;
      /** Model number or model name of the device. */
      model: string;
      /** Device manager protocol name. */
      protocol?: string;
      /** Protocol-specific address of device, e.g., an IP address or a Bluetooth device ID. */
      address?: string;
      /** Port number if relevant for the protocol. */
      port?: number;
      /** Protocol- and device-specific custom settings. This is an arbitrary JSON object; the exact settings depend on the device type. */
      settings?: { [key: string]: unknown };
      /** Level of diagnostic information to log. */
      verbosity?: number;
      /** ID of parent device such as a hub or gateway, if any. */
      parentId?: number;
    };
    DeviceManagerPayload: {
      id: number;
      sensorKitId: string;
      /** If true, this device manager is available to connect to a facility. */
      available: boolean;
      /** The facility this device manager is connected to, or null if it is not connected. */
      facilityId?: number;
      /** If true, this device manager is currently online. */
      isOnline: boolean;
      /** When the device manager's isOnline value changed most recently. In other words, if isOnline is true, the device manager has been online since this time; if isOnline is false, the device manager has been offline since this time. This may be null if the device manager has not come online for the first time yet. */
      onlineChangedTime?: string;
      /** If an update is being downloaded or installed, its progress as a percentage. Not present if no update is in progress. */
      updateProgress?: number;
    };
    DeviceTemplatePayload: {
      id: number;
      category: "PV" | "Seed Bank Default";
      name: string;
      type: string;
      make: string;
      model: string;
      protocol?: string;
      address?: string;
      port?: number;
      settings?: { [key: string]: { [key: string]: unknown } };
      verbosity?: number;
    };
    DeviceUnresponsiveRequestPayload: {
      /** When the device most recently responded. Null or absent if the device has never responded. */
      lastRespondedTime?: string;
      /** The expected amount of time between updates from the device. Null or absent if there is no fixed update interval. */
      expectedIntervalSecs?: number;
    };
    ErrorDetails: {
      message: string;
    };
    /** This organization's facilities. Only included if depth is "Facility". */
    FacilityPayload: {
      connectionState: "Not Connected" | "Connected" | "Configured";
      createdTime: string;
      description?: string;
      id: number;
      name: string;
      organizationId: number;
      type: "Seed Bank" | "Desalination" | "Reverse Osmosis";
    };
    FieldNodePayload: components["schemas"]["SearchNodePayload"] & {
      field?: string;
      /** List of values to match. For exact and fuzzy searches, a list of at least one value to search for; the list may include null to match accessions where the field does not have a value. For range searches, the list must contain exactly two values, the minimum and maximum; one of the values may be null to search for all values above a minimum or below a maximum. */
      values?: (string | null)[];
      type?: "Exact" | "Fuzzy" | "Range";
    } & {
      field: unknown;
      type: unknown;
      values: unknown;
    };
    FieldValuesPayload: {
      /** List of values in the matching accessions. If there are accessions where the field has no value, this list will contain null (an actual null value, not the string "null"). */
      values: (string | null)[];
      /** If true, the list of values is too long to return in its entirety and "values" is a partial list. */
      partial: boolean;
    };
    Geolocation: {
      latitude: number;
      longitude: number;
      accuracy?: number;
    };
    GetAccessionHistoryResponsePayload: {
      /** History of changes in descending time order (newest first.) */
      history: components["schemas"]["AccessionHistoryEntryPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetAccessionResponsePayload: {
      accession: components["schemas"]["AccessionPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetAccessionResponsePayloadV2: {
      accession: components["schemas"]["AccessionPayloadV2"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetAutomationResponsePayload: {
      automation: components["schemas"]["AutomationPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetCurrentTimeResponsePayload: {
      currentTime: string;
      status: components["schemas"]["SuccessOrError"];
    };
    GetDeviceManagerResponsePayload: {
      manager: components["schemas"]["DeviceManagerPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetDeviceManagersResponsePayload: {
      /** List of device managers that match the conditions in the request. Empty if there were no matches, e.g., the requested short code didn't exist. */
      managers: components["schemas"]["DeviceManagerPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetDeviceResponsePayload: {
      device: components["schemas"]["DeviceConfig"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetFacilityResponse: {
      facility: components["schemas"]["FacilityPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetNotificationResponsePayload: {
      notification: components["schemas"]["NotificationPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetNotificationsCountResponsePayload: {
      notifications: components["schemas"]["NotificationCountPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetNotificationsResponsePayload: {
      notifications: components["schemas"]["NotificationPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetOrganizationResponsePayload: {
      organization: components["schemas"]["OrganizationPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetOrganizationUserResponsePayload: {
      user: components["schemas"]["OrganizationUserPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetSpeciesProblemResponsePayload: {
      problem: components["schemas"]["SpeciesProblemElement"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetSpeciesResponsePayload: {
      species: components["schemas"]["SpeciesResponseElement"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetSpeciesUploadStatusDetailsPayload: {
      id: number;
      status:
        | "Receiving"
        | "Validating"
        | "Processing"
        | "Completed"
        | "Processing Failed"
        | "Invalid"
        | "Receiving Failed"
        | "Awaiting Validation"
        | "Awaiting User Action"
        | "Awaiting Processing";
      errors?: components["schemas"]["SpeciesUploadProblemPayload"][];
      warnings?: components["schemas"]["SpeciesUploadProblemPayload"][];
      /** True if the server is finished processing the file, either successfully or not. */
      finished: boolean;
    };
    GetSpeciesUploadStatusResponsePayload: {
      details: components["schemas"]["GetSpeciesUploadStatusDetailsPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetTimeseriesHistoryRequestPayload: {
      /** Start of time range to query. If this is non-null, endTime must also be specified, and seconds must be null or absent. */
      startTime?: string;
      /** End of time range to query. If this is non-null, startTime must also be specified, and seconds must be null or absent. */
      endTime?: string;
      /** Number of seconds in the past to start the time range. If this is non-null, startTime and endTime must be null or absent. */
      seconds?: number;
      /** Number of values to return. The time range is divided into this many equal intervals, and a value is returned from each interval if available. */
      count: number;
      /** Timeseries to query. May be from different devices. */
      timeseries: components["schemas"]["TimeseriesIdPayload"][];
    };
    GetTimeseriesHistoryResponsePayload: {
      values: components["schemas"]["TimeseriesValuesPayload"][];
    };
    GetUserPreferencesResponsePayload: {
      /** The user's preferences, or null if no preferences have been stored yet. */
      preferences?: { [key: string]: unknown };
      status: components["schemas"]["SuccessOrError"];
    };
    GetUserResponsePayload: {
      user: components["schemas"]["UserProfilePayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetViabilityTestPayload: {
      accessionId: number;
      endDate?: string;
      id: number;
      notes?: string;
      seedsTested?: number;
      seedType?: "Fresh" | "Stored";
      startDate?: string;
      substrate?:
        | "Nursery Media"
        | "Agar"
        | "Paper"
        | "Other"
        | "Sand"
        | "Media Mix"
        | "Soil"
        | "Moss"
        | "Perlite/Vermiculite";
      treatment?:
        | "Soak"
        | "Scarify"
        | "Chemical"
        | "Stratification"
        | "Other"
        | "Light";
      testingStaffName?: string;
      testingStaffUserId?: number;
      testResults?: components["schemas"]["ViabilityTestResultPayload"][];
      testType: "Lab" | "Nursery" | "Cut";
      totalPercentGerminated?: number;
      totalSeedsGerminated?: number;
    };
    GetViabilityTestResponsePayload: {
      viabilityTest: components["schemas"]["GetViabilityTestPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetWithdrawalPayload: {
      date: string;
      /** Number of seeds withdrawn. Calculated by server. This is an estimate if "withdrawnQuantity" is a weight quantity and the accession has subset weight and count data. Absent if "withdrawnQuantity" is a weight quantity and the accession has no subset weight and count. */
      estimatedCount?: number;
      estimatedWeight?: components["schemas"]["SeedQuantityPayload"];
      /** Server-assigned unique ID of this withdrawal. */
      id?: number;
      purpose?:
        | "Propagation"
        | "Outreach or Education"
        | "Research"
        | "Broadcast"
        | "Share with Another Site"
        | "Other"
        | "Viability Testing"
        | "Out-planting"
        | "Nursery";
      notes?: string;
      /** If this withdrawal is of purpose "Viability Testing", the ID of the test it is associated with. */
      viabilityTestId?: number;
      /** Full name of the person who withdrew the seeds. V1 COMPATIBILITY: This is the "staffResponsible" v1 field, which may not be the name of an organization user. */
      withdrawnByName?: string;
      /** ID of the user who withdrew the seeds. Only present if the current user has permission to list the users in the organization. V1 COMPATIBILITY: Also absent if the withdrawal was written with the v1 API and we haven't yet written the code to figure out which user ID to assign. */
      withdrawnByUserId?: number;
      withdrawnQuantity?: components["schemas"]["SeedQuantityPayload"];
    };
    GetWithdrawalResponsePayload: {
      withdrawal: components["schemas"]["GetWithdrawalPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetWithdrawalsResponsePayload: {
      withdrawals: components["schemas"]["GetWithdrawalPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListAllFieldValuesRequestPayload: {
      facilityId?: number;
      fields: string[];
      organizationId?: number;
    };
    ListAllFieldValuesResponsePayload: {
      results: {
        [key: string]: components["schemas"]["AllFieldValuesPayload"];
      };
      status: components["schemas"]["SuccessOrError"];
    };
    ListAutomationsResponsePayload: {
      automations: components["schemas"]["AutomationPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListDeviceConfigsResponse: {
      devices: components["schemas"]["DeviceConfig"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListDeviceTemplatesResponsePayload: {
      templates: components["schemas"]["DeviceTemplatePayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListFacilitiesResponse: {
      facilities: components["schemas"]["FacilityPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListFieldValuesRequestPayload: {
      facilityId?: number;
      fields: string[];
      organizationId?: number;
      search?:
        | components["schemas"]["AndNodePayload"]
        | components["schemas"]["FieldNodePayload"]
        | components["schemas"]["NotNodePayload"]
        | components["schemas"]["OrNodePayload"];
    };
    ListFieldValuesResponsePayload: {
      results: { [key: string]: components["schemas"]["FieldValuesPayload"] };
      status: components["schemas"]["SuccessOrError"];
    };
    ListOrganizationRolesResponsePayload: {
      roles: components["schemas"]["OrganizationRolePayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListOrganizationUsersResponsePayload: {
      users: components["schemas"]["OrganizationUserPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListOrganizationsResponsePayload: {
      organizations: components["schemas"]["OrganizationPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListPhotosResponseElement: {
      filename: string;
      size: number;
    };
    ListPhotosResponsePayload: {
      photos: components["schemas"]["ListPhotosResponseElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListSpeciesResponsePayload: {
      species: components["schemas"]["SpeciesResponseElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListTimeseriesResponsePayload: {
      timeseries: components["schemas"]["TimeseriesPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListViabilityTestsResponsePayload: {
      viabilityTests: components["schemas"]["GetViabilityTestPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ModifyAutomationRequestPayload: {
      name: string;
      description?: string;
      configuration?: { [key: string]: unknown };
      type: string;
      settings?: { [key: string]: { [key: string]: unknown } };
      timeseriesName?: string;
      deviceId?: number;
      lowerThreshold?: number;
      upperThreshold?: number;
      verbosity: number;
    };
    /** Search criterion that matches results that do not match a set of search criteria. */
    NotNodePayload: components["schemas"]["SearchNodePayload"] & {
      child?: components["schemas"]["SearchNodePayload"];
    } & {
      child: unknown;
    };
    NotificationCountPayload: {
      organizationId?: number;
      unread: number;
    };
    NotificationPayload: {
      id: number;
      notificationCriticality: "Info" | "Warning" | "Error" | "Success";
      organizationId?: number;
      title: string;
      body: string;
      localUrl: string;
      createdTime: string;
      isRead: boolean;
    };
    /** Search criterion that matches results that meet any of a set of other search criteria. That is, if the list of children is x, y, and z, this will require x OR y OR z. */
    OrNodePayload: components["schemas"]["SearchNodePayload"];
    OrganizationPayload: {
      /** ISO 3166 alpha-2 code of organization's country. */
      countryCode?: string;
      /** ISO 3166-2 code of organization's country subdivision (state, province, region, etc.) This is the full ISO 3166-2 code including the country prefix. If this is set, countryCode will also be set. */
      countrySubdivisionCode?: string;
      createdTime: string;
      description?: string;
      /** This organization's facilities. Only included if depth is "Facility". */
      facilities?: components["schemas"]["FacilityPayload"][];
      id: number;
      name: string;
      /** The current user's role in the organization. */
      role: "Contributor" | "Manager" | "Admin" | "Owner";
      /** The total number of users in the organization, including the current user. */
      totalUsers: number;
    };
    OrganizationRolePayload: {
      role: "Contributor" | "Manager" | "Admin" | "Owner";
      /** Total number of users in the organization with this role. */
      totalUsers: number;
    };
    OrganizationUserPayload: {
      /** Date and time the user was added to the organization. */
      addedTime: string;
      email: string;
      id: number;
      /** The user's first name. Not present if the user has been added to the organization but has not signed up for an account yet. */
      firstName?: string;
      /** The user's last name. Not present if the user has been added to the organization but has not signed up for an account yet. */
      lastName?: string;
      role: "Contributor" | "Manager" | "Admin" | "Owner";
    };
    RecordTimeseriesValuesRequestPayload: {
      timeseries: components["schemas"]["TimeseriesValuesPayload"][];
    };
    /** Results of a request to record timeseries values. */
    RecordTimeseriesValuesResponsePayload: {
      /** List of values that the server failed to record. Will not be included if all the values were recorded successfully. */
      failures?: components["schemas"]["TimeseriesValuesErrorPayload"][];
      status: components["schemas"]["SuccessOrError"];
      error?: components["schemas"]["ErrorDetails"];
    };
    ResolveSpeciesUploadRequestPayload: {
      /** If true, the data for entries that already exist will be overwritten with the values in the uploaded file. If false, only entries that don't already exist will be imported. */
      overwriteExisting: boolean;
    };
    /** A search criterion. The search will return results that match this criterion. The criterion can be composed of other search criteria to form arbitrary Boolean search expressions. TYPESCRIPT-OVERRIDE-TYPE-WITH-ANY */
    SearchNodePayload: any;
    SearchRequestPayload: {
      /** Prefix for field names. This determines how field names are interpreted, and also how results are structured. Each element in the "results" array in the response will be an instance of whatever entity the prefix points to. Always evaluated starting from the "organizations" level. If not present, the search will return a list of organizations. */
      prefix?: string;
      /** List of fields to return. Field names should be relative to the prefix. They may navigate the data hierarchy using '.' or '_' as delimiters. */
      fields: string[];
      /** How to sort the search results. This controls both the order of the top-level results and the order of any lists of child objects. */
      sortOrder?: components["schemas"]["SearchSortOrderElement"][];
      search?:
        | components["schemas"]["AndNodePayload"]
        | components["schemas"]["FieldNodePayload"]
        | components["schemas"]["NotNodePayload"]
        | components["schemas"]["OrNodePayload"];
      /** Maximum number of top-level search results to return. The system may impose a limit on this value. A separate system-imposed limit may also be applied to lists of child objects inside the top-level results. Use a value of 0 to return the maximum number of allowed results. */
      count: number;
      /** Starting point for search results. If present, a previous search will be continued from where it left off. This should be the value of the cursor that was returned in the response to a previous search. */
      cursor?: string;
    };
    SearchResponsePayload: {
      results: { [key: string]: unknown }[];
      cursor?: string;
    };
    /** How to sort the search results. This controls both the order of the top-level results and the order of any lists of child objects. */
    SearchSortOrderElement: {
      field: string;
      direction?: "Ascending" | "Descending";
    };
    SeedCountSummaryPayload: {
      /** Total number of seeds remaining. The sum of subtotalBySeedCount and subtotalByWeightEstimate. */
      total: number;
      /** Total number of seeds remaining in accessions whose quantities are measured in seeds. */
      subtotalBySeedCount: number;
      /** Estimated total number of seeds remaining in accessions whose quantities are measured by weight. This estimate is based on the subset weight and count. Accessions measured by weight that don't have subset weights and counts are not included in this estimate. */
      subtotalByWeightEstimate: number;
      /** Number of accessions that are measured by weight and don't have subset weight and count data. The system cannot estimate how many seeds they have. */
      unknownQuantityAccessions: number;
    };
    /** Represents a quantity of seeds, measured either in individual seeds or by weight. */
    SeedQuantityPayload: {
      /** Number of units of seeds. If "units" is "Seeds", this is the number of seeds and must be an integer. Otherwise it is a measurement in the weight units specified in the "units" field, and may have a fractional part. */
      quantity: number;
      units:
        | "Seeds"
        | "Grams"
        | "Milligrams"
        | "Kilograms"
        | "Ounces"
        | "Pounds";
      /** If this quantity is a weight measurement, the weight in grams. This is not set if the "units" field is "Seeds". This is always calculated on the server side and is ignored on input. */
      grams?: number;
    };
    SendFacilityAlertRequestPayload: {
      subject: string;
      /** Alert body in plain text. HTML alerts are not supported yet. */
      body: string;
    };
    SimpleErrorResponsePayload: {
      error: components["schemas"]["ErrorDetails"];
      status: components["schemas"]["SuccessOrError"];
    };
    SimpleSuccessResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
    };
    SpeciesLookupCommonNamePayload: {
      name: string;
      /** ISO 639-1 two-letter language code indicating the name's language. Some common names in the server's taxonomic database are not tagged with languages; this value will not be present for those names. */
      language?: string;
    };
    SpeciesLookupDetailsResponsePayload: {
      scientificName: string;
      /** List of known common names for the species, if any. */
      commonNames?: components["schemas"]["SpeciesLookupCommonNamePayload"][];
      familyName: string;
      /** True if the species is known to be endangered, false if the species is known to not be endangered. This value will not be present if the server's taxonomic database doesn't indicate whether or not the species is endangered. */
      endangered?: boolean;
      /** If this is not the accepted name for the species, the type of problem the name has. Currently, this will always be "Name Is Synonym". */
      problemType?: "Name Misspelled" | "Name Not Found" | "Name Is Synonym";
      /** If this is not the accepted name for the species, the name to suggest as an alternative. */
      suggestedScientificName?: string;
    };
    SpeciesLookupNamesResponsePayload: {
      names: string[];
      /** True if there were more matching names than could be included in the response. */
      partial: boolean;
      status: components["schemas"]["SuccessOrError"];
    };
    SpeciesProblemElement: {
      id: number;
      field: "Scientific Name";
      type: "Name Misspelled" | "Name Not Found" | "Name Is Synonym";
      /** Value for the field in question that would correct the problem. Absent if the system is unable to calculate a corrected value. */
      suggestedValue?: string;
    };
    SpeciesRequestPayload: {
      commonName?: string;
      endangered?: boolean;
      familyName?: string;
      growthForm?: "Tree" | "Shrub" | "Forb" | "Graminoid" | "Fern";
      /** Which organization's species list to update. */
      organizationId: number;
      rare?: boolean;
      scientificName: string;
      seedStorageBehavior?:
        | "Orthodox"
        | "Recalcitrant"
        | "Intermediate"
        | "Unknown";
    };
    SpeciesResponseElement: {
      commonName?: string;
      endangered?: boolean;
      familyName?: string;
      growthForm?: "Tree" | "Shrub" | "Forb" | "Graminoid" | "Fern";
      id: number;
      problems?: components["schemas"]["SpeciesProblemElement"][];
      rare?: boolean;
      scientificName: string;
      seedStorageBehavior?:
        | "Orthodox"
        | "Recalcitrant"
        | "Intermediate"
        | "Unknown";
    };
    /** List of conditions that might cause the user to want to cancel the upload but that can be automatically resolved if desired. */
    SpeciesUploadProblemPayload: {
      /** Name of the field with the problem. Absent if the problem isn't specific to a single field. */
      fieldName?: string;
      /** Human-readable description of the problem. */
      message?: string;
      /** Position (row number) of the record with the problem. */
      position?: number;
      type:
        | "Unrecognized Value"
        | "Missing Required Value"
        | "Duplicate Value"
        | "Malformed Value";
      /** The value that caused the problem. Absent if the problem wasn't caused by a specific field value. */
      value?: string;
    };
    StorageLocationDetails: {
      storageLocation: string;
      storageCondition: "Refrigerator" | "Freezer";
    };
    StorageLocationsResponsePayload: {
      locations: components["schemas"]["StorageLocationDetails"][];
      status: components["schemas"]["SuccessOrError"];
    };
    /** Indicates of success or failure of the requested operation. */
    SuccessOrError: "ok" | "error";
    SummarizeAccessionSearchRequestPayload: {
      search?:
        | components["schemas"]["AndNodePayload"]
        | components["schemas"]["FieldNodePayload"]
        | components["schemas"]["NotNodePayload"]
        | components["schemas"]["OrNodePayload"];
    };
    SummarizeAccessionSearchResponsePayload: {
      accessions: number;
      species: number;
      seedsRemaining: components["schemas"]["SeedCountSummaryPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    /** Summary of important statistics about the seed bank for the Summary page. */
    SummaryResponse: {
      activeAccessions: number;
      species: number;
      /** Number of accessions in each state. */
      accessionsByState: { [key: string]: number };
      seedsRemaining: components["schemas"]["SeedCountSummaryPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    /** Timeseries to query. May be from different devices. */
    TimeseriesIdPayload: {
      deviceId: number;
      timeseriesName: string;
    };
    TimeseriesPayload: {
      /** ID of device that produces this timeseries. */
      deviceId: number;
      timeseriesName: string;
      type: "Numeric" | "Text";
      /** Number of significant fractional digits (after the decimal point), if this is a timeseries with non-integer numeric values. */
      decimalPlaces?: number;
      /** Units of measure for values in this timeseries. */
      units?: string;
      latestValue?: components["schemas"]["TimeseriesValuePayload"];
    };
    TimeseriesValuePayload: {
      timestamp: string;
      /** Value to record. If the timeseries is of type Numeric, this must be a decimal or integer value in string form. If the timeseries is of type Text, this can be an arbitrary string. */
      value: string;
    };
    /** List of values that the server failed to record. Will not be included if all the values were recorded successfully. */
    TimeseriesValuesErrorPayload: {
      /** Device ID as specified in the failing request. */
      deviceId: number;
      /** Name of timeseries as specified in the failing request. */
      timeseriesName: string;
      /** Values that the server was not able to successfully record. */
      values: components["schemas"]["TimeseriesValuePayload"][];
      /** Human-readable details about the failure. */
      message: string;
    };
    TimeseriesValuesPayload: {
      /** ID of device that produced this value. */
      deviceId: number;
      /** Name of timeseries. This must be the name of a timeseries that has already been created for the device. */
      timeseriesName: string;
      values: components["schemas"]["TimeseriesValuePayload"][];
    };
    UpdateAccessionRequestPayload: {
      bagNumbers?: string[];
      collectedDate?: string;
      collectionSiteCity?: string;
      collectionSiteCountryCode?: string;
      collectionSiteCountrySubdivision?: string;
      collectionSiteLandowner?: string;
      collectionSiteName?: string;
      collectionSiteNotes?: string;
      collectionSource?: "Wild" | "Reintroduced" | "Cultivated" | "Other";
      collectors?: string[];
      cutTestSeedsCompromised?: number;
      cutTestSeedsEmpty?: number;
      cutTestSeedsFilled?: number;
      dryingEndDate?: string;
      dryingMoveDate?: string;
      dryingStartDate?: string;
      endangered?: "No" | "Yes" | "Unsure";
      /** @deprecated Backward-compatibility alias for collectionSiteNotes */
      environmentalNotes?: string;
      facilityId?: number;
      family?: string;
      fieldNotes?: string;
      founderId?: string;
      geolocations?: components["schemas"]["Geolocation"][];
      /** Initial size of accession. The units of this value must match the measurement type in "processingMethod". */
      initialQuantity?: components["schemas"]["SeedQuantityPayload"];
      /** @deprecated Backward-compatibility alias for collectionSiteLandowner */
      landowner?: string;
      numberOfTrees?: number;
      nurseryStartDate?: string;
      processingMethod?: "Count" | "Weight";
      processingNotes?: string;
      processingStaffResponsible?: string;
      processingStartDate?: string;
      rare?: "No" | "Yes" | "Unsure";
      receivedDate?: string;
      /** @deprecated Backward-compatibility alias for collectionSiteName */
      siteLocation?: string;
      sourcePlantOrigin?: "Wild" | "Outplant";
      species?: string;
      storageLocation?: string;
      storageNotes?: string;
      storagePackets?: number;
      storageStaffResponsible?: string;
      storageStartDate?: string;
      subsetCount?: number;
      /** Weight of subset of seeds. Units must be a weight measurement, not "Seeds". */
      subsetWeight?: components["schemas"]["SeedQuantityPayload"];
      targetStorageCondition?: "Refrigerator" | "Freezer";
      viabilityTests?: components["schemas"]["ViabilityTestPayload"][];
      withdrawals?: components["schemas"]["WithdrawalPayload"][];
    };
    UpdateAccessionRequestPayloadV2: {
      bagNumbers?: string[];
      collectedDate?: string;
      collectionSiteCity?: string;
      collectionSiteCoordinates?: components["schemas"]["Geolocation"][];
      collectionSiteCountryCode?: string;
      collectionSiteCountrySubdivision?: string;
      collectionSiteLandowner?: string;
      collectionSiteName?: string;
      collectionSiteNotes?: string;
      collectionSource?: "Wild" | "Reintroduced" | "Cultivated" | "Other";
      collectors?: string[];
      dryingEndDate?: string;
      facilityId?: number;
      founderId?: string;
      notes?: string;
      /** Estimated number of plants the seeds were collected from. */
      plantsCollectedFrom?: number;
      receivedDate?: string;
      remainingQuantity?: components["schemas"]["SeedQuantityPayload"];
      speciesId?: number;
      state?:
        | "Awaiting Check-In"
        | "Pending"
        | "Awaiting Processing"
        | "Processing"
        | "Cleaning"
        | "Processed"
        | "Drying"
        | "Dried"
        | "In Storage"
        | "Withdrawn"
        | "Used Up"
        | "Nursery";
      storageLocation?: string;
      subsetCount?: number;
      subsetWeight?: components["schemas"]["SeedQuantityPayload"];
      viabilityPercent?: number;
    };
    UpdateAccessionResponsePayload: {
      accession: components["schemas"]["AccessionPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    UpdateAccessionResponsePayloadV2: {
      accession: components["schemas"]["AccessionPayloadV2"];
      status: components["schemas"]["SuccessOrError"];
    };
    UpdateAutomationRequestPayload: {
      type: string;
      name: string;
      description?: string;
      deviceId?: number;
      timeseriesName?: string;
      verbosity?: number;
      lowerThreshold?: number;
      upperThreshold?: number;
      settings?: { [key: string]: { [key: string]: unknown } };
    };
    UpdateDeviceRequestPayload: {
      /** Name of this device. */
      name: string;
      /** High-level type of the device. Device manager may use this in conjunction with the make and model to determine which metrics to report. */
      type: string;
      /** Name of device manufacturer. */
      make: string;
      /** Model number or model name of the device. */
      model: string;
      /** Device manager protocol name. */
      protocol?: string;
      /** Protocol-specific address of device, e.g., an IP address or a Bluetooth device ID. */
      address?: string;
      /** Port number if relevant for the protocol. */
      port?: number;
      /** Protocol- and device-specific custom settings. This is an arbitrary JSON object; the exact settings depend on the device type. */
      settings?: { [key: string]: unknown };
      /** Level of diagnostic information to log. */
      verbosity?: number;
      /** ID of parent device such as a hub or gateway, if any. The parent device must exist. */
      parentId?: number;
    };
    UpdateFacilityRequestPayload: {
      description?: string;
      name: string;
    };
    UpdateNotificationRequestPayload: {
      read: boolean;
    };
    UpdateNotificationsRequestPayload: {
      read: boolean;
      organizationId?: number;
    };
    UpdateOrganizationRequestPayload: {
      /** ISO 3166 alpha-2 code of organization's country. */
      countryCode?: string;
      /** ISO 3166-2 code of organization's country subdivision (state, province, region, etc.) This is the full ISO 3166-2 code including the country prefix. If this is set, countryCode must also be set. */
      countrySubdivisionCode?: string;
      description?: string;
      name: string;
    };
    UpdateOrganizationUserRequestPayload: {
      role: "Contributor" | "Manager" | "Admin" | "Owner";
    };
    UpdateUserPreferencesRequestPayload: {
      /** If present, update the user's per-organization preferences for this organization. If not present, update the user's global preferences. */
      organizationId?: number;
      preferences: { [key: string]: unknown };
    };
    UpdateUserRequestPayload: {
      /** If true, the user wants to receive all the notifications for their organizations via email. This does not apply to certain kinds of notifications such as "You've been added to a new organization." If null, leave the existing value as-is. */
      emailNotificationsEnabled?: boolean;
      firstName: string;
      lastName: string;
    };
    UpdateViabilityTestRequestPayload: {
      endDate?: string;
      notes?: string;
      seedsTested?: number;
      seedType?: "Fresh" | "Stored";
      startDate?: string;
      substrate?:
        | "Nursery Media"
        | "Agar"
        | "Paper"
        | "Other"
        | "Sand"
        | "Media Mix"
        | "Soil"
        | "Moss"
        | "Perlite/Vermiculite";
      testingStaffUserId?: number;
      testResults?: components["schemas"]["ViabilityTestResultPayload"][];
      testType?: "Lab" | "Nursery" | "Cut";
      treatment?:
        | "Soak"
        | "Scarify"
        | "Chemical"
        | "Stratification"
        | "Other"
        | "Light";
    };
    UpdateWithdrawalRequestPayload: {
      date?: string;
      purpose?:
        | "Propagation"
        | "Outreach or Education"
        | "Research"
        | "Broadcast"
        | "Share with Another Site"
        | "Other"
        | "Viability Testing"
        | "Out-planting"
        | "Nursery";
      notes?: string;
      /** ID of the user who withdrew the seeds. Default for new withdrawals is the current user; for existing withdrawals, default is the withdrawal's existing user ID. Ignored if the current user does not have permission to list organization users. V1 COMPATIBILITY: If this is null and the withdrawal doesn't have a user ID, the existing "staffResponsible" value will be preserved. */
      withdrawnByUserId?: number;
      withdrawnQuantity?: components["schemas"]["SeedQuantityPayload"];
    };
    UploadSpeciesListResponsePayload: {
      /** ID of uploaded file. This may be used to poll for the file's status. */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    UserProfilePayload: {
      /** User's unique ID. This should not be shown to the user, but is a required input to some API endpoints. */
      id: number;
      email: string;
      /** If true, the user wants to receive all the notifications for their organizations via email. This does not apply to certain kinds of notifications such as "You've been added to a new organization." */
      emailNotificationsEnabled: boolean;
      firstName?: string;
      lastName?: string;
    };
    ViabilityTestPayload: {
      /** Server-assigned unique ID of this viability test. Null when creating a new test. */
      id?: string;
      /** Which type of test is described. At most one of each test type is allowed. */
      testType: "Lab" | "Nursery";
      startDate?: string;
      endDate?: string;
      seedType?: "Fresh" | "Stored";
      substrate?:
        | "Agar Petri Dish"
        | "Nursery Media"
        | "Paper Petri Dish"
        | "Other";
      treatment?: "Soak" | "Scarify" | "GA3" | "Stratification" | "Other";
      notes?: string;
      /** Quantity of seeds remaining. For weight-based accessions, this is user input and is required. For count-based accessions, it is calculated by the server and ignored on input. */
      remainingQuantity?: components["schemas"]["SeedQuantityPayload"];
      staffResponsible?: string;
      seedsSown?: number;
      testResults?: components["schemas"]["ViabilityTestResultPayload"][];
      totalPercentGerminated?: number;
      totalSeedsGerminated?: number;
    };
    ViabilityTestResultPayload: {
      recordingDate: string;
      seedsGerminated: number;
    };
    WithdrawalPayload: {
      /** Server-assigned unique ID of this withdrawal, its ID. Omit when creating a new withdrawal. */
      id?: number;
      date: string;
      purpose?:
        | "Propagation"
        | "Outreach or Education"
        | "Research"
        | "Broadcast"
        | "Share with Another Site"
        | "Other"
        | "Viability Testing"
        | "Out-planting"
        | "Nursery";
      destination?: string;
      notes?: string;
      /** Quantity of seeds remaining. For weight-based accessions, this is user input and is required. For count-based accessions, it is calculated by the server and ignored on input. */
      remainingQuantity?: components["schemas"]["SeedQuantityPayload"];
      staffResponsible?: string;
      /** If this withdrawal is of purpose "Germination Testing", the ID of the test it is associated with. This is always set by the server and cannot be modified. */
      viabilityTestId?: number;
      /** For weight-based accessions, the difference between the weight remaining before this withdrawal and the weight remaining after it. This is a server-calculated value and is ignored on input. */
      weightDifference?: components["schemas"]["SeedQuantityPayload"];
      /** Quantity of seeds withdrawn. For viability testing withdrawals, this is always the same as the test's "seedsSown" value, if that value is present. Otherwise, it is a user-supplied value. For count-based accessions, the units must always be "Seeds". For weight-based accessions, the units may either be a weight measurement or "Seeds". */
      withdrawnQuantity?: components["schemas"]["SeedQuantityPayload"];
      /** The best estimate of the number of seeds withdrawn. This is the same as "withdrawnQuantity" if that is present, or else the same as "weightDifference" if this is a weight-based accession. If this is a count-based accession and "withdrawnQuantity" does not have a value, this field will not be present. This is a server-calculated value and is ignored on input. */
      estimatedQuantity?: components["schemas"]["SeedQuantityPayload"];
    };
  };
}

export interface operations {
  listAutomations_2: {
    parameters: {
      query: {
        deviceId?: number;
        facilityId?: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListAutomationsResponsePayload"];
        };
      };
    };
  };
  createAutomation_2: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateAutomationResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateAutomationRequestPayload"];
      };
    };
  };
  getAutomation_2: {
    parameters: {
      path: {
        automationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetAutomationResponsePayload"];
        };
      };
    };
  };
  updateAutomation_2: {
    parameters: {
      path: {
        automationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateAutomationRequestPayload"];
      };
    };
  };
  deleteAutomation_2: {
    parameters: {
      path: {
        automationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  postAutomationTrigger: {
    parameters: {
      path: {
        automationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AutomationTriggerRequestPayload"];
      };
    };
  };
  createDevice: {
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateDeviceRequestPayload"];
      };
    };
  };
  getDeviceManagers: {
    parameters: {
      query: {
        sensorKitId?: string;
        facilityId?: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetDeviceManagersResponsePayload"];
        };
      };
    };
  };
  getDeviceManager: {
    parameters: {
      path: {
        deviceManagerId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetDeviceManagerResponsePayload"];
        };
      };
    };
  };
  connectDeviceManager: {
    parameters: {
      path: {
        deviceManagerId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectDeviceManagerRequestPayload"];
      };
    };
  };
  listDeviceTemplates: {
    parameters: {
      query: {
        category?: "PV" | "Seed Bank Default";
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListDeviceTemplatesResponsePayload"];
        };
      };
    };
  };
  getDevice: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** Device configuration retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["GetDeviceResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  updateDevice: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** Device configuration updated. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateDeviceRequestPayload"];
      };
    };
  };
  /** Notifies the appropriate users so they can troubleshoot the problem. */
  deviceUnresponsive: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeviceUnresponsiveRequestPayload"];
      };
    };
  };
  listAllFacilities_1: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListFacilitiesResponse"];
        };
      };
    };
  };
  createFacility_1: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateFacilityResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateFacilityRequestPayload"];
      };
    };
  };
  getFacility: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetFacilityResponse"];
        };
      };
    };
  };
  updateFacility: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateFacilityRequestPayload"];
      };
    };
  };
  sendFacilityAlert: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The request was received, but the user is still configuring or placing sensors, so no notification has been generated. */
      202: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SendFacilityAlertRequestPayload"];
      };
    };
  };
  listAutomations_1: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ListAutomationsResponsePayload"];
        };
      };
      /** The facility does not exist or is not accessible. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  createAutomation_1: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["CreateAutomationResponsePayload"];
        };
      };
      /** The facility does not exist or is not accessible. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ModifyAutomationRequestPayload"];
      };
    };
  };
  getAutomation_1: {
    parameters: {
      path: {
        facilityId: number;
        automationId: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetAutomationResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  updateAutomation_1: {
    parameters: {
      path: {
        facilityId: number;
        automationId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ModifyAutomationRequestPayload"];
      };
    };
  };
  deleteAutomation_1: {
    parameters: {
      path: {
        facilityId: number;
        automationId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** After connecting a device manager and finishing any necessary configuration of the facility's devices, send this request to enable processing of timeseries values and alerts from the device manager. Only valid if the facility's connection state is `Connected`. */
  postConfigured_1: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The facility's device manager was not in the process of being configured. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listFacilityDevices: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** Successfully listed the facility's devices. */
      200: {
        content: {
          "application/json": components["schemas"]["ListDeviceConfigsResponse"];
        };
      };
      /** The facility does not exist or is not accessible by the current user. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listAllFacilities: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListFacilitiesResponse"];
        };
      };
    };
  };
  createFacility: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateFacilityResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateFacilityRequestPayload"];
      };
    };
  };
  getFacility_1: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetFacilityResponse"];
        };
      };
    };
  };
  updateFacility_1: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateFacilityRequestPayload"];
      };
    };
  };
  sendFacilityAlert_1: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The request was received, but the user is still configuring or placing sensors, so no notification has been generated. */
      202: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SendFacilityAlertRequestPayload"];
      };
    };
  };
  listAutomations: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ListAutomationsResponsePayload"];
        };
      };
      /** The facility does not exist or is not accessible. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  createAutomation: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["CreateAutomationResponsePayload"];
        };
      };
      /** The facility does not exist or is not accessible. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ModifyAutomationRequestPayload"];
      };
    };
  };
  getAutomation: {
    parameters: {
      path: {
        facilityId: number;
        automationId: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetAutomationResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  updateAutomation: {
    parameters: {
      path: {
        facilityId: number;
        automationId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ModifyAutomationRequestPayload"];
      };
    };
  };
  deleteAutomation: {
    parameters: {
      path: {
        facilityId: number;
        automationId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** After connecting a device manager and finishing any necessary configuration of the facility's devices, send this request to enable processing of timeseries values and alerts from the device manager. Only valid if the facility's connection state is `Connected`. */
  postConfigured: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The facility's device manager was not in the process of being configured. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listFacilityDevices_1: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** Successfully listed the facility's devices. */
      200: {
        content: {
          "application/json": components["schemas"]["ListDeviceConfigsResponse"];
        };
      };
      /** The facility does not exist or is not accessible by the current user. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** For interactive web applications, this can be used to redirect the user to a login page to allow the application to make other API requests. The login process will set a cookie that will authenticate to the API, and will then redirect back to the application. One approach is to use this in error response handlers: if an API request returns HTTP 401 Unauthorized, set location.href to this endpoint and set "redirect" to the URL of the page the user was on so they'll return there after logging in. */
  login: {
    parameters: {
      query: {
        /** URL to redirect to after login. The list of valid redirect URLs is restricted; this must be the URL of a Terraware web application. */
        redirect: string;
      };
    };
    responses: {
      /** Redirects to a login page. After login, the user will be redirected back to the URL specified in the "redirect" parameter. */
      302: never;
    };
  };
  readAll: {
    parameters: {
      query: {
        /** If set, return notifications relevant to that organization. */
        organizationId?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNotificationsResponsePayload"];
        };
      };
    };
  };
  markAllRead: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateNotificationsRequestPayload"];
      };
    };
  };
  count: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNotificationsCountResponsePayload"];
        };
      };
    };
  };
  read_1: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNotificationResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  markRead: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateNotificationRequestPayload"];
      };
    };
  };
  /** Lists all organizations the user can access. */
  listOrganizations: {
    parameters: {
      query: {
        /** Return this level of information about the organization's contents. */
        depth?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListOrganizationsResponsePayload"];
        };
      };
    };
  };
  createOrganization: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetOrganizationResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateOrganizationRequestPayload"];
      };
    };
  };
  getOrganization: {
    parameters: {
      path: {
        /** ID of organization to get. User must be a member of the organization. */
        organizationId: string;
      };
      query: {
        /** Return this level of information about the organization's contents. */
        depth?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetOrganizationResponsePayload"];
        };
      };
    };
  };
  updateOrganization: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateOrganizationRequestPayload"];
      };
    };
  };
  /** Organizations can only be deleted if they have no members other than the current user. */
  deleteOrganization: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** The organization has other members and cannot be deleted. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listOrganizationRoles: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListOrganizationRolesResponsePayload"];
        };
      };
    };
  };
  listOrganizationUsers: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListOrganizationUsersResponsePayload"];
        };
      };
    };
  };
  addOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateOrganizationUserResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AddOrganizationUserRequestPayload"];
      };
    };
  };
  getOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
        userId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetOrganizationUserResponsePayload"];
        };
      };
    };
  };
  /** Only includes organization-level information that can be modified by organization administrators. */
  updateOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
        userId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The user is not a member of the organization. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** An organization must have at least one owner; cannot change the role of an organization's only owner. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateOrganizationUserRequestPayload"];
      };
    };
  };
  /** Does not remove any data created by the user. */
  deleteOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
        userId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The user is not a member of the organization. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** The user is the organization's only owner and an organization must have at least one owner. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  search_1: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SearchResponsePayload"];
          "text/csv": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SearchRequestPayload"];
      };
    };
  };
  create: {
    responses: {
      /** The accession was created successfully. Response includes fields populated by the server, including the accession number and ID. */
      200: {
        content: {
          "application/json": components["schemas"]["CreateAccessionResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateAccessionRequestPayload"];
      };
    };
  };
  read: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetAccessionResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  update: {
    parameters: {
      path: {
        id: number;
      };
      query: {
        /** If true, do not actually save the accession; just return the result that would have been returned if it had been saved. */
        simulate?: string;
      };
    };
    responses: {
      /** The accession was updated successfully. Response includes fields populated or modified by the server as a result of the update. */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayload"];
        };
      };
      /** The specified accession doesn't exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateAccessionRequestPayload"];
      };
    };
  };
  delete: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  checkIn: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  getAccessionHistory: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetAccessionHistoryResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listPhotos: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** The accession's photos are listed in the response. */
      200: {
        content: {
          "application/json": components["schemas"]["ListPhotosResponsePayload"];
        };
      };
      /** The accession does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio. */
  getPhoto: {
    parameters: {
      path: {
        id: number;
        photoFilename: string;
      };
      query: {
        /** Maximum desired width in pixels. If neither this nor maxHeight is specified, the full-sized original image will be returned. If this is specified, an image no wider than this will be returned. The image may be narrower than this value if needed to preserve the aspect ratio of the original. */
        maxWidth?: string;
        /** Maximum desired height in pixels. If neither this nor maxWidth is specified, the full-sized original image will be returned. If this is specified, an image no taller than this will be returned. The image may be shorter than this value if needed to preserve the aspect ratio of the original. */
        maxHeight?: string;
      };
    };
    responses: {
      /** The photo was successfully retrieved. */
      200: {
        content: {
          "image/jpeg": string;
        };
      };
      /** The accession does not exist, or does not have a photo with the requested filename. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  uploadPhoto: {
    parameters: {
      path: {
        id: number;
        photoFilename: string;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The specified accession does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** The requested photo already exists on the accession. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          file: string;
        };
      };
    };
  };
  /** In test environments, the clock can be advanced artificially, which will cause it to differ from the real-world date and time. */
  getCurrentTime: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetCurrentTimeResponsePayload"];
        };
      };
    };
  };
  recordLogMessage: {
    parameters: {
      path: {
        /** Source of the log message. */
        tag: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
    };
    requestBody: {
      content: {
        "application/json": string;
      };
    };
  };
  getSeedBankSummary: {
    parameters: {
      query: {
        /** If set, return summary on all seedbanks for that organization. */
        organizationId?: string;
        /** If set, return summary on that specific seedbank. */
        facilityId?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SummaryResponse"];
        };
      };
    };
  };
  summarizeAccessionSearch: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SummarizeAccessionSearchResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SummarizeAccessionSearchRequestPayload"];
      };
    };
  };
  listFieldValues: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListFieldValuesResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ListFieldValuesRequestPayload"];
      };
    };
  };
  listAllFieldValues: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListAllFieldValuesResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ListAllFieldValuesRequestPayload"];
      };
    };
  };
  getStorageLocations: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["StorageLocationsResponsePayload"];
        };
      };
    };
  };
  listSpecies: {
    parameters: {
      query: {
        /** Organization whose species should be listed. */
        organizationId: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListSpeciesResponsePayload"];
        };
      };
    };
  };
  createSpecies: {
    responses: {
      /** Species created. */
      200: {
        content: {
          "application/json": components["schemas"]["CreateSpeciesResponsePayload"];
        };
      };
      /** A species with the requested name already exists. */
      409: {
        content: {
          "application/json": components["schemas"]["CreateSpeciesResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SpeciesRequestPayload"];
      };
    };
  };
  getSpeciesDetails: {
    parameters: {
      query: {
        /** Exact scientific name to look up. This name is case-sensitive. */
        scientificName: string;
        /** If specified, only return common names in this language or whose language is unknown. Names with unknown languages are always included. This is a two-letter ISO 639-1 language code. */
        language?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SpeciesLookupDetailsResponsePayload"];
        };
      };
      /** The scientific name was not found in the server's taxonomic database. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets a list of known scientific names whose words begin with particular letters. */
  listSpeciesNames: {
    parameters: {
      query: {
        /** Space-delimited list of word prefixes to search for. Non-alphabetic characters are ignored, and matches are case-insensitive. The order of prefixes is significant; "ag sc" will match "Aglaonema schottianum" but won't match "Scabiosa agrestis". */
        search: string;
        /** Maximum number of results to return. */
        maxResults?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SpeciesLookupNamesResponsePayload"];
        };
      };
    };
  };
  /** Returns details about a problem with a species. */
  getSpeciesProblem: {
    parameters: {
      path: {
        problemId: number;
      };
    };
    responses: {
      /** Problem retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesProblemResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Only valid for problems that include suggested changes. */
  acceptProblemSuggestion: {
    parameters: {
      path: {
        problemId: number;
      };
    };
    responses: {
      /** Suggestion applied. Response contains the updated species information. */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** There is no suggested change for this problem. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  deleteProblem: {
    parameters: {
      path: {
        problemId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** The uploaded file must be in CSV format. A template with the correct headers may be downloaded from the `/api/v1/species/uploads/template` endpoint. */
  uploadSpeciesList: {
    responses: {
      /** The file has been successfully received. It will be processed asynchronously; use the ID returned in the response payload to poll for its status using the `/api/v1/species/uploads/{uploadId}` GET endpoint. */
      200: {
        content: {
          "application/json": components["schemas"]["UploadSpeciesListResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          file: string;
          organizationId?: unknown;
        };
      };
    };
  };
  getSpeciesListUploadTemplate: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": string;
        };
      };
    };
  };
  /** Clients may poll this endpoint to monitor the progress of the file. */
  getSpeciesListUploadStatus: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesUploadStatusResponsePayload"];
        };
      };
    };
  };
  /** This may only be called if the status of the upload is "Awaiting User Action". */
  deleteSpeciesListUpload: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The upload was not awaiting user action. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** This may only be called if the status of the upload is "Awaiting User Action". */
  resolveSpeciesListUpload: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The upload was not awaiting user action. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ResolveSpeciesUploadRequestPayload"];
      };
    };
  };
  getSpecies: {
    parameters: {
      path: {
        speciesId: number;
      };
      query: {
        /** Organization whose information about the species should be returned. */
        organizationId: string;
      };
    };
    responses: {
      /** Species retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  updateSpecies: {
    parameters: {
      path: {
        speciesId: number;
      };
    };
    responses: {
      /** Species updated or merged with an existing species. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SpeciesRequestPayload"];
      };
    };
  };
  /** The species will no longer appear in the organization's list of species, but existing data (plants, seeds, etc.) that refer to the species will still refer to it. */
  deleteSpecies: {
    parameters: {
      path: {
        speciesId: number;
      };
      query: {
        /** Organization from which the species should be deleted. */
        organizationId: string;
      };
    };
    responses: {
      /** Species deleted. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** Cannot delete the species because it is currently in use. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  listTimeseries: {
    parameters: {
      query: {
        deviceId: number[];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListTimeseriesResponsePayload"];
        };
      };
    };
  };
  /** If there are existing timeseries with the same names, the old definitions will be overwritten. */
  createMultipleTimeseries: {
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateTimeseriesRequestPayload"];
      };
    };
  };
  getTimeseriesHistory: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetTimeseriesHistoryResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["GetTimeseriesHistoryRequestPayload"];
      };
    };
  };
  recordTimeseriesValues: {
    responses: {
      /** Successfully processed the request. Note that this status will be returned even if the server was unable to record some of the values. In that case, the failed values will be returned in the response payload. */
      200: {
        content: {
          "application/json": components["schemas"]["RecordTimeseriesValuesResponsePayload"];
        };
      };
      /** The request was valid, but the user is still configuring or placing sensors, so the timeseries values have not been recorded. */
      202: {
        content: {
          "application/json": components["schemas"]["RecordTimeseriesValuesResponsePayload"];
        };
      };
      /** The request had more than 1000 values. */
      413: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RecordTimeseriesValuesRequestPayload"];
      };
    };
  };
  getMyself: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetUserResponsePayload"];
        };
      };
    };
  };
  updateMyself: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateUserRequestPayload"];
      };
    };
  };
  getUserPreferences: {
    parameters: {
      query: {
        /** If present, get the user's per-organization preferences for this organization. If not present, get the user's global preferences. */
        organizationId?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetUserPreferencesResponsePayload"];
        };
      };
    };
  };
  updateUserPreferences: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateUserPreferencesRequestPayload"];
      };
    };
  };
  createAccession: {
    responses: {
      /** The accession was created successfully. Response includes fields populated by the server, including the accession number and ID. */
      200: {
        content: {
          "application/json": components["schemas"]["CreateAccessionResponsePayloadV2"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateAccessionRequestPayloadV2"];
      };
    };
  };
  listViabilityTests: {
    parameters: {
      path: {
        accessionId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListViabilityTestsResponsePayload"];
        };
      };
    };
  };
  /** May cause the accession's remaining quantity to change. */
  createViabilityTest: {
    parameters: {
      path: {
        accessionId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateViabilityTestRequestPayload"];
      };
    };
  };
  getViabilityTest: {
    parameters: {
      path: {
        accessionId: number;
        viabilityTestId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetViabilityTestResponsePayload"];
        };
      };
    };
  };
  /** May cause the accession's remaining quantity to change. */
  updateViabilityTest: {
    parameters: {
      path: {
        accessionId: number;
        viabilityTestId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateViabilityTestRequestPayload"];
      };
    };
  };
  /** May cause the accession's remaining quantity to change. */
  deleteViabilityTest: {
    parameters: {
      path: {
        accessionId: number;
        viabilityTestId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
  };
  listWithdrawals: {
    parameters: {
      path: {
        accessionId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetWithdrawalsResponsePayload"];
        };
      };
    };
  };
  /** May cause the accession's remaining quantity to change. */
  createWithdrawal: {
    parameters: {
      path: {
        accessionId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateWithdrawalRequestPayload"];
      };
    };
  };
  getWithdrawal: {
    parameters: {
      path: {
        accessionId: number;
        withdrawalId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetWithdrawalResponsePayload"];
        };
      };
    };
  };
  /** May cause the accession's remaining quantity to change. */
  updateWithdrawal: {
    parameters: {
      path: {
        accessionId: number;
        withdrawalId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateWithdrawalRequestPayload"];
      };
    };
  };
  /** May cause the accession's remaining quantity to change. */
  deleteWithdrawal: {
    parameters: {
      path: {
        accessionId: number;
        withdrawalId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
    };
  };
  getAccession: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetAccessionResponsePayloadV2"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  updateAccession: {
    parameters: {
      path: {
        id: number;
      };
      query: {
        /** If true, do not actually save the accession; just return the result that would have been returned if it had been saved. */
        simulate?: string;
      };
    };
    responses: {
      /** The accession was updated successfully. Response includes fields populated or modified by the server as a result of the update. */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayloadV2"];
        };
      };
      /** The specified accession doesn't exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateAccessionRequestPayloadV2"];
      };
    };
  };
}

export interface external {}
