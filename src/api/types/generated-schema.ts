/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/api/v1/devices": {
    post: operations["createDevice"];
  };
  "/api/v1/devices/{id}": {
    get: operations["getDevice"];
    put: operations["updateDevice"];
  };
  "/api/v1/facility": {
    /** List all the facilities the current user can access. */
    get: operations["listAllFacilities"];
  };
  "/api/v1/facility/{facilityId}": {
    get: operations["getFacility"];
  };
  "/api/v1/facility/{facilityId}/alert/send": {
    post: operations["sendFacilityAlert"];
  };
  "/api/v1/facility/{facilityId}/automations": {
    get: operations["listAutomations"];
    post: operations["createAutomation"];
  };
  "/api/v1/facility/{facilityId}/automations/{automationId}": {
    get: operations["getAutomation"];
    put: operations["updateAutomation"];
    delete: operations["deleteAutomation"];
  };
  "/api/v1/facility/{facilityId}/devices": {
    get: operations["listFacilityDevices"];
  };
  "/api/v1/login": {
    /** For interactive web applications, this can be used to redirect the user to a login page to allow the application to make other API requests. The login process will set a cookie that will authenticate to the API, and will then redirect back to the application. One approach is to use this in error response handlers: if an API request returns HTTP 401 Unauthorized, set location.href to this endpoint and set "redirect" to the URL of the page the user was on so they'll return there after logging in. */
    get: operations["login"];
  };
  "/api/v1/organizations": {
    /** Lists all organizations the user can access. */
    get: operations["listOrganizations"];
    post: operations["createOrganization"];
  };
  "/api/v1/organizations/{organizationId}": {
    get: operations["getOrganization"];
    put: operations["updateOrganization"];
  };
  "/api/v1/organizations/{organizationId}/projects": {
    /** Only projects that are accessible by the current user are included. */
    get: operations["listOrganizationProjects"];
  };
  "/api/v1/organizations/{organizationId}/users": {
    get: operations["listOrganizationUsers"];
    post: operations["addOrganizationUser"];
  };
  "/api/v1/organizations/{organizationId}/users/{userId}": {
    get: operations["getOrganizationUser"];
    /** Only includes organization-level information that can be modified by organization administrators. Use /api/v1/projects/{projectId}/users/{userId} to change the user's projects. */
    put: operations["updateOrganizationUser"];
    /** Does not remove any data created by the user. */
    delete: operations["deleteOrganizationUser"];
  };
  "/api/v1/projects": {
    get: operations["listAllProjects"];
    post: operations["createProject"];
  };
  "/api/v1/projects/{id}": {
    get: operations["getProject"];
    /** Overwrites existing values; if a payload field is null, any existing value is removed from the project. */
    put: operations["updateProject"];
  };
  "/api/v1/projects/{projectId}/sites": {
    get: operations["listProjectSites"];
  };
  "/api/v1/projects/{projectId}/users/{userId}": {
    /** The user must already be a member of, or already be invited to, the organization. */
    post: operations["addProjectUser"];
    delete: operations["deleteProjectUser"];
  };
  "/api/v1/search": {
    post: operations["search_1"];
  };
  "/api/v1/seedbank/accession": {
    post: operations["create"];
  };
  "/api/v1/seedbank/accession/{id}": {
    get: operations["read"];
    put: operations["update"];
  };
  "/api/v1/seedbank/accession/{id}/checkIn": {
    post: operations["checkIn"];
  };
  "/api/v1/seedbank/accession/{id}/photo": {
    get: operations["listPhotos"];
  };
  "/api/v1/seedbank/accession/{id}/photo/{photoFilename}": {
    /** Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio. */
    get: operations["getPhoto"];
    post: operations["uploadPhoto"];
  };
  "/api/v1/seedbank/clock": {
    /** In test environments, the clock can be advanced artificially, which will cause it to differ from the real-world date and time. */
    get: operations["getCurrentTime"];
  };
  "/api/v1/seedbank/clock/advance": {
    /** Advancing the clock causes any scheduled processes to run. Subsequent GET requests to read the current time will take the advancement into account. Only supported in test and development environments. */
    post: operations["advanceClock"];
  };
  "/api/v1/seedbank/log/{tag}": {
    post: operations["recordLogMessage"];
  };
  "/api/v1/seedbank/notification": {
    get: operations["listAll"];
  };
  "/api/v1/seedbank/notification/all/markRead": {
    post: operations["markAllRead"];
  };
  "/api/v1/seedbank/notification/all/markUnread": {
    /** For development and testing of notifications. Not available in production. */
    post: operations["markAllUnread"];
  };
  "/api/v1/seedbank/notification/{id}/markRead": {
    post: operations["markRead"];
  };
  "/api/v1/seedbank/search": {
    post: operations["searchAccessions"];
  };
  "/api/v1/seedbank/search/export": {
    post: operations["exportAccessions"];
  };
  "/api/v1/seedbank/summary/{facilityId}": {
    get: operations["getSummary"];
  };
  "/api/v1/seedbank/values": {
    post: operations["listFieldValues"];
  };
  "/api/v1/seedbank/values/all": {
    post: operations["listAllFieldValues"];
  };
  "/api/v1/seedbank/values/storageLocation/{facilityId}": {
    get: operations["getStorageLocations"];
  };
  "/api/v1/sites": {
    get: operations["listAllSites"];
    post: operations["createSite"];
  };
  "/api/v1/sites/{siteId}": {
    get: operations["getSite"];
    put: operations["updateSite"];
  };
  "/api/v1/species": {
    get: operations["listSpecies"];
    post: operations["createSpecies"];
  };
  "/api/v1/species/names": {
    get: operations["listAllSpeciesNames"];
    post: operations["createSpeciesName"];
  };
  "/api/v1/species/names/{speciesNameId}": {
    /** Gets information about a single species name. */
    get: operations["getSpeciesName"];
    /** Updates one of the names of a species. */
    put: operations["updateSpeciesName"];
    /** Deletes one of the secondary names of a species. */
    delete: operations["deleteSpeciesName"];
  };
  "/api/v1/species/{speciesId}": {
    get: operations["getSpecies"];
    put: operations["updateSpecies"];
    /** The species will no longer appear in the organization's list of species, but existing data (plants, seeds, etc.) that refer to the species will still refer to it. */
    delete: operations["deleteSpecies"];
  };
  "/api/v1/species/{speciesId}/names": {
    get: operations["listSpeciesNames"];
  };
  "/api/v1/timeseries/create": {
    /** If there are existing timeseries with the same names, the old definitions will be overwritten. */
    post: operations["createMultipleTimeseries"];
  };
  "/api/v1/timeseries/values": {
    post: operations["recordTimeseriesValues"];
  };
  "/api/v1/users/me": {
    get: operations["getMyself"];
    put: operations["updateMyself"];
  };
}

export interface components {
  schemas: {
    AccessionNotificationPayload: {
      /** Unique identifier for this notification. Clients should treat it as opaque. */
      id: string;
      timestamp: string;
      type: "Alert" | "State" | "Date";
      /** If true, this notification has been marked as read. */
      read: boolean;
      /** Plain-text body of notification. */
      text: string;
      /** For accession notifications, which accession caused the notification. */
      accessionId?: number;
      /** For state notifications, which state is being summarized. */
      state?:
        | "Awaiting Check-In"
        | "Pending"
        | "Processing"
        | "Processed"
        | "Drying"
        | "Dried"
        | "In Storage"
        | "Withdrawn"
        | "Nursery";
    };
    AccessionPayload: {
      /** Server-generated human-readable identifier for the accession. This is unique within a single seed bank, but different seed banks may have accessions with the same number. */
      accessionNumber: string;
      /** Server-calculated active indicator. This is based on the accession's state. */
      active: "Inactive" | "Active";
      bagNumbers?: string[];
      checkedInTime?: string;
      collectedDate?: string;
      deviceInfo?: components["schemas"]["DeviceInfoPayload"];
      cutTestSeedsCompromised?: number;
      cutTestSeedsEmpty?: number;
      cutTestSeedsFilled?: number;
      dryingEndDate?: string;
      dryingMoveDate?: string;
      dryingStartDate?: string;
      endangered?: "No" | "Yes" | "Unsure";
      environmentalNotes?: string;
      estimatedSeedCount?: number;
      facilityId: number;
      family?: string;
      fieldNotes?: string;
      founderId?: string;
      geolocations?: components["schemas"]["Geolocation"][];
      germinationTests?: components["schemas"]["GerminationTestPayload"][];
      germinationTestTypes?: ("Lab" | "Nursery")[];
      /** Server-generated unique identifier for the accession. This is unique across all seed banks, but is not suitable for display to end users. */
      id: number;
      /** Initial size of accession. The units of this value must match the measurement type in "processingMethod". */
      initialQuantity?: components["schemas"]["SeedQuantityPayload"];
      landowner?: string;
      latestGerminationTestDate?: string;
      latestViabilityPercent?: number;
      numberOfTrees?: number;
      nurseryStartDate?: string;
      photoFilenames?: string[];
      primaryCollector?: string;
      processingMethod?: "Count" | "Weight";
      processingNotes?: string;
      processingStaffResponsible?: string;
      processingStartDate?: string;
      rare?: "No" | "Yes" | "Unsure";
      receivedDate?: string;
      /** Number or weight of seeds remaining for withdrawal and testing. Calculated by the server when the accession's total size is known. */
      remainingQuantity?: components["schemas"]["SeedQuantityPayload"];
      secondaryCollectors?: string[];
      siteLocation?: string;
      /** Which application this accession originally came from. This is currently based on the presence of the deviceInfo field. */
      source?: "Web" | "SeedCollectorApp";
      sourcePlantOrigin?: "Wild" | "Outplant";
      species?: string;
      /** Server-generated unique ID of the species. */
      speciesId?: number;
      /** Server-calculated accession state. Can change due to modifications to accession data or based on passage of time. */
      state:
        | "Awaiting Check-In"
        | "Pending"
        | "Processing"
        | "Processed"
        | "Drying"
        | "Dried"
        | "In Storage"
        | "Withdrawn"
        | "Nursery";
      storageCondition?: "Refrigerator" | "Freezer";
      storageLocation?: string;
      storagePackets?: number;
      storageNotes?: string;
      storageStaffResponsible?: string;
      storageStartDate?: string;
      subsetCount?: number;
      /** Weight of subset of seeds. Units must be a weight measurement, not "Seeds". */
      subsetWeight?: components["schemas"]["SeedQuantityPayload"];
      targetStorageCondition?: "Refrigerator" | "Freezer";
      /** Total quantity of all past withdrawals, including germination tests. */
      totalPastWithdrawalQuantity?: components["schemas"]["SeedQuantityPayload"];
      /** Total quantity of scheduled withdrawals, not counting germination tests. */
      totalScheduledNonTestQuantity?: components["schemas"]["SeedQuantityPayload"];
      /** Total quantity of scheduled withdrawals for germination tests. */
      totalScheduledTestQuantity?: components["schemas"]["SeedQuantityPayload"];
      /** Total quantity of scheduled withdrawals, including germination tests. */
      totalScheduledWithdrawalQuantity?: components["schemas"]["SeedQuantityPayload"];
      totalViabilityPercent?: number;
      /** Total quantity of all past and scheduled withdrawals, including germination tests. */
      totalWithdrawalQuantity?: components["schemas"]["SeedQuantityPayload"];
      withdrawals?: components["schemas"]["WithdrawalPayload"][];
    };
    AddOrganizationUserRequestPayload: {
      email: string;
      role: "Contributor" | "Admin" | "Owner";
      projectIds?: number[];
    };
    AdvanceClockRequestPayload: {
      days: number;
    };
    AllFieldValuesPayload: {
      /** All the values this field could possibly have, whether or not any accessions have them. For fields that allow the user to enter arbitrary values, this is equivalent to querying the list of values without any filter criteria, that is, it's a list of all the user-entered values. */
      values: string[];
      /** If true, the list of values is too long to return in its entirety and "values" is a partial list. */
      partial: boolean;
    };
    /** Search criterion that matches results that meet all of a set of other search criteria. That is, if the list of children is x, y, and z, this will require x AND y AND z. */
    AndNodePayload: components["schemas"]["SearchNodePayload"] & {
      children?: components["schemas"]["SearchNodePayload"][];
    } & {
      children: unknown;
    };
    AutomationPayload: {
      id: number;
      facilityId: number;
      /** Short human-readable name of this automation. */
      name: string;
      /** Human-readable description of this automation. */
      description?: string;
      /** Client-defined configuration data for this automation. */
      configuration?: { [key: string]: unknown };
    };
    /** Coordinate reference system used for X and Y coordinates in this geometry. By default, coordinates are in WGS 84, with longitude and latitude in degrees. In that case, this element is not present. Otherwise, it specifies which coordinate system to use. */
    CRS: {
      type: "name";
      properties: components["schemas"]["CRSProperties"];
    };
    CRSProperties: {
      /** Name of the coordinate reference system. This must be in the form EPSG:nnnn where nnnn is the numeric identifier of a coordinate system in the EPSG dataset. The default is Longitude/Latitude EPSG:4326, which is the coordinate system +for GeoJSON. */
      name: string;
    };
    CreateAccessionRequestPayload: {
      bagNumbers?: string[];
      collectedDate?: string;
      deviceInfo?: components["schemas"]["DeviceInfoPayload"];
      endangered?: "No" | "Yes" | "Unsure";
      environmentalNotes?: string;
      facilityId?: number;
      family?: string;
      fieldNotes?: string;
      founderId?: string;
      geolocations?: components["schemas"]["Geolocation"][];
      germinationTestTypes?: ("Lab" | "Nursery")[];
      landowner?: string;
      numberOfTrees?: number;
      primaryCollector?: string;
      rare?: "No" | "Yes" | "Unsure";
      receivedDate?: string;
      secondaryCollectors?: string[];
      siteLocation?: string;
      sourcePlantOrigin?: "Wild" | "Outplant";
      species?: string;
    };
    CreateAccessionResponsePayload: {
      accession: components["schemas"]["AccessionPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    CreateAutomationResponsePayload: {
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateDeviceRequestPayload: {
      /** Identifier of facility where this device is located. */
      facilityId: number;
      /** Name of this device. */
      name: string;
      /** High-level type of the device. Device manager may use this in conjunction with the make and model to determine which metrics to report. */
      type: string;
      /** Name of device manufacturer. */
      make: string;
      /** Model number or model name of the device. */
      model: string;
      /** Device manager protocol name. */
      protocol?: string;
      /** Protocol-specific address of device, e.g., an IP address or a Bluetooth device ID. */
      address?: string;
      /** Port number if relevant for the protocol. */
      port?: number;
      /** Protocol- and device-specific custom settings. This is an arbitrary JSON object; the exact settings depend on the device type. */
      settings?: { [key: string]: unknown };
      /** How often the device manager should poll for status updates, in seconds. */
      pollingInterval?: number;
      /** ID of parent device such as a hub or gateway, if any. The parent device must exist. */
      parentId?: number;
    };
    CreateOrganizationRequestPayload: {
      /** ISO 3166 alpha-2 code of organization's country. */
      countryCode?: string;
      /** ISO 3166-2 code of organization's country subdivision (state, province, region, etc.) This is the full ISO 3166-2 code including the country prefix. If this is set, countryCode must also be set. */
      countrySubdivisionCode?: string;
      /** If true or not specified, create a project, site, and seed bank facility automatically. */
      createSeedBank?: boolean;
      description?: string;
      name: string;
    };
    CreateOrganizationUserResponsePayload: {
      /** The ID of the newly-added user. */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateProjectRequestPayload: {
      description?: string;
      name: string;
      organizationId: number;
      startDate?: string;
      status?: "Propagating" | "Planting" | "Completed/Monitoring";
      types?: (
        | "Native Forest Restoration"
        | "Agroforestry"
        | "Silvopasture"
        | "Sustainable Timber"
      )[];
    };
    CreateSiteRequestPayload: {
      description?: string;
      location?: components["schemas"]["Point"];
      locale?: string;
      name: string;
      projectId: number;
      timezone?: string;
    };
    CreateSiteResponsePayload: {
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateSpeciesNameRequestPayload: {
      /** True if name is a scientific name for the species. */
      isScientific?: boolean;
      locale?: string;
      name: string;
      /** Which organization's species list to update. */
      organizationId: number;
      speciesId: number;
    };
    CreateSpeciesNameResponsePayload: {
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateSpeciesResponsePayload: {
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateTimeseriesEntry: {
      /** ID of device that produces this timeseries. */
      deviceId: number;
      /** Name of this timeseries. Duplicate timeseries names for the same device aren't allowed, but different devices can have timeseries with the same name. */
      timeseriesName: string;
      type: "Numeric" | "Text";
      /** Number of significant fractional digits (after the decimal point), if this is a timeseries with non-integer numeric values. */
      decimalPlaces?: number;
      /** Units of measure for values in this timeseries. */
      units?: string;
    };
    CreateTimeseriesRequestPayload: {
      timeseries: components["schemas"]["CreateTimeseriesEntry"][];
    };
    DeviceConfig: {
      /** Unique identifier of this device. */
      id: number;
      /** Identifier of facility where this device is located. */
      facilityId: number;
      /** Name of this device. */
      name: string;
      /** High-level type of the device. Device manager may use this in conjunction with the make and model to determine which metrics to report. */
      type: string;
      /** Name of device manufacturer. */
      make: string;
      /** Model number or model name of the device. */
      model: string;
      /** Device manager protocol name. */
      protocol?: string;
      /** Protocol-specific address of device, e.g., an IP address or a Bluetooth device ID. */
      address?: string;
      /** Port number if relevant for the protocol. */
      port?: number;
      /** Protocol- and device-specific custom settings. This is an arbitrary JSON object; the exact settings depend on the device type. */
      settings?: { [key: string]: unknown };
      /** How often the device manager should poll for status updates, in seconds. */
      pollingInterval?: number;
      /** ID of parent device such as a hub or gateway, if any. */
      parentId?: number;
    };
    /** Details about the device and the application that created the accession. All these values are optional and most of them are platform-dependent. */
    DeviceInfoPayload: {
      /** Build number of application that is submitting the accession, e.g., from React Native getBuildId() */
      appBuild?: string;
      /** Name of application */
      appName?: string;
      /** Brand of device, e.g., from React Native getBrand(). */
      brand?: string;
      /** Model of device hardware, e.g., from React Native getDeviceId(). */
      model?: string;
      /** Name the user has assigned to the device, e.g., from React Native getDeviceName(). */
      name?: string;
      /** Type of operating system, e.g., from React Native getSystemName(). */
      osType?: string;
      /** Version of operating system, e.g., from React Native getSystemVersion(). */
      osVersion?: string;
      /** Unique identifier of the hardware device, e.g., from React Native getUniqueId(). */
      uniqueId?: string;
    };
    ErrorDetails: {
      message: string;
    };
    ExportAccessionsRequestPayload: {
      facilityId: number;
      fields: string[];
      sortOrder?: components["schemas"]["SearchSortOrderElement"][];
      search?:
        | components["schemas"]["AndNodePayload"]
        | components["schemas"]["FieldNodePayload"]
        | components["schemas"]["NotNodePayload"]
        | components["schemas"]["OrNodePayload"];
    };
    FacilityPayload: {
      createdTime: string;
      id: number;
      siteId: number;
      name: string;
      type: "Seed Bank" | "Desalination" | "Reverse Osmosis";
    };
    FieldNodePayload: components["schemas"]["SearchNodePayload"] & {
      field?: string;
      /** List of values to match. For exact and fuzzy searches, a list of at least one value to search for; the list may include null to match accessions where the field does not have a value. For range searches, the list must contain exactly two values, the minimum and maximum; one of the values may be null to search for all values above a minimum or below a maximum. */
      values?: (string | null)[];
      type?: "Exact" | "Fuzzy" | "Range";
    } & {
      field: unknown;
      type: unknown;
      values: unknown;
    };
    FieldValuesPayload: {
      /** List of values in the matching accessions. If there are accessions where the field has no value, this list will contain null (an actual null value, not the string "null"). */
      values: (string | null)[];
      /** If true, the list of values is too long to return in its entirety and "values" is a partial list. */
      partial: boolean;
    };
    Geolocation: {
      latitude: number;
      longitude: number;
      accuracy?: number;
    };
    /** GEOMETRY-FIX-TYPE-ON-CLIENT-SIDE */
    Geometry: {
      type:
        | "Point"
        | "LineString"
        | "Polygon"
        | "MultiPoint"
        | "MultiLineString"
        | "MultiPolygon"
        | "GeometryCollection";
      coordinates: number[];
      crs?: components["schemas"]["CRS"];
    };
    GeometryCollection: components["schemas"]["Geometry"] & {
      geometries?: components["schemas"]["Geometry"][];
    } & {
      geometries: unknown;
    };
    GerminationPayload: {
      recordingDate: string;
      seedsGerminated: number;
    };
    GerminationTestPayload: {
      /** Server-assigned unique ID of this germination test. Null when creating a new test. */
      id?: string;
      /** Which type of test is described. At most one of each test type is allowed. */
      testType: "Lab" | "Nursery";
      startDate?: string;
      endDate?: string;
      seedType?: "Fresh" | "Stored";
      substrate?:
        | "Nursery Media"
        | "Agar Petri Dish"
        | "Paper Petri Dish"
        | "Other";
      treatment?: "Soak" | "Scarify" | "GA3" | "Stratification" | "Other";
      notes?: string;
      /** Quantity of seeds remaining. For weight-based accessions, this is user input and is required. For count-based accessions, it is calculated by the server and ignored on input. */
      remainingQuantity?: components["schemas"]["SeedQuantityPayload"];
      staffResponsible?: string;
      seedsSown?: number;
      totalPercentGerminated?: number;
      totalSeedsGerminated?: number;
      germinations?: components["schemas"]["GerminationPayload"][];
    };
    GetAccessionResponsePayload: {
      accession: components["schemas"]["AccessionPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetAutomationResponsePayload: {
      automation: components["schemas"]["AutomationPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetCurrentTimeResponsePayload: {
      currentTime: string;
      status: components["schemas"]["SuccessOrError"];
    };
    GetDeviceResponsePayload: {
      device: components["schemas"]["DeviceConfig"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetFacilityResponse: {
      facility: components["schemas"]["FacilityPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetOrganizationResponsePayload: {
      organization: components["schemas"]["OrganizationPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetOrganizationUserResponsePayload: {
      user: components["schemas"]["OrganizationUserPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetProjectResponsePayload: {
      project: components["schemas"]["ProjectPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetSiteResponsePayload: {
      site: components["schemas"]["SiteElement"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetSpeciesNameResponsePayload: {
      speciesName: components["schemas"]["SpeciesNamesResponseElement"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetSpeciesResponsePayload: {
      species: components["schemas"]["SpeciesResponseElement"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetUserResponsePayload: {
      user: components["schemas"]["UserProfilePayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    LineString: components["schemas"]["Geometry"] & {
      coordinates?: number[][];
    } & {
      coordinates: unknown;
    };
    ListAccessionNotificationsResponsePayload: {
      notifications: components["schemas"]["AccessionNotificationPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListAllFieldValuesRequestPayload: {
      facilityId: number;
      fields: string[];
    };
    ListAllFieldValuesResponsePayload: {
      results: {
        [key: string]: components["schemas"]["AllFieldValuesPayload"];
      };
      status: components["schemas"]["SuccessOrError"];
    };
    ListAutomationsResponsePayload: {
      automations: components["schemas"]["AutomationPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListDeviceConfigsResponse: {
      devices: components["schemas"]["DeviceConfig"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListFacilitiesResponse: {
      facilities: components["schemas"]["FacilityPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListFieldValuesRequestPayload: {
      facilityId: number;
      fields: string[];
      search?:
        | components["schemas"]["AndNodePayload"]
        | components["schemas"]["FieldNodePayload"]
        | components["schemas"]["NotNodePayload"]
        | components["schemas"]["OrNodePayload"];
    };
    ListFieldValuesResponsePayload: {
      results: { [key: string]: components["schemas"]["FieldValuesPayload"] };
      status: components["schemas"]["SuccessOrError"];
    };
    ListOrganizationUsersResponsePayload: {
      users: components["schemas"]["OrganizationUserPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListOrganizationsResponsePayload: {
      organizations: components["schemas"]["OrganizationPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListPhotosResponseElement: {
      filename: string;
      size: number;
      capturedTime: string;
      /** @deprecated Use location field instead. */
      latitude?: number;
      /** @deprecated Use location field instead. */
      longitude?: number;
      location?: components["schemas"]["Point"];
      /** GPS accuracy in meters. */
      gpsAccuracy?: number;
    };
    ListPhotosResponsePayload: {
      photos: components["schemas"]["ListPhotosResponseElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListProjectsResponsePayload: {
      projects: components["schemas"]["ProjectPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListSitesResponsePayload: {
      sites: components["schemas"]["SiteElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListSpeciesNamesResponsePayload: {
      speciesNames: components["schemas"]["SpeciesNamesResponseElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListSpeciesResponsePayload: {
      species: components["schemas"]["SpeciesResponseElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ModifyAutomationRequestPayload: {
      name: string;
      description?: string;
      configuration?: { [key: string]: unknown };
    };
    MultiLineString: components["schemas"]["Geometry"] & {
      coordinates?: number[][][];
    } & {
      coordinates: unknown;
    };
    MultiPoint: components["schemas"]["Geometry"] & {
      coordinates?: number[][];
    } & {
      coordinates: unknown;
    };
    MultiPolygon: components["schemas"]["Geometry"] & {
      coordinates?: number[][][][];
    } & {
      coordinates: unknown;
    };
    /** Search criterion that matches results that do not match a set of search criteria. */
    NotNodePayload: components["schemas"]["SearchNodePayload"] & {
      child?: components["schemas"]["SearchNodePayload"];
    } & {
      child: unknown;
    };
    /** Search criterion that matches results that meet any of a set of other search criteria. That is, if the list of children is x, y, and z, this will require x OR y OR z. */
    OrNodePayload: components["schemas"]["SearchNodePayload"];
    OrganizationPayload: {
      /** ISO 3166 alpha-2 code of organization's country. */
      countryCode?: string;
      /** ISO 3166-2 code of organization's country subdivision (state, province, region, etc.) This is the full ISO 3166-2 code including the country prefix. If this is set, countryCode will also be set. */
      countrySubdivisionCode?: string;
      createdTime: string;
      description?: string;
      id: number;
      name: string;
      /** This organization's projects. Omitted if depth is "Organization". */
      projects?: components["schemas"]["ProjectPayload"][];
      /** The current user's role in the organization. */
      role: "Contributor" | "Admin" | "Owner";
      /** The total number of users in the organization, including the current user. */
      totalUsers: number;
    };
    OrganizationUserPayload: {
      /** Date and time the user was added to the organization. */
      addedTime: string;
      email: string;
      id: number;
      /** The user's first name. Not present if the user has been added to the organization but has not signed up for an account yet. */
      firstName?: string;
      /** The user's last name. Not present if the user has been added to the organization but has not signed up for an account yet. */
      lastName?: string;
      /** IDs of projects the user is in. Users with admin and owner roles always have access to all projects. */
      projectIds: number[];
      role: "Contributor" | "Admin" | "Owner";
    };
    Point: components["schemas"]["Geometry"] & {
      /** A single position. In the terraware-server API, positions must always include 3 dimensions. The X and Y dimensions use the coordinate system specified by the crs field, and the Z dimension is in meters. */
      coordinates?: number[];
    } & {
      coordinates: unknown;
    };
    Polygon: components["schemas"]["Geometry"] & {
      coordinates?: number[][][];
    } & {
      coordinates: unknown;
    };
    ProjectPayload: {
      createdTime: string;
      description?: string;
      /** If true, the project and its associated sites and facilities should not be displayed to end users. */
      hidden: boolean;
      id: number;
      name: string;
      organizationId: number;
      /** If false, the project is accessible by the entire organization and users may not be added. If true, the project is only accessible by users who are specifically added to it (as well as to admins and owners). */
      organizationWide: boolean;
      sites?: components["schemas"]["SiteElement"][];
      startDate?: string;
      status?: "Propagating" | "Planting" | "Completed/Monitoring";
      /** Total number of users with access to the project. This includes administrators, who have access to all the organization's projects. Only included if the client specifically requested it. */
      totalUsers?: number;
      types?: (
        | "Native Forest Restoration"
        | "Agroforestry"
        | "Silvopasture"
        | "Sustainable Timber"
      )[];
    };
    RecordTimeseriesValuesRequestPayload: {
      timeseries: components["schemas"]["TimeseriesValuesPayload"][];
    };
    /** Results of a request to record timeseries values. */
    RecordTimeseriesValuesResponsePayload: {
      /** List of values that the server failed to record. Will not be included if all the values were recorded successfully. */
      failures?: components["schemas"]["TimeseriesValuesErrorPayload"][];
      status: components["schemas"]["SuccessOrError"];
      error?: components["schemas"]["ErrorDetails"];
    };
    SearchAccessionsRequestPayload: {
      facilityId: number;
      fields: string[];
      sortOrder?: components["schemas"]["SearchSortOrderElement"][];
      search?:
        | components["schemas"]["AndNodePayload"]
        | components["schemas"]["FieldNodePayload"]
        | components["schemas"]["NotNodePayload"]
        | components["schemas"]["OrNodePayload"];
      cursor?: string;
      count: number;
    };
    /** A search criterion. The search will return results that match this criterion. The criterion can be composed of other search criteria to form arbitrary Boolean search expressions. TYPESCRIPT-OVERRIDE-TYPE-WITH-ANY */
    SearchNodePayload: any;
    SearchRequestPayload: {
      /** Prefix for field names. This determines how field names are interpreted, and also how results are structured. Each element in the "results" array in the response will be an instance of whatever entity the prefix points to. Always evaluated starting from the "organizations" level. If not present, the search will return a list of organizations. */
      prefix?: string;
      /** List of fields to return. Field names should be relative to the prefix. They may navigate the data hierarchy using '.' or '_' as delimiters. */
      fields: string[];
      /** How to sort the search results. This controls both the order of the top-level results and the order of any lists of child objects. */
      sortOrder?: components["schemas"]["SearchSortOrderElement"][];
      search?:
        | components["schemas"]["AndNodePayload"]
        | components["schemas"]["FieldNodePayload"]
        | components["schemas"]["NotNodePayload"]
        | components["schemas"]["OrNodePayload"];
      /** Maximum number of top-level search results to return. The system may impose a limit on this value. A separate system-imposed limit may also be applied to lists of child objects inside the top-level results. Use a value of 0 to return the maximum number of allowed results. */
      count: number;
      /** Starting point for search results. If present, a previous search will be continued from where it left off. This should be the value of the cursor that was returned in the response to a previous search. */
      cursor?: string;
    };
    SearchResponsePayload: {
      results: { [key: string]: unknown }[];
      cursor?: string;
    };
    SearchSortOrderElement: {
      field: string;
      direction?: "Ascending" | "Descending";
    };
    /** Represents a quantity of seeds, measured either in individual seeds or by weight. */
    SeedQuantityPayload: {
      /** Number of units of seeds. If "units" is "Seeds", this is the number of seeds and must be an integer. Otherwise it is a measurement in the weight units specified in the "units" field, and may have a fractional part. */
      quantity: number;
      units:
        | "Seeds"
        | "Grams"
        | "Milligrams"
        | "Kilograms"
        | "Ounces"
        | "Pounds";
      /** If this quantity is a weight measurement, the weight in grams. This is not set if the "units" field is "Seeds". This is always calculated on the server side and is ignored on input. */
      grams?: number;
    };
    SendFacilityAlertRequestPayload: {
      subject: string;
      /** Alert body in plain text. HTML alerts are not supported yet. */
      body: string;
    };
    SimpleErrorResponsePayload: {
      error: components["schemas"]["ErrorDetails"];
      status: components["schemas"]["SuccessOrError"];
    };
    SimpleSuccessResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
    };
    SiteElement: {
      createdTime: string;
      description?: string;
      id: number;
      name: string;
      projectId: number;
      location?: components["schemas"]["Point"];
      locale?: string;
      timezone?: string;
      facilities?: components["schemas"]["FacilityPayload"][];
    };
    SpeciesNamesResponseElement: {
      id: number;
      /** True if name is the scientific name for the species. */
      isScientific: boolean;
      name: string;
      organizationId: number;
      speciesId: number;
    };
    SpeciesRequestPayload: {
      conservationStatus?: string;
      /** True if name is the scientific name for the species. */
      isScientific?: boolean;
      name: string;
      /** Which organization's species list to update. */
      organizationId: number;
      plantForm?: "Tree" | "Shrub" | "Vine" | "Liana" | "Herbaceous";
      rare?: "No" | "Yes" | "Unsure";
      /** Taxonomic serial number from ITIS database. */
      tsn?: string;
    };
    SpeciesResponseElement: {
      conservationStatus?: string;
      id: number;
      /** True if name is the scientific name for the species. */
      isScientific: boolean;
      name: string;
      plantForm?: "Tree" | "Shrub" | "Vine" | "Liana" | "Herbaceous";
      rare?: "No" | "Yes" | "Unsure";
      /** Taxonomic serial number from ITIS database. */
      tsn?: string;
    };
    StorageLocationDetails: {
      storageLocation: string;
      storageCondition: "Refrigerator" | "Freezer";
    };
    StorageLocationsResponsePayload: {
      locations: components["schemas"]["StorageLocationDetails"][];
      status: components["schemas"]["SuccessOrError"];
    };
    /** Indicates of success or failure of the requested operation. */
    SuccessOrError: "ok" | "error";
    /** Summary of important statistics about the seed bank for the Summary page. */
    SummaryResponse: {
      activeAccessions: components["schemas"]["SummaryStatistic"];
      species: components["schemas"]["SummaryStatistic"];
      families: components["schemas"]["SummaryStatistic"];
      /** Number of accessions in Pending state overdue for processing */
      overduePendingAccessions: number;
      /** Number of accessions in Processed state overdue for drying */
      overdueProcessedAccessions: number;
      /** Number of accessions in Dried state overdue for storage */
      overdueDriedAccessions: number;
      /** Number of accessions withdrawn so far this week */
      recentlyWithdrawnAccessions: number;
    };
    /** The current value and value as of last week for a summary statistic */
    SummaryStatistic: {
      current: number;
      lastWeek: number;
    };
    TimeseriesValuePayload: {
      timestamp: string;
      /** Value to record. If the timeseries is of type Numeric, this must be a decimal or integer value in string form. If the timeseries is of type Text, this can be an arbitrary string. */
      value: string;
    };
    /** List of values that the server failed to record. Will not be included if all the values were recorded successfully. */
    TimeseriesValuesErrorPayload: {
      /** Device ID as specified in the failing request. */
      deviceId: number;
      /** Name of timeseries as specified in the failing request. */
      timeseriesName: string;
      /** Values that the server was not able to successfully record. */
      values: components["schemas"]["TimeseriesValuePayload"][];
      /** Human-readable details about the failure. */
      message: string;
    };
    TimeseriesValuesPayload: {
      /** ID of device that produced this value. */
      deviceId: number;
      /** Name of timeseries. This must be the name of a timeseries that has already been created for the device. */
      timeseriesName: string;
      values: components["schemas"]["TimeseriesValuePayload"][];
    };
    UpdateAccessionRequestPayload: {
      bagNumbers?: string[];
      collectedDate?: string;
      cutTestSeedsCompromised?: number;
      cutTestSeedsEmpty?: number;
      cutTestSeedsFilled?: number;
      dryingEndDate?: string;
      dryingMoveDate?: string;
      dryingStartDate?: string;
      endangered?: "No" | "Yes" | "Unsure";
      environmentalNotes?: string;
      family?: string;
      fieldNotes?: string;
      founderId?: string;
      geolocations?: components["schemas"]["Geolocation"][];
      germinationTestTypes?: ("Lab" | "Nursery")[];
      germinationTests?: components["schemas"]["GerminationTestPayload"][];
      /** Initial size of accession. The units of this value must match the measurement type in "processingMethod". */
      initialQuantity?: components["schemas"]["SeedQuantityPayload"];
      landowner?: string;
      numberOfTrees?: number;
      nurseryStartDate?: string;
      primaryCollector?: string;
      processingMethod?: "Count" | "Weight";
      processingNotes?: string;
      processingStaffResponsible?: string;
      processingStartDate?: string;
      rare?: "No" | "Yes" | "Unsure";
      receivedDate?: string;
      secondaryCollectors?: string[];
      siteLocation?: string;
      sourcePlantOrigin?: "Wild" | "Outplant";
      species?: string;
      storageLocation?: string;
      storageNotes?: string;
      storagePackets?: number;
      storageStaffResponsible?: string;
      storageStartDate?: string;
      subsetCount?: number;
      /** Weight of subset of seeds. Units must be a weight measurement, not "Seeds". */
      subsetWeight?: components["schemas"]["SeedQuantityPayload"];
      targetStorageCondition?: "Refrigerator" | "Freezer";
      withdrawals?: components["schemas"]["WithdrawalPayload"][];
    };
    UpdateAccessionResponsePayload: {
      accession: components["schemas"]["AccessionPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    UpdateDeviceRequestPayload: {
      /** Name of this device. */
      name: string;
      /** High-level type of the device. Device manager may use this in conjunction with the make and model to determine which metrics to report. */
      type: string;
      /** Name of device manufacturer. */
      make: string;
      /** Model number or model name of the device. */
      model: string;
      /** Device manager protocol name. */
      protocol?: string;
      /** Protocol-specific address of device, e.g., an IP address or a Bluetooth device ID. */
      address?: string;
      /** Port number if relevant for the protocol. */
      port?: number;
      /** Protocol- and device-specific custom settings. This is an arbitrary JSON object; the exact settings depend on the device type. */
      settings?: { [key: string]: unknown };
      /** How often the device manager should poll for status updates, in seconds. */
      pollingInterval?: number;
      /** ID of parent device such as a hub or gateway, if any. The parent device must exist. */
      parentId?: number;
    };
    UpdateOrganizationRequestPayload: {
      /** ISO 3166 alpha-2 code of organization's country. */
      countryCode?: string;
      /** ISO 3166-2 code of organization's country subdivision (state, province, region, etc.) This is the full ISO 3166-2 code including the country prefix. If this is set, countryCode must also be set. */
      countrySubdivisionCode?: string;
      description?: string;
      name: string;
    };
    UpdateOrganizationUserRequestPayload: {
      role: "Contributor" | "Admin" | "Owner";
    };
    UpdateProjectRequestPayload: {
      description?: string;
      name: string;
      startDate?: string;
      status?: "Propagating" | "Planting" | "Completed/Monitoring";
      types?: (
        | "Native Forest Restoration"
        | "Agroforestry"
        | "Silvopasture"
        | "Sustainable Timber"
      )[];
    };
    UpdateSiteRequestPayload: {
      description?: string;
      location?: components["schemas"]["Point"];
      locale?: string;
      name: string;
      /** If present, move the site to this project. Project must be owned by the same organization as the site's current project. User must have permission to add sites to the new project and remove them from the existing one. */
      projectId?: number;
      timezone?: string;
    };
    UpdateSpeciesNameRequestPayload: {
      /** True if name is a scientific name for the species. */
      isScientific?: boolean;
      locale?: string;
      name: string;
    };
    UpdateUserRequestPayload: {
      /** If true, the user wants to receive all the notifications for their organization and projects via email. This does not apply to certain kinds of notifications such as "You've been added to a new organization." If null, leave the existing value as-is. */
      emailNotificationsEnabled?: boolean;
      firstName: string;
      lastName: string;
    };
    UploadPhotoMetadataPayload: {
      capturedTime: string;
      /** @deprecated Use location field instead. */
      latitude?: number;
      /** @deprecated Use location field instead. */
      longitude?: number;
      location?: components["schemas"]["Point"];
      /** GPS accuracy in meters. */
      gpsAccuracy?: number;
    };
    UserProfilePayload: {
      /** User's unique ID. This should not be shown to the user, but is a required input to some API endpoints. */
      id: number;
      email: string;
      /** If true, the user wants to receive all the notifications for their organization and projects via email. This does not apply to certain kinds of notifications such as "You've been added to a new organization." */
      emailNotificationsEnabled: boolean;
      firstName?: string;
      lastName?: string;
    };
    WithdrawalPayload: {
      /** Server-assigned unique ID of this withdrawal, its ID. Omit when creating a new withdrawal. */
      id?: number;
      date: string;
      purpose:
        | "Propagation"
        | "Outreach or Education"
        | "Research"
        | "Broadcast"
        | "Share with Another Site"
        | "Other"
        | "Germination Testing";
      destination?: string;
      notes?: string;
      /** Quantity of seeds remaining. For weight-based accessions, this is user input and is required. For count-based accessions, it is calculated by the server and ignored on input. */
      remainingQuantity?: components["schemas"]["SeedQuantityPayload"];
      staffResponsible?: string;
      /** If this withdrawal is of type "Germination Testing", the ID of the test it is associated with. This is always set by the server and cannot be modified. */
      germinationTestId?: number;
      /** For weight-based accessions, the difference between the weight remaining before this withdrawal and the weight remaining after it. This is a server-calculated value and is ignored on input. */
      weightDifference?: components["schemas"]["SeedQuantityPayload"];
      /** Quantity of seeds withdrawn. For germination testing withdrawals, this is always the same as the test's "seedsSown" value, if that value is present. Otherwise, it is a user-supplied value. For count-based accessions, the units must always be "Seeds". For weight-based accessions, the units may either be a weight measurement or "Seeds". */
      withdrawnQuantity?: components["schemas"]["SeedQuantityPayload"];
      /** The best estimate of the number of seeds withdrawn. This is the same as "withdrawnQuantity" if that is present, or else the same as "weightDifference" if this is a weight-based accession. If this is a count-based accession and "withdrawnQuantity" does not have a value, this field will not be present. This is a server-calculated value and is ignored on input. */
      estimatedQuantity?: components["schemas"]["SeedQuantityPayload"];
    };
  };
}

export interface operations {
  createDevice: {
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateDeviceRequestPayload"];
      };
    };
  };
  getDevice: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** Device configuration retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["GetDeviceResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  updateDevice: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** Device configuration updated. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateDeviceRequestPayload"];
      };
    };
  };
  /** List all the facilities the current user can access. */
  listAllFacilities: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListFacilitiesResponse"];
        };
      };
    };
  };
  getFacility: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetFacilityResponse"];
        };
      };
    };
  };
  sendFacilityAlert: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SendFacilityAlertRequestPayload"];
      };
    };
  };
  listAutomations: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ListAutomationsResponsePayload"];
        };
      };
      /** The facility does not exist or is not accessible. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  createAutomation: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["CreateAutomationResponsePayload"];
        };
      };
      /** The facility does not exist or is not accessible. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ModifyAutomationRequestPayload"];
      };
    };
  };
  getAutomation: {
    parameters: {
      path: {
        facilityId: number;
        automationId: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetAutomationResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  updateAutomation: {
    parameters: {
      path: {
        facilityId: number;
        automationId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ModifyAutomationRequestPayload"];
      };
    };
  };
  deleteAutomation: {
    parameters: {
      path: {
        facilityId: number;
        automationId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listFacilityDevices: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** Successfully listed the facility's devices. */
      200: {
        content: {
          "application/json": components["schemas"]["ListDeviceConfigsResponse"];
        };
      };
      /** The facility does not exist or is not accessible by the current user. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** For interactive web applications, this can be used to redirect the user to a login page to allow the application to make other API requests. The login process will set a cookie that will authenticate to the API, and will then redirect back to the application. One approach is to use this in error response handlers: if an API request returns HTTP 401 Unauthorized, set location.href to this endpoint and set "redirect" to the URL of the page the user was on so they'll return there after logging in. */
  login: {
    parameters: {
      query: {
        redirect: string;
      };
    };
    responses: {
      /** Redirects to a login page. After login, the user will be redirected back to the URL specified in the "redirect" parameter. */
      302: never;
    };
  };
  /** Lists all organizations the user can access. */
  listOrganizations: {
    parameters: {
      query: {
        depth?: "Organization" | "Project" | "Site" | "Facility";
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListOrganizationsResponsePayload"];
        };
      };
    };
  };
  createOrganization: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetOrganizationResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateOrganizationRequestPayload"];
      };
    };
  };
  getOrganization: {
    parameters: {
      path: {
        organizationId: number;
      };
      query: {
        depth?: "Organization" | "Project" | "Site" | "Facility";
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetOrganizationResponsePayload"];
        };
      };
    };
  };
  updateOrganization: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateOrganizationRequestPayload"];
      };
    };
  };
  /** Only projects that are accessible by the current user are included. */
  listOrganizationProjects: {
    parameters: {
      path: {
        organizationId: number;
      };
      query: {
        totalUsers?: boolean;
      };
    };
    responses: {
      /** Projects retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["ListProjectsResponsePayload"];
        };
      };
      /** The user is not a member of the organization, or the organization does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listOrganizationUsers: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListOrganizationUsersResponsePayload"];
        };
      };
    };
  };
  addOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateOrganizationUserResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AddOrganizationUserRequestPayload"];
      };
    };
  };
  getOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
        userId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetOrganizationUserResponsePayload"];
        };
      };
    };
  };
  /** Only includes organization-level information that can be modified by organization administrators. Use /api/v1/projects/{projectId}/users/{userId} to change the user's projects. */
  updateOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
        userId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The user is not a member of the organization. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** An organization must have at least one owner; cannot change the role of an organization's only owner. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateOrganizationUserRequestPayload"];
      };
    };
  };
  /** Does not remove any data created by the user. */
  deleteOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
        userId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The user is not a member of the organization. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** The user is the organization's only owner and an organization must have at least one owner. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listAllProjects: {
    parameters: {
      query: {
        totalUsers?: boolean;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListProjectsResponsePayload"];
        };
      };
    };
  };
  createProject: {
    responses: {
      /** Project created. */
      200: {
        content: {
          "application/json": components["schemas"]["GetProjectResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateProjectRequestPayload"];
      };
    };
  };
  getProject: {
    parameters: {
      path: {
        id: number;
      };
      query: {
        totalUsers?: boolean;
      };
    };
    responses: {
      /** Project retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["GetProjectResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Overwrites existing values; if a payload field is null, any existing value is removed from the project. */
  updateProject: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateProjectRequestPayload"];
      };
    };
  };
  listProjectSites: {
    parameters: {
      path: {
        projectId: number;
      };
      query: {
        srid?: number;
      };
    };
    responses: {
      /** Retrieved list of sites. */
      200: {
        content: {
          "application/json": components["schemas"]["ListSitesResponsePayload"];
        };
      };
      /** The project does not exist or is not accessible. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** The user must already be a member of, or already be invited to, the organization. */
  addProjectUser: {
    parameters: {
      path: {
        projectId: number;
        userId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The user does not exist or is not a member of the organization. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** The user is already a member of the project, or the project is organization-wide. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  deleteProjectUser: {
    parameters: {
      path: {
        projectId: number;
        userId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The user does not exist or is not a member of the project. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  search_1: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SearchResponsePayload"];
          "text/csv": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SearchRequestPayload"];
      };
    };
  };
  create: {
    responses: {
      /** The accession was created successfully. Response includes fields populated by the server, including the accession number and ID. */
      200: {
        content: {
          "application/json": components["schemas"]["CreateAccessionResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateAccessionRequestPayload"];
      };
    };
  };
  read: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetAccessionResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  update: {
    parameters: {
      path: {
        id: number;
      };
      query: {
        simulate?: boolean;
      };
    };
    responses: {
      /** The accession was updated successfully. Response includes fields populated or modified by the server as a result of the update. */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayload"];
        };
      };
      /** The specified accession doesn't exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateAccessionRequestPayload"];
      };
    };
  };
  checkIn: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listPhotos: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** The accession's photos are listed in the response. */
      200: {
        content: {
          "application/json": components["schemas"]["ListPhotosResponsePayload"];
        };
      };
      /** The accession does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio. */
  getPhoto: {
    parameters: {
      path: {
        id: number;
        photoFilename: string;
      };
      query: {
        maxWidth?: number;
        maxHeight?: number;
      };
    };
    responses: {
      /** The photo was successfully retrieved. */
      200: {
        content: {
          "image/jpeg": string;
        };
      };
      /** The accession does not exist, or does not have a photo with the requested filename. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  uploadPhoto: {
    parameters: {
      path: {
        id: number;
        photoFilename: string;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The specified accession does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** The requested photo already exists on the accession. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          file: string;
          metadata: components["schemas"]["UploadPhotoMetadataPayload"];
        };
      };
    };
  };
  /** In test environments, the clock can be advanced artificially, which will cause it to differ from the real-world date and time. */
  getCurrentTime: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetCurrentTimeResponsePayload"];
        };
      };
    };
  };
  /** Advancing the clock causes any scheduled processes to run. Subsequent GET requests to read the current time will take the advancement into account. Only supported in test and development environments. */
  advanceClock: {
    responses: {
      /** The clock has been advanced. The response includes the newly-adjusted time. */
      200: {
        content: {
          "application/json": components["schemas"]["GetCurrentTimeResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AdvanceClockRequestPayload"];
      };
    };
  };
  recordLogMessage: {
    parameters: {
      path: {
        tag: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
    };
    requestBody: {
      content: {
        "application/json": { [key: string]: { [key: string]: unknown } };
      };
    };
  };
  listAll: {
    parameters: {
      query: {
        facilityId: number;
        /** Don't return notifications older than this; default is 1 month ago */
        since?: string;
        /** Return at most this many notifications; default is no limit */
        limit?: number;
      };
    };
    responses: {
      /** Notifications in reverse time order (newest first). */
      200: {
        content: {
          "application/json": components["schemas"]["ListAccessionNotificationsResponsePayload"];
        };
      };
    };
  };
  markAllRead: {
    responses: {
      /** All notifications have been marked as read. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  /** For development and testing of notifications. Not available in production. */
  markAllUnread: {
    responses: {
      /** All notifications have been marked as unread. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  markRead: {
    parameters: {
      path: {
        /** ID of notification to mark as read */
        id: string;
      };
    };
    responses: {
      /** Notification has been marked as read. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested notification ID was not valid. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  searchAccessions: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SearchResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SearchAccessionsRequestPayload"];
      };
    };
  };
  exportAccessions: {
    responses: {
      /** Export succeeded. */
      200: {
        content: {
          "text/csv": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ExportAccessionsRequestPayload"];
      };
    };
  };
  getSummary: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SummaryResponse"];
        };
      };
    };
  };
  listFieldValues: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListFieldValuesResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ListFieldValuesRequestPayload"];
      };
    };
  };
  listAllFieldValues: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListAllFieldValuesResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ListAllFieldValuesRequestPayload"];
      };
    };
  };
  getStorageLocations: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["StorageLocationsResponsePayload"];
        };
      };
    };
  };
  listAllSites: {
    parameters: {
      query: {
        srid?: number;
      };
    };
    responses: {
      /** Retrieved list of sites. */
      200: {
        content: {
          "application/json": components["schemas"]["ListSitesResponsePayload"];
        };
      };
    };
  };
  createSite: {
    responses: {
      /** Site created. */
      200: {
        content: {
          "application/json": components["schemas"]["CreateSiteResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateSiteRequestPayload"];
      };
    };
  };
  getSite: {
    parameters: {
      path: {
        siteId: number;
      };
      query: {
        srid?: number;
      };
    };
    responses: {
      /** Site retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["GetSiteResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  updateSite: {
    parameters: {
      path: {
        siteId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateSiteRequestPayload"];
      };
    };
  };
  listSpecies: {
    parameters: {
      query: {
        organizationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListSpeciesResponsePayload"];
        };
      };
    };
  };
  createSpecies: {
    responses: {
      /** Species created. */
      200: {
        content: {
          "application/json": components["schemas"]["CreateSpeciesResponsePayload"];
        };
      };
      /** A species with the requested name already exists. */
      409: {
        content: {
          "application/json": components["schemas"]["CreateSpeciesResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SpeciesRequestPayload"];
      };
    };
  };
  listAllSpeciesNames: {
    parameters: {
      query: {
        organizationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListSpeciesNamesResponsePayload"];
        };
      };
    };
  };
  createSpeciesName: {
    responses: {
      /** Species name added. */
      200: {
        content: {
          "application/json": components["schemas"]["CreateSpeciesNameResponsePayload"];
        };
      };
      /** The species does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** The species already has the requested name. */
      409: {
        content: {
          "application/json": components["schemas"]["CreateSpeciesNameResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateSpeciesNameRequestPayload"];
      };
    };
  };
  /** Gets information about a single species name. */
  getSpeciesName: {
    parameters: {
      path: {
        speciesNameId: number;
      };
    };
    responses: {
      /** Species name retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesNameResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Updates one of the names of a species. */
  updateSpeciesName: {
    parameters: {
      path: {
        speciesNameId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateSpeciesNameRequestPayload"];
      };
    };
  };
  /** Deletes one of the secondary names of a species. */
  deleteSpeciesName: {
    parameters: {
      path: {
        speciesNameId: number;
      };
    };
    responses: {
      /** Species name deleted. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** Cannot delete the primary name of a species. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  getSpecies: {
    parameters: {
      path: {
        speciesId: number;
      };
      query: {
        organizationId: number;
      };
    };
    responses: {
      /** Species retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  updateSpecies: {
    parameters: {
      path: {
        speciesId: number;
      };
    };
    responses: {
      /** Species updated or merged with an existing species. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SpeciesRequestPayload"];
      };
    };
  };
  /** The species will no longer appear in the organization's list of species, but existing data (plants, seeds, etc.) that refer to the species will still refer to it. */
  deleteSpecies: {
    parameters: {
      path: {
        speciesId: number;
      };
      query: {
        organizationId: number;
      };
    };
    responses: {
      /** Species deleted. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** Cannot delete the species because it is currently in use. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  listSpeciesNames: {
    parameters: {
      path: {
        speciesId: number;
      };
      query: {
        organizationId: number;
      };
    };
    responses: {
      /** Species names retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["ListSpeciesNamesResponsePayload"];
        };
      };
      /** The species does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** If there are existing timeseries with the same names, the old definitions will be overwritten. */
  createMultipleTimeseries: {
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateTimeseriesRequestPayload"];
      };
    };
  };
  recordTimeseriesValues: {
    responses: {
      /** Successfully processed the request. Note that this status will be returned even if the server was unable to record some of the values. In that case, the failed values will be returned in the response payload. */
      200: {
        content: {
          "application/json": components["schemas"]["RecordTimeseriesValuesResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RecordTimeseriesValuesRequestPayload"];
      };
    };
  };
  getMyself: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetUserResponsePayload"];
        };
      };
    };
  };
  updateMyself: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateUserRequestPayload"];
      };
    };
  };
}

export interface external {}
