/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/api/v1/devices': {
    post: operations['createDevice'];
  };
  '/api/v1/devices/{id}': {
    get: operations['getDevice'];
    put: operations['updateDevice'];
  };
  '/api/v1/facility': {
    /** List all the facilities the current user can access. */
    get: operations['listAllFacilities'];
  };
  '/api/v1/facility/{facilityId}': {
    get: operations['getFacility'];
  };
  '/api/v1/facility/{facilityId}/devices': {
    get: operations['listFacilityDevices'];
  };
  '/api/v1/gis/features': {
    post: operations['create_4'];
  };
  '/api/v1/gis/features/list/{layerId}': {
    get: operations['list_1'];
  };
  '/api/v1/gis/features/{featureId}': {
    get: operations['read_2'];
    put: operations['update_4'];
    delete: operations['delete_1'];
  };
  '/api/v1/gis/features/{featureId}/photos': {
    get: operations['listFeaturePhotos'];
    post: operations['createFeaturePhoto'];
  };
  '/api/v1/gis/features/{featureId}/photos/{photoId}': {
    /** Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio. */
    get: operations['downloadFeaturePhoto'];
    delete: operations['deleteFeaturePhoto'];
  };
  '/api/v1/gis/features/{featureId}/photos/{photoId}/metadata': {
    get: operations['getFeaturePhotoMetadata'];
  };
  '/api/v1/gis/layers': {
    post: operations['create_3'];
  };
  '/api/v1/gis/layers/list/{siteId}': {
    get: operations['list'];
  };
  '/api/v1/gis/layers/{layerId}': {
    get: operations['read_1'];
    put: operations['update_3'];
    delete: operations['delete'];
  };
  '/api/v1/gis/plant_observations': {
    post: operations['create_2'];
  };
  '/api/v1/gis/plant_observations/list/{featureId}': {
    get: operations['getList'];
  };
  '/api/v1/gis/plant_observations/{plantObservationId}': {
    get: operations['get_1'];
    put: operations['update_2'];
  };
  '/api/v1/gis/plants': {
    post: operations['create_1'];
  };
  '/api/v1/gis/plants/list/summary/{layerId}': {
    get: operations['getPlantSummary'];
  };
  '/api/v1/gis/plants/list/{layerId}': {
    get: operations['getPlantsList'];
  };
  '/api/v1/gis/plants/{featureId}': {
    get: operations['get'];
    put: operations['update_1'];
  };
  '/api/v1/login': {
    /** For interactive web applications, this can be used to redirect the user to a login page to allow the application to make other API requests. The login process will set a cookie that will authenticate to the API, and will then redirect back to the application. One approach is to use this in error response handlers: if an API request returns HTTP 401 Unauthorized, set location.href to this endpoint and set "redirect" to the URL of the page the user was on so they'll return there after logging in. */
    get: operations['login'];
  };
  '/api/v1/organization': {
    /** List all organizations the user can access. */
    get: operations['listAll_1'];
  };
  '/api/v1/organizations/{organizationId}/projects': {
    /** Only projects that are accessible by the current user are included. */
    get: operations['listOrganizationProjects'];
  };
  '/api/v1/projects': {
    get: operations['listAllProjects'];
    post: operations['createProject'];
  };
  '/api/v1/projects/{id}': {
    get: operations['getProject'];
    put: operations['updateProject'];
  };
  '/api/v1/projects/{projectId}/sites': {
    get: operations['listProjectSites'];
  };
  '/api/v1/seedbank/accession': {
    post: operations['create'];
  };
  '/api/v1/seedbank/accession/{id}': {
    get: operations['read'];
    put: operations['update'];
  };
  '/api/v1/seedbank/accession/{id}/photo': {
    get: operations['listPhotos'];
  };
  '/api/v1/seedbank/accession/{id}/photo/{photoFilename}': {
    /** Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio. */
    get: operations['getPhoto'];
    post: operations['uploadPhoto'];
  };
  '/api/v1/seedbank/clock': {
    /** In test environments, the clock can be advanced artificially, which will cause it to differ from the real-world date and time. */
    get: operations['getCurrentTime'];
  };
  '/api/v1/seedbank/clock/advance': {
    /** Advancing the clock causes any scheduled processes to run. Subsequent GET requests to read the current time will take the advancement into account. Only supported in test and development environments. */
    post: operations['advanceClock'];
  };
  '/api/v1/seedbank/log/{tag}': {
    post: operations['recordLogMessage'];
  };
  '/api/v1/seedbank/notification': {
    get: operations['listAll'];
  };
  '/api/v1/seedbank/notification/all/markRead': {
    post: operations['markAllRead'];
  };
  '/api/v1/seedbank/notification/all/markUnread': {
    /** For development and testing of notifications. Not available in production. */
    post: operations['markAllUnread'];
  };
  '/api/v1/seedbank/notification/{id}/markRead': {
    post: operations['markRead'];
  };
  '/api/v1/seedbank/search': {
    post: operations['search'];
  };
  '/api/v1/seedbank/search/export': {
    post: operations['export'];
  };
  '/api/v1/seedbank/summary/{facilityId}': {
    get: operations['getSummary'];
  };
  '/api/v1/seedbank/timeseries/create': {
    /** If there are existing timeseries with the same names, the old definitions will be overwritten. */
    post: operations['createMultipleTimeseries'];
  };
  '/api/v1/seedbank/timeseries/values': {
    post: operations['recordTimeseriesValues'];
  };
  '/api/v1/seedbank/values': {
    post: operations['listFieldValues'];
  };
  '/api/v1/seedbank/values/all': {
    post: operations['listAllFieldValues'];
  };
  '/api/v1/seedbank/values/species': {
    /** Use /api/v1/species instead. */
    get: operations['listSpecies'];
    /** Use /api/v1/species instead. */
    post: operations['createSpecies'];
  };
  '/api/v1/seedbank/values/species/{id}': {
    /** Use /api/v1/species instead. */
    post: operations['updateSpecies'];
  };
  '/api/v1/seedbank/values/storageLocation/{facilityId}': {
    get: operations['getStorageLocations'];
  };
  '/api/v1/sites': {
    get: operations['listAllSites'];
  };
  '/api/v1/sites/{siteId}': {
    get: operations['getSite'];
  };
  '/api/v1/species': {
    get: operations['speciesList'];
    post: operations['speciesCreate'];
  };
  '/api/v1/species/names': {
    get: operations['speciesNamesListAll'];
    post: operations['speciesNameCreate'];
  };
  '/api/v1/species/names/{speciesNameId}': {
    /** Gets information about a single species name. */
    get: operations['speciesNameGet'];
    /** Updates one of the names of a species. */
    put: operations['speciesNameUpdate'];
    /** Deletes one of the secondary names of a species. */
    delete: operations['speciesNameDelete'];
  };
  '/api/v1/species/{speciesId}': {
    get: operations['speciesRead'];
    put: operations['speciesUpdate'];
    delete: operations['speciesDelete'];
  };
  '/api/v1/species/{speciesId}/names': {
    get: operations['speciesNamesList'];
  };
}

export interface components {
  schemas: {
    AccessionPayload: {
      /** Server-generated human-readable identifier for the accession. This is unique within a single seed bank, but different seed banks may have accessions with the same number. */
      accessionNumber: string;
      /** Server-calculated active indicator. This is based on the accession's state. */
      active: 'Inactive' | 'Active';
      bagNumbers?: string[];
      collectedDate?: string;
      deviceInfo?: components['schemas']['DeviceInfoPayload'];
      cutTestSeedsCompromised?: number;
      cutTestSeedsEmpty?: number;
      cutTestSeedsFilled?: number;
      dryingEndDate?: string;
      dryingMoveDate?: string;
      dryingStartDate?: string;
      endangered?: 'No' | 'Yes' | 'Unsure';
      environmentalNotes?: string;
      estimatedSeedCount?: number;
      facilityId: number;
      family?: string;
      fieldNotes?: string;
      founderId?: string;
      geolocations?: components['schemas']['Geolocation'][];
      germinationTests?: components['schemas']['GerminationTestPayload'][];
      germinationTestTypes?: ('Lab' | 'Nursery')[];
      /** Server-generated unique identifier for the accession. This is unique across all seed banks, but is not suitable for display to end users. */
      id: number;
      /** Initial size of accession. The units of this value must match the measurement type in "processingMethod". */
      initialQuantity?: components['schemas']['SeedQuantityPayload'];
      landowner?: string;
      latestGerminationTestDate?: string;
      latestViabilityPercent?: number;
      numberOfTrees?: number;
      nurseryStartDate?: string;
      photoFilenames?: string[];
      primaryCollector?: string;
      processingMethod?: 'Count' | 'Weight';
      processingNotes?: string;
      processingStaffResponsible?: string;
      processingStartDate?: string;
      rare?: 'No' | 'Yes' | 'Unsure';
      receivedDate?: string;
      /** Number or weight of seeds remaining for withdrawal and testing. Calculated by the server when the accession's total size is known. */
      remainingQuantity?: components['schemas']['SeedQuantityPayload'];
      secondaryCollectors?: string[];
      siteLocation?: string;
      /** Which application this accession originally came from. This is currently based on the presence of the deviceInfo field. */
      source?: 'Web' | 'SeedCollectorApp';
      sourcePlantOrigin?: 'Wild' | 'Outplant';
      species?: string;
      /** Server-generated unique ID of the species. */
      speciesId?: number;
      /** Server-calculated accession state. Can change due to modifications to accession data or based on passage of time. */
      state:
        | 'Pending'
        | 'Processing'
        | 'Processed'
        | 'Drying'
        | 'Dried'
        | 'In Storage'
        | 'Withdrawn'
        | 'Nursery';
      storageCondition?: 'Refrigerator' | 'Freezer';
      storageLocation?: string;
      storagePackets?: number;
      storageNotes?: string;
      storageStaffResponsible?: string;
      storageStartDate?: string;
      subsetCount?: number;
      /** Weight of subset of seeds. Units must be a weight measurement, not "Seeds". */
      subsetWeight?: components['schemas']['SeedQuantityPayload'];
      targetStorageCondition?: 'Refrigerator' | 'Freezer';
      /** Total quantity of all past withdrawals, including germination tests. */
      totalPastWithdrawalQuantity?: components['schemas']['SeedQuantityPayload'];
      /** Total quantity of scheduled withdrawals, not counting germination tests. */
      totalScheduledNonTestQuantity?: components['schemas']['SeedQuantityPayload'];
      /** Total quantity of scheduled withdrawals for germination tests. */
      totalScheduledTestQuantity?: components['schemas']['SeedQuantityPayload'];
      /** Total quantity of scheduled withdrawals, including germination tests. */
      totalScheduledWithdrawalQuantity?: components['schemas']['SeedQuantityPayload'];
      totalViabilityPercent?: number;
      /** Total quantity of all past and scheduled withdrawals, including germination tests. */
      totalWithdrawalQuantity?: components['schemas']['SeedQuantityPayload'];
      withdrawals?: components['schemas']['WithdrawalPayload'][];
    };
    AdvanceClockRequestPayload: {
      days: number;
    };
    AllFieldValuesPayload: {
      /** All the values this field could possibly have, whether or not any accessions have them. For fields that allow the user to enter arbitrary values, this is equivalent to querying the list of values without any filter criteria, that is, it's a list of all the user-entered values. */
      values: string[];
      /** If true, the list of values is too long to return in its entirety and "values" is a partial list. */
      partial: boolean;
    };
    /** Search criterion that matches results that meet all of a set of other search criteria. That is, if the list of children is x, y, and z, this will require x AND y AND z. */
    AndNodePayload: components['schemas']['SearchNodePayload'] & {
      children?: components['schemas']['SearchNodePayload'][];
    } & {
      children: unknown;
    };
    /** Coordinate reference system used for X and Y coordinates in this geometry. By default, coordinates are in WGS 84, with longitude and latitude in degrees. In that case, this element is not present. Otherwise, it specifies which coordinate system to use. */
    CRS: {
      type: 'name';
      properties: components['schemas']['CRSProperties'];
    };
    CRSProperties: {
      /** Name of the coordinate reference system. This must be in the form EPSG:nnnn where nnnn is the numeric identifier of a coordinate system in the EPSG dataset. The default is Longitude/Latitude EPSG:4326, which is the coordinate system +for GeoJSON. */
      name: string;
    };
    CreateAccessionRequestPayload: {
      bagNumbers?: string[];
      collectedDate?: string;
      deviceInfo?: components['schemas']['DeviceInfoPayload'];
      endangered?: 'No' | 'Yes' | 'Unsure';
      environmentalNotes?: string;
      facilityId?: number;
      family?: string;
      fieldNotes?: string;
      founderId?: string;
      geolocations?: components['schemas']['Geolocation'][];
      germinationTestTypes?: ('Lab' | 'Nursery')[];
      landowner?: string;
      numberOfTrees?: number;
      primaryCollector?: string;
      rare?: 'No' | 'Yes' | 'Unsure';
      receivedDate?: string;
      secondaryCollectors?: string[];
      siteLocation?: string;
      sourcePlantOrigin?: 'Wild' | 'Outplant';
      species?: string;
    };
    CreateAccessionResponsePayload: {
      accession: components['schemas']['AccessionPayload'];
      status: components['schemas']['SuccessOrError'];
    };
    CreateDeviceRequestPayload: {
      /** Identifier of facility where this device is located. */
      facilityId: number;
      /** Name of this device. */
      name: string;
      /** High-level type of the device. Device manager may use this in conjunction with the make and model to determine which metrics to report. */
      type: string;
      /** Name of device manufacturer. */
      make: string;
      /** Model number or model name of the device. */
      model: string;
      /** Device manager protocol name. */
      protocol?: string;
      /** Protocol-specific address of device, e.g., an IP address or a Bluetooth device ID. */
      address?: string;
      /** Port number if relevant for the protocol. */
      port?: number;
      /** Protocol- and device-specific custom settings. This is an arbitrary JSON object; the exact settings depend on the device type. */
      settings?: { [key: string]: unknown };
      /** How often the device manager should poll for status updates, in seconds. */
      pollingInterval?: number;
      /** ID of parent device such as a hub or gateway, if any. The parent device must exist. */
      parentId?: number;
    };
    CreateFeaturePhotoRequestPayload: {
      capturedTime: string;
      /** Compass heading of phone/camera when photo was taken. */
      heading?: number;
      location?: components['schemas']['Point'];
      /** Orientation of phone/camera when photo was taken. */
      orientation?: number;
      /** GPS horizontal accuracy in meters. */
      gpsHorizAccuracy?: number;
      /** GPS vertical (altitude) accuracy in meters. */
      gpsVertAccuracy?: number;
    };
    CreateFeaturePhotoResponsePayload: {
      photoId: number;
      status: components['schemas']['SuccessOrError'];
    };
    CreateFeatureRequestPayload: {
      layerId: number;
      geom?: components['schemas']['Geometry'];
      gpsHorizAccuracy?: number;
      gpsVertAccuracy?: number;
      attrib?: string;
      notes?: string;
      enteredTime?: string;
    };
    CreateFeatureResponsePayload: {
      feature: components['schemas']['FeatureResponse'];
      status: components['schemas']['SuccessOrError'];
    };
    CreateLayerRequestPayload: {
      siteId: number;
      layerType:
        | 'Aerial Photos'
        | 'Surface Color Map'
        | 'Terrain Color Map'
        | 'Boundaries'
        | 'Plants Planted'
        | 'Plants Existing'
        | 'Irrigation'
        | 'Infrastructure'
        | 'Partner Input'
        | 'Restoration Zones'
        | 'Site Prep'
        | 'Map notes';
      tileSetName: string;
      proposed: boolean;
      hidden: boolean;
    };
    CreateLayerResponsePayload: {
      layer: components['schemas']['LayerResponse'];
      status: components['schemas']['SuccessOrError'];
    };
    CreateObservationRequestPayload: {
      featureId: number;
      timestamp: string;
      healthState?: 'Good' | 'Moderate' | 'Poor' | 'Dead';
      flowers?: boolean;
      seeds?: boolean;
      pests?: string;
      /** Height in meters */
      height?: number;
      /** Diameter at breast height in meters */
      diameterAtBreastHeight?: number;
    };
    CreateObservationResponsePayload: {
      resp: components['schemas']['ObservationResponse'];
      status: components['schemas']['SuccessOrError'];
    };
    CreatePlantRequestPayload: {
      featureId: number;
      label?: string;
      speciesId?: number;
      naturalRegen?: boolean;
      datePlanted?: string;
    };
    CreatePlantResponsePayload: {
      plant: components['schemas']['PlantResponse'];
      status: components['schemas']['SuccessOrError'];
    };
    CreateProjectRequestPayload: {
      name: string;
      organizationId: number;
    };
    CreateSpeciesRequestPayload: {
      name: string;
    };
    CreateSpeciesResponsePayload: {
      details: components['schemas']['SpeciesDetails'];
      status: components['schemas']['SuccessOrError'];
    };
    CreateTimeseriesEntry: {
      /** ID of device that produces this timeseries. */
      deviceId: number;
      /** Name of this timeseries. Duplicate timeseries names for the same device aren't allowed, but different devices can have timeseries with the same name. */
      timeseriesName: string;
      type: 'Numeric' | 'Text';
      /** Number of significant fractional digits (after the decimal point), if this is a timeseries with non-integer numeric values. */
      decimalPlaces?: number;
      /** Units of measure for values in this timeseries. */
      units?: string;
    };
    CreateTimeseriesRequestPayload: {
      timeseries: components['schemas']['CreateTimeseriesEntry'][];
    };
    DeleteFeatureResponsePayload: {
      id: number;
      status: components['schemas']['SuccessOrError'];
    };
    DeleteLayerResponse: {
      id: number;
      siteId: number;
    };
    DeleteLayerResponsePayload: {
      layer: components['schemas']['DeleteLayerResponse'];
      status: components['schemas']['SuccessOrError'];
    };
    DeviceConfig: {
      /** Unique identifier of this device. */
      id: number;
      /** Identifier of facility where this device is located. */
      facilityId: number;
      /** Name of this device. */
      name: string;
      /** High-level type of the device. Device manager may use this in conjunction with the make and model to determine which metrics to report. */
      type: string;
      /** Name of device manufacturer. */
      make: string;
      /** Model number or model name of the device. */
      model: string;
      /** Device manager protocol name. */
      protocol?: string;
      /** Protocol-specific address of device, e.g., an IP address or a Bluetooth device ID. */
      address?: string;
      /** Port number if relevant for the protocol. */
      port?: number;
      /** Protocol- and device-specific custom settings. This is an arbitrary JSON object; the exact settings depend on the device type. */
      settings?: { [key: string]: unknown };
      /** How often the device manager should poll for status updates, in seconds. */
      pollingInterval?: number;
      /** ID of parent device such as a hub or gateway, if any. */
      parentId?: number;
    };
    /** Details about the device and the application that created the accession. All these values are optional and most of them are platform-dependent. */
    DeviceInfoPayload: {
      /** Build number of application that is submitting the accession, e.g., from React Native getBuildId() */
      appBuild?: string;
      /** Name of application */
      appName?: string;
      /** Brand of device, e.g., from React Native getBrand(). */
      brand?: string;
      /** Model of device hardware, e.g., from React Native getDeviceId(). */
      model?: string;
      /** Name the user has assigned to the device, e.g., from React Native getDeviceName(). */
      name?: string;
      /** Type of operating system, e.g., from React Native getSystemName(). */
      osType?: string;
      /** Version of operating system, e.g., from React Native getSystemVersion(). */
      osVersion?: string;
      /** Unique identifier of the hardware device, e.g., from React Native getUniqueId(). */
      uniqueId?: string;
    };
    ErrorDetails: {
      message: string;
    };
    ExportRequestPayload: {
      facilityId: number;
      fields: components['schemas']['SearchField'][];
      sortOrder?: components['schemas']['SearchSortOrderElement'][];
      filters?: components['schemas']['SearchFilter'][];
      search?:
        | components['schemas']['AndNodePayload']
        | components['schemas']['FieldNodePayload']
        | components['schemas']['NotNodePayload']
        | components['schemas']['OrNodePayload'];
    };
    FacilityPayload: {
      id: number;
      name: string;
      type: 'Seed Bank' | 'Desalination' | 'Reverse Osmosis';
      /** The name of the role the current user has at the facility. */
      role: string;
    };
    FeaturePhoto: {
      capturedTime: string;
      contentType: string;
      featureId: number;
      fileName: string;
      /** GPS horizontal accuracy in meters. */
      gpsHorizAccuracy?: number;
      /** GPS vertical (altitude) accuracy in meters. */
      gpsVertAccuracy?: number;
      /** Compass heading of phone/camera when photo was taken. */
      heading?: number;
      id: number;
      location?: components['schemas']['Point'];
      /** Orientation of phone/camera when photo was taken. */
      orientation?: number;
      size: number;
    };
    /** Describes a map feature. The coordinate reference system of the "geom" field will be longitude/latitude EPSG:4326. */
    FeatureResponse: {
      id: number;
      layerId: number;
      geom?: components['schemas']['Geometry'];
      gpsHorizAccuracy?: number;
      gpsVertAccuracy?: number;
      attrib?: string;
      notes?: string;
      enteredTime?: string;
    };
    FieldNodePayload: components['schemas']['SearchNodePayload'] & {
      field?: components['schemas']['SearchField'];
      /** List of values to match. For exact and fuzzy searches, a list of at least one value to search for; the list may include null to match accessions where the field does not have a value. For range searches, the list must contain exactly two values, the minimum and maximum; one of the values may be null to search for all values above a minimum or below a maximum. */
      values?: (string | null)[];
      type?: 'Exact' | 'Fuzzy' | 'Range';
    } & {
      field: unknown;
      type: unknown;
      values: unknown;
    };
    FieldValuesPayload: {
      /** List of values in the matching accessions. If there are accessions where the field has no value, this list will contain null (an actual null value, not the string "null"). */
      values: (string | null)[];
      /** If true, the list of values is too long to return in its entirety and "values" is a partial list. */
      partial: boolean;
    };
    Geolocation: {
      latitude: number;
      longitude: number;
      accuracy?: number;
    };
    /** GEOMETRY-FIX-TYPE-ON-CLIENT-SIDE */
    Geometry: {
      type:
        | 'Point'
        | 'LineString'
        | 'Polygon'
        | 'MultiPoint'
        | 'MultiLineString'
        | 'MultiPolygon'
        | 'GeometryCollection';
      coordinates: number[];
      crs?: components['schemas']['CRS'];
    };
    GeometryCollection: components['schemas']['Geometry'] & {
      geometries?: components['schemas']['Geometry'][];
    } & {
      geometries: unknown;
    };
    GerminationPayload: {
      recordingDate: string;
      seedsGerminated: number;
    };
    GerminationTestPayload: {
      /** Server-assigned unique ID of this germination test. Null when creating a new test. */
      id?: string;
      /** Which type of test is described. At most one of each test type is allowed. */
      testType: 'Lab' | 'Nursery';
      startDate?: string;
      endDate?: string;
      seedType?: 'Fresh' | 'Stored';
      substrate?:
        | 'Nursery Media'
        | 'Agar Petri Dish'
        | 'Paper Petri Dish'
        | 'Other';
      treatment?: 'Soak' | 'Scarify' | 'GA3' | 'Stratification' | 'Other';
      notes?: string;
      /** Quantity of seeds remaining. For weight-based accessions, this is user input and is required. For count-based accessions, it is calculated by the server and ignored on input. */
      remainingQuantity?: components['schemas']['SeedQuantityPayload'];
      staffResponsible?: string;
      seedsSown?: number;
      totalPercentGerminated?: number;
      totalSeedsGerminated?: number;
      germinations?: components['schemas']['GerminationPayload'][];
    };
    GetAccessionResponsePayload: {
      accession: components['schemas']['AccessionPayload'];
      status: components['schemas']['SuccessOrError'];
    };
    GetCurrentTimeResponsePayload: {
      currentTime: string;
      status: components['schemas']['SuccessOrError'];
    };
    GetDeviceResponsePayload: {
      device: components['schemas']['DeviceConfig'];
      status: components['schemas']['SuccessOrError'];
    };
    GetFacilityResponse: {
      facility: components['schemas']['FacilityPayload'];
      status: components['schemas']['SuccessOrError'];
    };
    GetFeaturePhotoMetadataResponsePayload: {
      photo: components['schemas']['FeaturePhoto'];
      status: components['schemas']['SuccessOrError'];
    };
    GetFeatureResponsePayload: {
      feature: components['schemas']['FeatureResponse'];
      status: components['schemas']['SuccessOrError'];
    };
    GetLayerResponsePayload: {
      layer: components['schemas']['LayerResponse'];
      status: components['schemas']['SuccessOrError'];
    };
    GetObservationResponsePayload: {
      resp: components['schemas']['ObservationResponse'];
      status: components['schemas']['SuccessOrError'];
    };
    GetPlantResponsePayload: {
      plant: components['schemas']['PlantResponse'];
      status: components['schemas']['SuccessOrError'];
    };
    GetProjectResponsePayload: {
      project: components['schemas']['ProjectPayload'];
      status: components['schemas']['SuccessOrError'];
    };
    GetSiteResponsePayload: {
      site: components['schemas']['SiteElement'];
      status: components['schemas']['SuccessOrError'];
    };
    LayerResponse: {
      id: number;
      siteId: number;
      layerType:
        | 'Aerial Photos'
        | 'Surface Color Map'
        | 'Terrain Color Map'
        | 'Boundaries'
        | 'Plants Planted'
        | 'Plants Existing'
        | 'Irrigation'
        | 'Infrastructure'
        | 'Partner Input'
        | 'Restoration Zones'
        | 'Site Prep'
        | 'Map notes';
      tileSetName?: string;
      proposed: boolean;
      hidden: boolean;
    };
    LineString: components['schemas']['Geometry'] & {
      coordinates?: number[][];
    } & {
      coordinates: unknown;
    };
    ListAllFieldValuesRequestPayload: {
      facilityId: number;
      fields: components['schemas']['SearchField'][];
    };
    ListAllFieldValuesResponsePayload: {
      results: {
        [key: string]: components['schemas']['AllFieldValuesPayload'];
      };
      status: components['schemas']['SuccessOrError'];
    };
    ListDeviceConfigsResponse: {
      devices: components['schemas']['DeviceConfig'][];
      status: components['schemas']['SuccessOrError'];
    };
    ListFacilitiesResponse: {
      facilities: components['schemas']['FacilityPayload'][];
      status: components['schemas']['SuccessOrError'];
    };
    ListFeaturePhotosResponsePayload: {
      photos: components['schemas']['FeaturePhoto'][];
      status: components['schemas']['SuccessOrError'];
    };
    ListFeaturesResponsePayload: {
      features: components['schemas']['FeatureResponse'][];
      totalCount: number;
      status: components['schemas']['SuccessOrError'];
    };
    ListFieldValuesRequestPayload: {
      facilityId: number;
      fields: components['schemas']['SearchField'][];
      filters?: components['schemas']['SearchFilter'][];
      search?:
        | components['schemas']['AndNodePayload']
        | components['schemas']['FieldNodePayload']
        | components['schemas']['NotNodePayload']
        | components['schemas']['OrNodePayload'];
    };
    ListFieldValuesResponsePayload: {
      results: { [key: string]: components['schemas']['FieldValuesPayload'] };
      status: components['schemas']['SuccessOrError'];
    };
    ListLayersResponsePayload: {
      layers: components['schemas']['LayerResponse'][];
      status: components['schemas']['SuccessOrError'];
    };
    ListObservationsResponsePayload: {
      list: components['schemas']['ObservationResponse'][];
      status: components['schemas']['SuccessOrError'];
    };
    ListOrganizationsElement: {
      id: number;
      name: string;
    };
    ListOrganizationsResponse: {
      organizations: components['schemas']['ListOrganizationsElement'][];
    };
    ListPhotosResponseElement: {
      filename: string;
      size: number;
      capturedTime: string;
      /** Use location field instead. */
      latitude?: number;
      /** Use location field instead. */
      longitude?: number;
      location?: components['schemas']['Point'];
      /** GPS accuracy in meters. */
      gpsAccuracy?: number;
    };
    ListPhotosResponsePayload: {
      photos: components['schemas']['ListPhotosResponseElement'][];
      status: components['schemas']['SuccessOrError'];
    };
    ListPlantsResponseElement: {
      featureId: number;
      label?: string;
      speciesId?: number;
      naturalRegen?: boolean;
      datePlanted?: string;
      layerId: number;
      gpsHorizAccuracy?: number;
      gpsVertAccuracy?: number;
      attrib?: string;
      notes?: string;
      enteredTime?: string;
      geom?: components['schemas']['Geometry'];
    };
    ListPlantsResponsePayload: {
      list: components['schemas']['ListPlantsResponseElement'][];
      status: components['schemas']['SuccessOrError'];
    };
    ListProjectsResponsePayload: {
      projects: components['schemas']['ProjectPayload'][];
      status: components['schemas']['SuccessOrError'];
    };
    ListSitesResponsePayload: {
      sites: components['schemas']['SiteElement'][];
      status: components['schemas']['SuccessOrError'];
    };
    ListSpeciesResponsePayload: {
      values: components['schemas']['SpeciesDetails'][];
      status: components['schemas']['SuccessOrError'];
    };
    MultiLineString: components['schemas']['Geometry'] & {
      coordinates?: number[][][];
    } & {
      coordinates: unknown;
    };
    MultiPoint: components['schemas']['Geometry'] & {
      coordinates?: number[][];
    } & {
      coordinates: unknown;
    };
    MultiPolygon: components['schemas']['Geometry'] & {
      coordinates?: number[][][][];
    } & {
      coordinates: unknown;
    };
    /** Search criterion that matches results that do not match a set of search criteria. */
    NotNodePayload: components['schemas']['SearchNodePayload'] & {
      child?: components['schemas']['SearchNodePayload'];
    } & {
      child: unknown;
    };
    NotificationListResponse: {
      notifications: components['schemas']['NotificationPayload'][];
      status: components['schemas']['SuccessOrError'];
    };
    NotificationPayload: {
      /** Unique identifier for this notification. Clients should treat it as opaque. */
      id: string;
      timestamp: string;
      type: 'Alert' | 'State' | 'Date';
      /** If true, this notification has been marked as read. */
      read: boolean;
      /** Plain-text body of notification. */
      text: string;
      /** For accession notifications, which accession caused the notification. */
      accessionId?: number;
      /** For state notifications, which state is being summarized. */
      state?:
        | 'Pending'
        | 'Processing'
        | 'Processed'
        | 'Drying'
        | 'Dried'
        | 'In Storage'
        | 'Withdrawn'
        | 'Nursery';
    };
    ObservationResponse: {
      id: number;
      featureId: number;
      timestamp: string;
      healthState?: 'Good' | 'Moderate' | 'Poor' | 'Dead';
      flowers?: boolean;
      seeds?: boolean;
      pests?: string;
      /** Height in meters */
      height?: number;
      /** Diameter at breast height in meters */
      diameterAtBreastHeight?: number;
    };
    /** Search criterion that matches results that meet any of a set of other search criteria. That is, if the list of children is x, y, and z, this will require x OR y OR z. */
    OrNodePayload: components['schemas']['SearchNodePayload'];
    PlantResponse: {
      featureId: number;
      label?: string;
      speciesId?: number;
      naturalRegen?: boolean;
      datePlanted?: string;
    };
    PlantSummaryResponsePayload: {
      summary: { [key: string]: number };
      status: components['schemas']['SuccessOrError'];
    };
    Point: components['schemas']['Geometry'] & {
      /** A single position. In the terraware-server API, positions must always include 3 dimensions. The X and Y dimensions use the coordinate system specified by the crs field, and the Z dimension is in meters. */
      coordinates?: number[];
    } & {
      coordinates: unknown;
    };
    Polygon: components['schemas']['Geometry'] & {
      coordinates?: number[][][];
    } & {
      coordinates: unknown;
    };
    ProjectPayload: {
      id: number;
      name: string;
      organizationId: number;
    };
    RecordTimeseriesValuesRequestPayload: {
      timeseries: components['schemas']['TimeseriesValuesPayload'][];
    };
    /** Results of a request to record timeseries values. */
    RecordTimeseriesValuesResponsePayload: {
      /** List of values that the server failed to record. Will not be included if all the values were recorded successfully. */
      failures?: components['schemas']['TimeseriesValuesPayload'][];
      status: components['schemas']['SuccessOrError'];
      error?: components['schemas']['ErrorDetails'];
    };
    SearchField:
      | 'accessionNumber'
      | 'active'
      | 'bagNumber'
      | 'collectedDate'
      | 'collectionNotes'
      | 'cutTestSeedsCompromised'
      | 'cutTestSeedsEmpty'
      | 'cutTestSeedsFilled'
      | 'dryingEndDate'
      | 'dryingMoveDate'
      | 'dryingStartDate'
      | 'endangered'
      | 'estimatedSeedsIncoming'
      | 'family'
      | 'geolocation'
      | 'germinationEndDate'
      | 'germinationPercentGerminated'
      | 'germinationSeedType'
      | 'germinationSeedsGerminated'
      | 'germinationSeedsSown'
      | 'germinationStartDate'
      | 'germinationSubstrate'
      | 'germinationTestNotes'
      | 'germinationTestType'
      | 'germinationTreatment'
      | 'id'
      | 'landowner'
      | 'latestGerminationTestDate'
      | 'latestViabilityPercent'
      | 'nurseryStartDate'
      | 'primaryCollector'
      | 'processingMethod'
      | 'processingNotes'
      | 'processingStartDate'
      | 'rare'
      | 'receivedDate'
      | 'remainingGrams'
      | 'remainingQuantity'
      | 'remainingUnits'
      | 'siteLocation'
      | 'sourcePlantOrigin'
      | 'species'
      | 'state'
      | 'storageCondition'
      | 'storageLocation'
      | 'storageNotes'
      | 'storagePackets'
      | 'storageStartDate'
      | 'targetStorageCondition'
      | 'totalGrams'
      | 'totalQuantity'
      | 'totalUnits'
      | 'totalViabilityPercent'
      | 'treesCollectedFrom'
      | 'viabilityTestType'
      | 'withdrawalDate'
      | 'withdrawalDestination'
      | 'withdrawalGrams'
      | 'withdrawalNotes'
      | 'withdrawalPurpose'
      | 'withdrawalQuantity'
      | 'withdrawalRemainingGrams'
      | 'withdrawalRemainingQuantity'
      | 'withdrawalRemainingUnits'
      | 'withdrawalUnits';
    SearchFilter: {
      field: components['schemas']['SearchField'];
      /** List of values to match. For exact and fuzzy searches, a list of at least one value to search for; the list may include null to match accessions where the field does not have a value. For range searches, the list must contain exactly two values, the minimum and maximum; one of the values may be null to search for all values above a minimum or below a maximum. */
      values: (string | null)[];
      type: 'Exact' | 'Fuzzy' | 'Range';
    };
    /** A search criterion. The search will return results that match this criterion. The criterion can be composed of other search criteria to form arbitrary Boolean search expressions. TYPESCRIPT-OVERRIDE-TYPE-WITH-ANY */
    SearchNodePayload: any;
    SearchRequestPayload: {
      facilityId: number;
      fields: components['schemas']['SearchField'][];
      sortOrder?: components['schemas']['SearchSortOrderElement'][];
      filters?: components['schemas']['SearchFilter'][];
      search?:
        | components['schemas']['AndNodePayload']
        | components['schemas']['FieldNodePayload']
        | components['schemas']['NotNodePayload']
        | components['schemas']['OrNodePayload'];
      cursor?: string;
      count: number;
    };
    SearchResponsePayload: {
      results: { [key: string]: string }[];
      cursor?: string;
    };
    SearchSortOrderElement: {
      field: components['schemas']['SearchField'];
      direction?: 'Ascending' | 'Descending';
    };
    /** Represents a quantity of seeds, measured either in individual seeds or by weight. */
    SeedQuantityPayload: {
      /** Number of units of seeds. If "units" is "Seeds", this is the number of seeds and must be an integer. Otherwise it is a measurement in the weight units specified in the "units" field, and may have a fractional part. */
      quantity: number;
      units:
        | 'Seeds'
        | 'Grams'
        | 'Milligrams'
        | 'Kilograms'
        | 'Ounces'
        | 'Pounds';
      /** If this quantity is a weight measurement, the weight in grams. This is not set if the "units" field is "Seeds". This is always calculated on the server side and is ignored on input. */
      grams?: number;
    };
    SimpleErrorResponsePayload: {
      error: components['schemas']['ErrorDetails'];
      status: components['schemas']['SuccessOrError'];
    };
    SimpleSuccessResponsePayload: {
      status: components['schemas']['SuccessOrError'];
    };
    SiteElement: {
      id: number;
      name: string;
      projectId: number;
      location: components['schemas']['Point'];
      locale?: string;
      timezone?: string;
    };
    SpeciesCreateResponsePayload: {
      id: number;
      status: components['schemas']['SuccessOrError'];
    };
    SpeciesDetails: {
      id: number;
      name: string;
    };
    SpeciesGetResponsePayload: {
      species: components['schemas']['SpeciesResponseElement'];
      status: components['schemas']['SuccessOrError'];
    };
    SpeciesListResponsePayload: {
      species: components['schemas']['SpeciesResponseElement'][];
      status: components['schemas']['SuccessOrError'];
    };
    SpeciesNameCreateResponsePayload: {
      id: number;
      status: components['schemas']['SuccessOrError'];
    };
    SpeciesNameGetResponsePayload: {
      speciesName: components['schemas']['SpeciesNamesResponseElement'];
      status: components['schemas']['SuccessOrError'];
    };
    SpeciesNameRequestPayload: {
      /** True if name is a scientific name for the species. */
      isScientific?: boolean;
      locale?: string;
      name: string;
      speciesId: number;
    };
    SpeciesNamesListResponsePayload: {
      speciesNames: components['schemas']['SpeciesNamesResponseElement'][];
      status: components['schemas']['SuccessOrError'];
    };
    SpeciesNamesResponseElement: {
      id: number;
      /** True if name is the scientific name for the species. */
      isScientific: boolean;
      name: string;
      speciesId: number;
    };
    SpeciesRequestPayload: {
      conservationStatus?: string;
      familyId?: number;
      /** True if name is the scientific name for the species. */
      isScientific?: boolean;
      name: string;
      plantForm?: 'Tree' | 'Shrub' | 'Vine' | 'Liana' | 'Herbaceous';
      rare?: 'No' | 'Yes' | 'Unsure';
      /** Taxonomic serial number from ITIS database. */
      tsn?: string;
    };
    SpeciesResponseElement: {
      conservationStatus?: string;
      familyId?: number;
      id: number;
      /** True if name is the scientific name for the species. */
      isScientific: boolean;
      name: string;
      plantForm?: 'Tree' | 'Shrub' | 'Vine' | 'Liana' | 'Herbaceous';
      rare?: 'No' | 'Yes' | 'Unsure';
      /** Taxonomic serial number from ITIS database. */
      tsn?: string;
    };
    StorageLocationDetails: {
      storageLocation: string;
      storageCondition: 'Refrigerator' | 'Freezer';
    };
    StorageLocationsResponsePayload: {
      locations: components['schemas']['StorageLocationDetails'][];
      status: components['schemas']['SuccessOrError'];
    };
    /** Indicates of success or failure of the requested operation. */
    SuccessOrError: 'ok' | 'error';
    /** Summary of important statistics about the seed bank for the Summary page. */
    SummaryResponse: {
      activeAccessions: components['schemas']['SummaryStatistic'];
      species: components['schemas']['SummaryStatistic'];
      families: components['schemas']['SummaryStatistic'];
      /** Number of accessions in Pending state overdue for processing */
      overduePendingAccessions: number;
      /** Number of accessions in Processed state overdue for drying */
      overdueProcessedAccessions: number;
      /** Number of accessions in Dried state overdue for storage */
      overdueDriedAccessions: number;
      /** Number of accessions withdrawn so far this week */
      recentlyWithdrawnAccessions: number;
    };
    /** The current value and value as of last week for a summary statistic */
    SummaryStatistic: {
      current: number;
      lastWeek: number;
    };
    TimeseriesValuePayload: {
      timestamp: string;
      /** Value to record. If the timeseries is of type Numeric, this must be a decimal or integer value in string form. If the timeseries is of type Text, this can be an arbitrary string. */
      value: string;
    };
    TimeseriesValuesPayload: {
      /** ID of device that produced this value. */
      deviceId: number;
      /** Name of timeseries. This must be the name of a timeseries that has already been created for the device. */
      timeseriesName: string;
      values: components['schemas']['TimeseriesValuePayload'][];
    };
    UpdateAccessionRequestPayload: {
      bagNumbers?: string[];
      collectedDate?: string;
      cutTestSeedsCompromised?: number;
      cutTestSeedsEmpty?: number;
      cutTestSeedsFilled?: number;
      dryingEndDate?: string;
      dryingMoveDate?: string;
      dryingStartDate?: string;
      endangered?: 'No' | 'Yes' | 'Unsure';
      environmentalNotes?: string;
      family?: string;
      fieldNotes?: string;
      founderId?: string;
      geolocations?: components['schemas']['Geolocation'][];
      germinationTestTypes?: ('Lab' | 'Nursery')[];
      germinationTests?: components['schemas']['GerminationTestPayload'][];
      /** Initial size of accession. The units of this value must match the measurement type in "processingMethod". */
      initialQuantity?: components['schemas']['SeedQuantityPayload'];
      landowner?: string;
      numberOfTrees?: number;
      nurseryStartDate?: string;
      primaryCollector?: string;
      processingMethod?: 'Count' | 'Weight';
      processingNotes?: string;
      processingStaffResponsible?: string;
      processingStartDate?: string;
      rare?: 'No' | 'Yes' | 'Unsure';
      receivedDate?: string;
      secondaryCollectors?: string[];
      siteLocation?: string;
      sourcePlantOrigin?: 'Wild' | 'Outplant';
      species?: string;
      storageLocation?: string;
      storageNotes?: string;
      storagePackets?: number;
      storageStaffResponsible?: string;
      storageStartDate?: string;
      subsetCount?: number;
      /** Weight of subset of seeds. Units must be a weight measurement, not "Seeds". */
      subsetWeight?: components['schemas']['SeedQuantityPayload'];
      targetStorageCondition?: 'Refrigerator' | 'Freezer';
      withdrawals?: components['schemas']['WithdrawalPayload'][];
    };
    UpdateAccessionResponsePayload: {
      accession: components['schemas']['AccessionPayload'];
      status: components['schemas']['SuccessOrError'];
    };
    UpdateDeviceRequestPayload: {
      /** Name of this device. */
      name: string;
      /** High-level type of the device. Device manager may use this in conjunction with the make and model to determine which metrics to report. */
      type: string;
      /** Name of device manufacturer. */
      make: string;
      /** Model number or model name of the device. */
      model: string;
      /** Device manager protocol name. */
      protocol?: string;
      /** Protocol-specific address of device, e.g., an IP address or a Bluetooth device ID. */
      address?: string;
      /** Port number if relevant for the protocol. */
      port?: number;
      /** Protocol- and device-specific custom settings. This is an arbitrary JSON object; the exact settings depend on the device type. */
      settings?: { [key: string]: unknown };
      /** How often the device manager should poll for status updates, in seconds. */
      pollingInterval?: number;
      /** ID of parent device such as a hub or gateway, if any. The parent device must exist. */
      parentId?: number;
    };
    UpdateFeatureRequestPayload: {
      layerId: number;
      geom?: components['schemas']['Geometry'];
      gpsHorizAccuracy?: number;
      gpsVertAccuracy?: number;
      attrib?: string;
      notes?: string;
      enteredTime?: string;
    };
    UpdateFeatureResponsePayload: {
      feature: components['schemas']['FeatureResponse'];
      status: components['schemas']['SuccessOrError'];
    };
    UpdateLayerRequestPayload: {
      siteId: number;
      layerType:
        | 'Aerial Photos'
        | 'Surface Color Map'
        | 'Terrain Color Map'
        | 'Boundaries'
        | 'Plants Planted'
        | 'Plants Existing'
        | 'Irrigation'
        | 'Infrastructure'
        | 'Partner Input'
        | 'Restoration Zones'
        | 'Site Prep'
        | 'Map notes';
      tileSetName: string;
      proposed: boolean;
      hidden: boolean;
    };
    UpdateLayerResponsePayload: {
      layer: components['schemas']['LayerResponse'];
      status: components['schemas']['SuccessOrError'];
    };
    UpdateObservationRequestPayload: {
      timestamp: string;
      healthState?: 'Good' | 'Moderate' | 'Poor' | 'Dead';
      flowers?: boolean;
      seeds?: boolean;
      pests?: string;
      /** Height in meters */
      height?: number;
      /** Diameter at breast height in meters */
      diameterAtBreastHeight?: number;
    };
    UpdateObservationResponsePayload: {
      resp: components['schemas']['ObservationResponse'];
      status: components['schemas']['SuccessOrError'];
    };
    UpdatePlantRequestPayload: {
      label?: string;
      speciesId?: number;
      naturalRegen?: boolean;
      datePlanted?: string;
    };
    UpdatePlantResponsePayload: {
      plant: components['schemas']['PlantResponse'];
      status: components['schemas']['SuccessOrError'];
    };
    UpdateProjectRequestPayload: {
      name: string;
    };
    UploadPhotoMetadataPayload: {
      capturedTime: string;
      /** Use location field instead. */
      latitude?: number;
      /** Use location field instead. */
      longitude?: number;
      location?: components['schemas']['Point'];
      /** GPS accuracy in meters. */
      gpsAccuracy?: number;
    };
    WithdrawalPayload: {
      /** Server-assigned unique ID of this withdrawal, its ID. Omit when creating a new withdrawal. */
      id?: number;
      date: string;
      purpose:
        | 'Propagation'
        | 'Outreach or Education'
        | 'Research'
        | 'Broadcast'
        | 'Share with Another Site'
        | 'Other'
        | 'Germination Testing';
      destination?: string;
      notes?: string;
      /** Quantity of seeds remaining. For weight-based accessions, this is user input and is required. For count-based accessions, it is calculated by the server and ignored on input. */
      remainingQuantity?: components['schemas']['SeedQuantityPayload'];
      staffResponsible?: string;
      /** If this withdrawal is of type "Germination Testing", the ID of the test it is associated with. This is always set by the server and cannot be modified. */
      germinationTestId?: number;
      /** For weight-based accessions, the difference between the weight remaining before this withdrawal and the weight remaining after it. This is a server-calculated value and is ignored on input. */
      weightDifference?: components['schemas']['SeedQuantityPayload'];
      /** Quantity of seeds withdrawn. For germination testing withdrawals, this is always the same as the test's "seedsSown" value, if that value is present. Otherwise, it is a user-supplied value. For count-based accessions, the units must always be "Seeds". For weight-based accessions, the units may either be a weight measurement or "Seeds". */
      withdrawnQuantity?: components['schemas']['SeedQuantityPayload'];
      /** The best estimate of the number of seeds withdrawn. This is the same as "withdrawnQuantity" if that is present, or else the same as "weightDifference" if this is a weight-based accession. If this is a count-based accession and "withdrawnQuantity" does not have a value, this field will not be present. This is a server-calculated value and is ignored on input. */
      estimatedQuantity?: components['schemas']['SeedQuantityPayload'];
    };
  };
}

export interface operations {
  createDevice: {
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['SimpleSuccessResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateDeviceRequestPayload'];
      };
    };
  };
  getDevice: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** Device configuration retrieved. */
      200: {
        content: {
          'application/json': components['schemas']['GetDeviceResponsePayload'];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  updateDevice: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** Device configuration updated. */
      200: {
        content: {
          'application/json': components['schemas']['SimpleSuccessResponsePayload'];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateDeviceRequestPayload'];
      };
    };
  };
  /** List all the facilities the current user can access. */
  listAllFacilities: {
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['ListFacilitiesResponse'];
        };
      };
    };
  };
  getFacility: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['GetFacilityResponse'];
        };
      };
    };
  };
  listFacilityDevices: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** Successfully listed the facility's devices. */
      200: {
        content: {
          'application/json': components['schemas']['ListDeviceConfigsResponse'];
        };
      };
      /** The facility does not exist or is not accessible by the current user. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  create_4: {
    responses: {
      /** The feature was created successfully. Response includes fields populated by the server, including the feature id. */
      200: {
        content: {
          'application/json': components['schemas']['CreateFeatureResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateFeatureRequestPayload'];
      };
    };
  };
  list_1: {
    parameters: {
      query: {
        skip?: number;
        limit?: number;
      };
      path: {
        layerId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['ListFeaturesResponsePayload'];
        };
      };
    };
  };
  read_2: {
    parameters: {
      path: {
        featureId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['GetFeatureResponsePayload'];
        };
      };
      /** The specified feature doesn't exist. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  update_4: {
    parameters: {
      path: {
        featureId: number;
      };
    };
    responses: {
      /** The feature was updated successfully. */
      200: {
        content: {
          'application/json': components['schemas']['UpdateFeatureResponsePayload'];
        };
      };
      /** The specified feature doesn't exist. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateFeatureRequestPayload'];
      };
    };
  };
  delete_1: {
    parameters: {
      path: {
        featureId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['DeleteFeatureResponsePayload'];
        };
      };
      /** The specified feature doesn't exist. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  listFeaturePhotos: {
    parameters: {
      path: {
        featureId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['ListFeaturePhotosResponsePayload'];
        };
      };
    };
  };
  createFeaturePhoto: {
    parameters: {
      path: {
        featureId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['CreateFeaturePhotoResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'multipart/form-data': {
          metadata: components['schemas']['CreateFeaturePhotoRequestPayload'];
          file: string;
        };
      };
    };
  };
  /** Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio. */
  downloadFeaturePhoto: {
    parameters: {
      path: {
        featureId: number;
        photoId: number;
      };
      query: {
        maxWidth?: number;
        maxHeight?: number;
      };
    };
    responses: {
      /** The photo was successfully retrieved. */
      200: {
        content: {
          'image/jpeg': string;
        };
      };
      /** The accession does not exist, or does not have a photo with the requested filename. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  deleteFeaturePhoto: {
    parameters: {
      path: {
        featureId: number;
        photoId: number;
      };
    };
    responses: {
      /** Photo deleted. */
      200: {
        content: {
          'application/json': components['schemas']['SimpleSuccessResponsePayload'];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  getFeaturePhotoMetadata: {
    parameters: {
      path: {
        featureId: number;
        photoId: number;
      };
    };
    responses: {
      /** Photo metadata retrieved. */
      200: {
        content: {
          'application/json': components['schemas']['GetFeaturePhotoMetadataResponsePayload'];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  create_3: {
    responses: {
      /** The layer was created successfully. Response includes fields populated by the server, including the layer id. */
      200: {
        content: {
          'application/json': components['schemas']['CreateLayerResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateLayerRequestPayload'];
      };
    };
  };
  list: {
    parameters: {
      path: {
        siteId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['ListLayersResponsePayload'];
        };
      };
    };
  };
  read_1: {
    parameters: {
      path: {
        layerId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['GetLayerResponsePayload'];
        };
      };
      /** The specified layer doesn't exist. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  update_3: {
    parameters: {
      path: {
        layerId: number;
      };
    };
    responses: {
      /** The layer was updated successfully. */
      200: {
        content: {
          'application/json': components['schemas']['UpdateLayerResponsePayload'];
        };
      };
      /** The specified layer doesn't exist. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateLayerRequestPayload'];
      };
    };
  };
  delete: {
    parameters: {
      path: {
        layerId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['DeleteLayerResponsePayload'];
        };
      };
      /** The specified layer doesn't exist. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  create_2: {
    responses: {
      /** The plant observation was created successfully. */
      200: {
        content: {
          'application/json': components['schemas']['CreateObservationResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateObservationRequestPayload'];
      };
    };
  };
  getList: {
    parameters: {
      path: {
        featureId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['ListObservationsResponsePayload'];
        };
      };
    };
  };
  get_1: {
    parameters: {
      path: {
        plantObservationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['GetObservationResponsePayload'];
        };
      };
      /** The specified plant observation doesn't exist. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  update_2: {
    parameters: {
      path: {
        plantObservationId: number;
      };
    };
    responses: {
      /** The plant observation was updated successfully. */
      200: {
        content: {
          'application/json': components['schemas']['UpdateObservationResponsePayload'];
        };
      };
      /** The specified plant observation doesn't exist. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateObservationRequestPayload'];
      };
    };
  };
  create_1: {
    responses: {
      /** The plant was created successfully. */
      200: {
        content: {
          'application/json': components['schemas']['CreatePlantResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreatePlantRequestPayload'];
      };
    };
  };
  getPlantSummary: {
    parameters: {
      query: {
        minEnteredTime?: string;
        maxEnteredTime?: string;
      };
      path: {
        layerId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['PlantSummaryResponsePayload'];
        };
      };
    };
  };
  getPlantsList: {
    parameters: {
      query: {
        speciesName?: string;
        minEnteredTime?: string;
        maxEnteredTime?: string;
        notes?: string;
      };
      path: {
        layerId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['ListPlantsResponsePayload'];
        };
      };
    };
  };
  get: {
    parameters: {
      path: {
        featureId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['GetPlantResponsePayload'];
        };
      };
      /** The specified plant doesn't exist. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  update_1: {
    parameters: {
      path: {
        featureId: number;
      };
    };
    responses: {
      /** The plant was updated successfully. */
      200: {
        content: {
          'application/json': components['schemas']['UpdatePlantResponsePayload'];
        };
      };
      /** The specified plant doesn't exist. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdatePlantRequestPayload'];
      };
    };
  };
  /** For interactive web applications, this can be used to redirect the user to a login page to allow the application to make other API requests. The login process will set a cookie that will authenticate to the API, and will then redirect back to the application. One approach is to use this in error response handlers: if an API request returns HTTP 401 Unauthorized, set location.href to this endpoint and set "redirect" to the URL of the page the user was on so they'll return there after logging in. */
  login: {
    parameters: {
      query: {
        redirect: string;
      };
    };
    responses: {
      /** Redirects to a login page. After login, the user will be redirected back to the URL specified in the "redirect" parameter. */
      302: never;
    };
  };
  /** List all organizations the user can access. */
  listAll_1: {
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['ListOrganizationsResponse'];
        };
      };
    };
  };
  /** Only projects that are accessible by the current user are included. */
  listOrganizationProjects: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** Projects retrieved. */
      200: {
        content: {
          'application/json': components['schemas']['ListProjectsResponsePayload'];
        };
      };
      /** The user is not a member of the organization, or the organization does not exist. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  listAllProjects: {
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['ListProjectsResponsePayload'];
        };
      };
    };
  };
  createProject: {
    responses: {
      /** Project created. */
      200: {
        content: {
          'application/json': components['schemas']['GetProjectResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateProjectRequestPayload'];
      };
    };
  };
  getProject: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** Project retrieved. */
      200: {
        content: {
          'application/json': components['schemas']['GetProjectResponsePayload'];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  updateProject: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['SimpleSuccessResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateProjectRequestPayload'];
      };
    };
  };
  listProjectSites: {
    parameters: {
      path: {
        projectId: number;
      };
      query: {
        srid?: number;
      };
    };
    responses: {
      /** Retrieved list of sites. */
      200: {
        content: {
          'application/json': components['schemas']['ListSitesResponsePayload'];
        };
      };
      /** The project does not exist or is not accessible. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  create: {
    responses: {
      /** The accession was created successfully. Response includes fields populated by the server, including the accession number and ID. */
      200: {
        content: {
          'application/json': components['schemas']['CreateAccessionResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateAccessionRequestPayload'];
      };
    };
  };
  read: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['GetAccessionResponsePayload'];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  update: {
    parameters: {
      path: {
        id: number;
      };
      query: {
        simulate?: boolean;
      };
    };
    responses: {
      /** The accession was updated successfully. Response includes fields populated or modified by the server as a result of the update. */
      200: {
        content: {
          'application/json': components['schemas']['UpdateAccessionResponsePayload'];
        };
      };
      /** The specified accession doesn't exist. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateAccessionRequestPayload'];
      };
    };
  };
  listPhotos: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** The accession's photos are listed in the response. */
      200: {
        content: {
          'application/json': components['schemas']['ListPhotosResponsePayload'];
        };
      };
      /** The accession does not exist. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  /** Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio. */
  getPhoto: {
    parameters: {
      path: {
        id: number;
        photoFilename: string;
      };
      query: {
        maxWidth?: number;
        maxHeight?: number;
      };
    };
    responses: {
      /** The photo was successfully retrieved. */
      200: {
        content: {
          'image/jpeg': string;
        };
      };
      /** The accession does not exist, or does not have a photo with the requested filename. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  uploadPhoto: {
    parameters: {
      path: {
        id: number;
        photoFilename: string;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['SimpleSuccessResponsePayload'];
        };
      };
      /** The specified accession does not exist. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
      /** The requested photo already exists on the accession. */
      409: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'multipart/form-data': {
          file: string;
          metadata: components['schemas']['UploadPhotoMetadataPayload'];
        };
      };
    };
  };
  /** In test environments, the clock can be advanced artificially, which will cause it to differ from the real-world date and time. */
  getCurrentTime: {
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['GetCurrentTimeResponsePayload'];
        };
      };
    };
  };
  /** Advancing the clock causes any scheduled processes to run. Subsequent GET requests to read the current time will take the advancement into account. Only supported in test and development environments. */
  advanceClock: {
    responses: {
      /** The clock has been advanced. The response includes the newly-adjusted time. */
      200: {
        content: {
          'application/json': components['schemas']['GetCurrentTimeResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AdvanceClockRequestPayload'];
      };
    };
  };
  recordLogMessage: {
    parameters: {
      path: {
        tag: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
    };
    requestBody: {
      content: {
        'application/json': { [key: string]: { [key: string]: unknown } };
      };
    };
  };
  listAll: {
    parameters: {
      query: {
        facilityId: number;
        /** Don't return notifications older than this; default is 1 month ago */
        since?: string;
        /** Return at most this many notifications; default is no limit */
        limit?: number;
      };
    };
    responses: {
      /** Notifications in reverse time order (newest first). */
      200: {
        content: {
          'application/json': components['schemas']['NotificationListResponse'];
        };
      };
    };
  };
  markAllRead: {
    responses: {
      /** All notifications have been marked as read. */
      200: {
        content: {
          'application/json': components['schemas']['SimpleSuccessResponsePayload'];
        };
      };
    };
  };
  /** For development and testing of notifications. Not available in production. */
  markAllUnread: {
    responses: {
      /** All notifications have been marked as unread. */
      200: {
        content: {
          'application/json': components['schemas']['SimpleSuccessResponsePayload'];
        };
      };
    };
  };
  markRead: {
    parameters: {
      path: {
        /** ID of notification to mark as read */
        id: string;
      };
    };
    responses: {
      /** Notification has been marked as read. */
      200: {
        content: {
          'application/json': components['schemas']['SimpleSuccessResponsePayload'];
        };
      };
      /** The requested notification ID was not valid. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  search: {
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['SearchResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SearchRequestPayload'];
      };
    };
  };
  export: {
    responses: {
      /** Export succeeded. */
      200: {
        content: {
          'text/csv': string;
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExportRequestPayload'];
      };
    };
  };
  getSummary: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['SummaryResponse'];
        };
      };
    };
  };
  /** If there are existing timeseries with the same names, the old definitions will be overwritten. */
  createMultipleTimeseries: {
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['SimpleSuccessResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateTimeseriesRequestPayload'];
      };
    };
  };
  recordTimeseriesValues: {
    responses: {
      /** Successfully processed the request. Note that this status will be returned even if the server was unable to record some of the values. In that case, the failed values will be returned in the response payload. */
      200: {
        content: {
          'application/json': components['schemas']['RecordTimeseriesValuesResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RecordTimeseriesValuesRequestPayload'];
      };
    };
  };
  listFieldValues: {
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['ListFieldValuesResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListFieldValuesRequestPayload'];
      };
    };
  };
  listAllFieldValues: {
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['ListAllFieldValuesResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListAllFieldValuesRequestPayload'];
      };
    };
  };
  /** Use /api/v1/species instead. */
  listSpecies: {
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['ListSpeciesResponsePayload'];
        };
      };
    };
  };
  /** Use /api/v1/species instead. */
  createSpecies: {
    responses: {
      /** Species created. */
      200: {
        content: {
          'application/json': components['schemas']['CreateSpeciesResponsePayload'];
        };
      };
      /** A species with the requested name already exists. */
      409: {
        content: {
          'application/json': components['schemas']['CreateSpeciesResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateSpeciesRequestPayload'];
      };
    };
  };
  /** Use /api/v1/species instead. */
  updateSpecies: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          'application/json': components['schemas']['SimpleSuccessResponsePayload'];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateSpeciesRequestPayload'];
      };
    };
  };
  getStorageLocations: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['StorageLocationsResponsePayload'];
        };
      };
    };
  };
  listAllSites: {
    parameters: {
      query: {
        srid?: number;
      };
    };
    responses: {
      /** Retrieved list of sites. */
      200: {
        content: {
          'application/json': components['schemas']['ListSitesResponsePayload'];
        };
      };
    };
  };
  getSite: {
    parameters: {
      path: {
        siteId: number;
      };
      query: {
        srid?: number;
      };
    };
    responses: {
      /** Site retrieved. */
      200: {
        content: {
          'application/json': components['schemas']['GetSiteResponsePayload'];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  speciesList: {
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['SpeciesListResponsePayload'];
        };
      };
    };
  };
  speciesCreate: {
    responses: {
      /** Species created. */
      200: {
        content: {
          'application/json': components['schemas']['SpeciesCreateResponsePayload'];
        };
      };
      /** A species with the requested name already exists. */
      409: {
        content: {
          'application/json': components['schemas']['SpeciesCreateResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SpeciesRequestPayload'];
      };
    };
  };
  speciesNamesListAll: {
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['SpeciesNamesListResponsePayload'];
        };
      };
    };
  };
  speciesNameCreate: {
    responses: {
      /** Species name added. */
      200: {
        content: {
          'application/json': components['schemas']['SpeciesNameCreateResponsePayload'];
        };
      };
      /** The species does not exist. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
      /** The species already has the requested name. */
      409: {
        content: {
          'application/json': components['schemas']['SpeciesNameCreateResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SpeciesNameRequestPayload'];
      };
    };
  };
  /** Gets information about a single species name. */
  speciesNameGet: {
    parameters: {
      path: {
        speciesNameId: number;
      };
    };
    responses: {
      /** Species name retrieved. */
      200: {
        content: {
          'application/json': components['schemas']['SpeciesNameGetResponsePayload'];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  /** Updates one of the names of a species. */
  speciesNameUpdate: {
    parameters: {
      path: {
        speciesNameId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          'application/json': components['schemas']['SimpleSuccessResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SpeciesNameRequestPayload'];
      };
    };
  };
  /** Deletes one of the secondary names of a species. */
  speciesNameDelete: {
    parameters: {
      path: {
        speciesNameId: number;
      };
    };
    responses: {
      /** Species name deleted. */
      200: {
        content: {
          'application/json': components['schemas']['SimpleSuccessResponsePayload'];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
      /** Cannot delete the primary name of a species. */
      409: {
        content: {
          'application/json': components['schemas']['SimpleSuccessResponsePayload'];
        };
      };
    };
  };
  speciesRead: {
    parameters: {
      path: {
        speciesId: number;
      };
    };
    responses: {
      /** Species retrieved. */
      200: {
        content: {
          'application/json': components['schemas']['SpeciesGetResponsePayload'];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
  speciesUpdate: {
    parameters: {
      path: {
        speciesId: number;
      };
    };
    responses: {
      /** Species updated or merged with an existing species. */
      200: {
        content: {
          'application/json': components['schemas']['SimpleSuccessResponsePayload'];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SpeciesRequestPayload'];
      };
    };
  };
  speciesDelete: {
    parameters: {
      path: {
        speciesId: number;
      };
    };
    responses: {
      /** Species deleted. */
      200: {
        content: {
          'application/json': components['schemas']['SimpleSuccessResponsePayload'];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
      /** Cannot delete the species because it is currently in use. */
      409: {
        content: {
          'application/json': components['schemas']['SimpleSuccessResponsePayload'];
        };
      };
    };
  };
  speciesNamesList: {
    parameters: {
      path: {
        speciesId: number;
      };
    };
    responses: {
      /** Species names retrieved. */
      200: {
        content: {
          'application/json': components['schemas']['SpeciesNamesListResponsePayload'];
        };
      };
      /** The species does not exist. */
      404: {
        content: {
          'application/json': components['schemas']['SimpleErrorResponsePayload'];
        };
      };
    };
  };
}

export interface external {}
