/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/api/v1/automations": {
    get: operations["listAutomations_2"];
    post: operations["createAutomation_2"];
  };
  "/api/v1/automations/{automationId}": {
    get: operations["getAutomation_2"];
    put: operations["updateAutomation_2"];
    delete: operations["deleteAutomation_2"];
  };
  "/api/v1/automations/{automationId}/trigger": {
    post: operations["postAutomationTrigger"];
  };
  "/api/v1/devices": {
    post: operations["createDevice"];
  };
  "/api/v1/devices/managers": {
    get: operations["getDeviceManagers"];
  };
  "/api/v1/devices/managers/{deviceManagerId}": {
    get: operations["getDeviceManager"];
  };
  "/api/v1/devices/managers/{deviceManagerId}/connect": {
    post: operations["connectDeviceManager"];
  };
  "/api/v1/devices/templates": {
    get: operations["listDeviceTemplates"];
  };
  "/api/v1/devices/{id}": {
    get: operations["getDevice"];
    put: operations["updateDevice"];
  };
  "/api/v1/devices/{id}/unresponsive": {
    /** Notifies the appropriate users so they can troubleshoot the problem. */
    post: operations["deviceUnresponsive"];
  };
  "/api/v1/facilities": {
    get: operations["listAllFacilities_1"];
    post: operations["createFacility_1"];
  };
  "/api/v1/facilities/{facilityId}": {
    get: operations["getFacility"];
    put: operations["updateFacility"];
  };
  "/api/v1/facilities/{facilityId}/alert/send": {
    post: operations["sendFacilityAlert"];
  };
  "/api/v1/facilities/{facilityId}/automations": {
    get: operations["listAutomations_1"];
    post: operations["createAutomation_1"];
  };
  "/api/v1/facilities/{facilityId}/automations/{automationId}": {
    get: operations["getAutomation_1"];
    put: operations["updateAutomation_1"];
    delete: operations["deleteAutomation_1"];
  };
  "/api/v1/facilities/{facilityId}/configured": {
    /** After connecting a device manager and finishing any necessary configuration of the facility's devices, send this request to enable processing of timeseries values and alerts from the device manager. Only valid if the facility's connection state is `Connected`. */
    post: operations["postConfigured_1"];
  };
  "/api/v1/facilities/{facilityId}/devices": {
    get: operations["listFacilityDevices"];
  };
  "/api/v1/facility": {
    get: operations["listAllFacilities"];
    post: operations["createFacility"];
  };
  "/api/v1/facility/{facilityId}": {
    get: operations["getFacility_1"];
    put: operations["updateFacility_1"];
  };
  "/api/v1/facility/{facilityId}/alert/send": {
    post: operations["sendFacilityAlert_1"];
  };
  "/api/v1/facility/{facilityId}/automations": {
    get: operations["listAutomations"];
    post: operations["createAutomation"];
  };
  "/api/v1/facility/{facilityId}/automations/{automationId}": {
    get: operations["getAutomation"];
    put: operations["updateAutomation"];
    delete: operations["deleteAutomation"];
  };
  "/api/v1/facility/{facilityId}/configured": {
    /** After connecting a device manager and finishing any necessary configuration of the facility's devices, send this request to enable processing of timeseries values and alerts from the device manager. Only valid if the facility's connection state is `Connected`. */
    post: operations["postConfigured"];
  };
  "/api/v1/facility/{facilityId}/devices": {
    get: operations["listFacilityDevices_1"];
  };
  "/api/v1/login": {
    /** For interactive web applications, this can be used to redirect the user to a login page to allow the application to make other API requests. The login process will set a cookie that will authenticate to the API, and will then redirect back to the application. One approach is to use this in error response handlers: if an API request returns HTTP 401 Unauthorized, set location.href to this endpoint and set "redirect" to the URL of the page the user was on so they'll return there after logging in. */
    get: operations["login"];
  };
  "/api/v1/notifications": {
    get: operations["readAll"];
    put: operations["markAllRead"];
  };
  "/api/v1/notifications/count": {
    get: operations["count"];
  };
  "/api/v1/notifications/{id}": {
    get: operations["read_2"];
    put: operations["markRead"];
  };
  "/api/v1/organizations": {
    /** Lists all organizations the user can access. */
    get: operations["listOrganizations"];
    post: operations["createOrganization"];
  };
  "/api/v1/organizations/{organizationId}": {
    get: operations["getOrganization"];
    put: operations["updateOrganization"];
    /** Organizations can only be deleted if they have no members other than the current user. */
    delete: operations["deleteOrganization"];
  };
  "/api/v1/organizations/{organizationId}/roles": {
    get: operations["listOrganizationRoles"];
  };
  "/api/v1/organizations/{organizationId}/users": {
    get: operations["listOrganizationUsers"];
    post: operations["addOrganizationUser"];
  };
  "/api/v1/organizations/{organizationId}/users/{userId}": {
    get: operations["getOrganizationUser"];
    /** Only includes organization-level information that can be modified by organization administrators. */
    put: operations["updateOrganizationUser"];
    /** Does not remove any data created by the user. */
    delete: operations["deleteOrganizationUser"];
  };
  "/api/v1/search": {
    post: operations["search_1"];
  };
  "/api/v1/seedbank/accession": {
    post: operations["create_1"];
  };
  "/api/v1/seedbank/accession/{id}": {
    get: operations["read_1"];
    put: operations["update_1"];
  };
  "/api/v1/seedbank/accession/{id}/checkIn": {
    post: operations["checkIn_1"];
  };
  "/api/v1/seedbank/accession/{id}/photo": {
    get: operations["listPhotos"];
  };
  "/api/v1/seedbank/accession/{id}/photo/{photoFilename}": {
    /** Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio. */
    get: operations["getPhoto_1"];
    post: operations["uploadPhoto_1"];
  };
  "/api/v1/seedbank/accessions": {
    post: operations["create"];
  };
  "/api/v1/seedbank/accessions/{id}": {
    get: operations["read"];
    put: operations["update"];
  };
  "/api/v1/seedbank/accessions/{id}/checkIn": {
    post: operations["checkIn"];
  };
  "/api/v1/seedbank/accessions/{id}/photos": {
    get: operations["listPhotos_1"];
  };
  "/api/v1/seedbank/accessions/{id}/photos/{photoFilename}": {
    /** Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio. */
    get: operations["getPhoto"];
    post: operations["uploadPhoto"];
  };
  "/api/v1/seedbank/clock": {
    /** In test environments, the clock can be advanced artificially, which will cause it to differ from the real-world date and time. */
    get: operations["getCurrentTime"];
  };
  "/api/v1/seedbank/log/{tag}": {
    post: operations["recordLogMessage"];
  };
  "/api/v1/seedbank/search": {
    post: operations["searchAccessions"];
  };
  "/api/v1/seedbank/search/export": {
    post: operations["exportAccessions"];
  };
  "/api/v1/seedbank/summary": {
    get: operations["getSeedBankSummary"];
  };
  "/api/v1/seedbank/summary/{facilityId}": {
    get: operations["getSummary"];
  };
  "/api/v1/seedbank/values": {
    post: operations["listFieldValues"];
  };
  "/api/v1/seedbank/values/all": {
    post: operations["listAllFieldValues"];
  };
  "/api/v1/seedbank/values/storageLocation/{facilityId}": {
    get: operations["getStorageLocations"];
  };
  "/api/v1/species": {
    get: operations["listSpecies"];
    post: operations["createSpecies"];
  };
  "/api/v1/species/lookup/details": {
    get: operations["getSpeciesDetails"];
  };
  "/api/v1/species/lookup/names": {
    /** Gets a list of known scientific names whose words begin with particular letters. */
    get: operations["listSpeciesNames"];
  };
  "/api/v1/species/problems/{problemId}": {
    /** Returns details about a problem with a species. */
    get: operations["getSpeciesProblem"];
    /** Only valid for problems that include suggested changes. */
    post: operations["acceptProblemSuggestion"];
    delete: operations["deleteProblem"];
  };
  "/api/v1/species/uploads": {
    /** The uploaded file must be in CSV format. A template with the correct headers may be downloaded from the `/api/v1/species/uploads/template` endpoint. */
    post: operations["uploadSpeciesList"];
  };
  "/api/v1/species/uploads/template": {
    get: operations["getSpeciesListUploadTemplate"];
  };
  "/api/v1/species/uploads/{uploadId}": {
    /** Clients may poll this endpoint to monitor the progress of the file. */
    get: operations["getSpeciesListUploadStatus"];
    /** This may only be called if the status of the upload is "Awaiting User Action". */
    delete: operations["deleteSpeciesListUpload"];
  };
  "/api/v1/species/uploads/{uploadId}/resolve": {
    /** This may only be called if the status of the upload is "Awaiting User Action". */
    post: operations["resolveSpeciesListUpload"];
  };
  "/api/v1/species/{speciesId}": {
    get: operations["getSpecies"];
    put: operations["updateSpecies"];
    /** The species will no longer appear in the organization's list of species, but existing data (plants, seeds, etc.) that refer to the species will still refer to it. */
    delete: operations["deleteSpecies"];
  };
  "/api/v1/timeseries": {
    get: operations["listTimeseries"];
  };
  "/api/v1/timeseries/create": {
    /** If there are existing timeseries with the same names, the old definitions will be overwritten. */
    post: operations["createMultipleTimeseries"];
  };
  "/api/v1/timeseries/history": {
    post: operations["getTimeseriesHistory"];
  };
  "/api/v1/timeseries/values": {
    post: operations["recordTimeseriesValues"];
  };
  "/api/v1/users/me": {
    get: operations["getMyself"];
    put: operations["updateMyself"];
  };
}

export interface components {
  schemas: {
    AccessionPayload: {
      /** Server-generated human-readable identifier for the accession. This is unique within a single seed bank, but different seed banks may have accessions with the same number. */
      accessionNumber: string;
      /** Server-calculated active indicator. This is based on the accession's state. */
      active: "Inactive" | "Active";
      bagNumbers?: string[];
      checkedInTime?: string;
      collectedDate?: string;
      deviceInfo?: components["schemas"]["DeviceInfoPayload"];
      cutTestSeedsCompromised?: number;
      cutTestSeedsEmpty?: number;
      cutTestSeedsFilled?: number;
      dryingEndDate?: string;
      dryingMoveDate?: string;
      dryingStartDate?: string;
      endangered?: "No" | "Yes" | "Unsure";
      environmentalNotes?: string;
      estimatedSeedCount?: number;
      facilityId: number;
      family?: string;
      fieldNotes?: string;
      founderId?: string;
      geolocations?: components["schemas"]["Geolocation"][];
      /** Server-generated unique identifier for the accession. This is unique across all seed banks, but is not suitable for display to end users. */
      id: number;
      /** Initial size of accession. The units of this value must match the measurement type in "processingMethod". */
      initialQuantity?: components["schemas"]["SeedQuantityPayload"];
      landowner?: string;
      latestViabilityPercent?: number;
      latestViabilityTestDate?: string;
      numberOfTrees?: number;
      nurseryStartDate?: string;
      photoFilenames?: string[];
      primaryCollector?: string;
      processingMethod?: "Count" | "Weight";
      processingNotes?: string;
      processingStaffResponsible?: string;
      processingStartDate?: string;
      rare?: "No" | "Yes" | "Unsure";
      receivedDate?: string;
      /** Number or weight of seeds remaining for withdrawal and testing. Calculated by the server when the accession's total size is known. */
      remainingQuantity?: components["schemas"]["SeedQuantityPayload"];
      secondaryCollectors?: string[];
      siteLocation?: string;
      /** Which application this accession originally came from. This is currently based on the presence of the deviceInfo field. */
      source?: "Web" | "SeedCollectorApp";
      sourcePlantOrigin?: "Wild" | "Outplant";
      species?: string;
      /** Server-generated unique ID of the species. */
      speciesId?: number;
      /** Server-calculated accession state. Can change due to modifications to accession data or based on passage of time. */
      state:
        | "Awaiting Check-In"
        | "Pending"
        | "Processing"
        | "Processed"
        | "Drying"
        | "Dried"
        | "In Storage"
        | "Withdrawn"
        | "Nursery";
      storageCondition?: "Refrigerator" | "Freezer";
      storageLocation?: string;
      storagePackets?: number;
      storageNotes?: string;
      storageStaffResponsible?: string;
      storageStartDate?: string;
      subsetCount?: number;
      /** Weight of subset of seeds. Units must be a weight measurement, not "Seeds". */
      subsetWeight?: components["schemas"]["SeedQuantityPayload"];
      targetStorageCondition?: "Refrigerator" | "Freezer";
      /** Total quantity of all past withdrawals, including viability tests. */
      totalPastWithdrawalQuantity?: components["schemas"]["SeedQuantityPayload"];
      /** Total quantity of scheduled withdrawals, not counting viability tests. */
      totalScheduledNonTestQuantity?: components["schemas"]["SeedQuantityPayload"];
      /** Total quantity of scheduled withdrawals for viability tests. */
      totalScheduledTestQuantity?: components["schemas"]["SeedQuantityPayload"];
      /** Total quantity of scheduled withdrawals, including viability tests. */
      totalScheduledWithdrawalQuantity?: components["schemas"]["SeedQuantityPayload"];
      totalViabilityPercent?: number;
      /** Total quantity of all past and scheduled withdrawals, including viability tests. */
      totalWithdrawalQuantity?: components["schemas"]["SeedQuantityPayload"];
      viabilityTests?: components["schemas"]["ViabilityTestPayload"][];
      viabilityTestTypes?: ("Lab" | "Nursery")[];
      withdrawals?: components["schemas"]["WithdrawalPayload"][];
    };
    AddOrganizationUserRequestPayload: {
      email: string;
      role: "Contributor" | "Manager" | "Admin" | "Owner";
    };
    AllFieldValuesPayload: {
      /** All the values this field could possibly have, whether or not any accessions have them. For fields that allow the user to enter arbitrary values, this is equivalent to querying the list of values without any filter criteria, that is, it's a list of all the user-entered values. */
      values: string[];
      /** If true, the list of values is too long to return in its entirety and "values" is a partial list. */
      partial: boolean;
    };
    /** Search criterion that matches results that meet all of a set of other search criteria. That is, if the list of children is x, y, and z, this will require x AND y AND z. */
    AndNodePayload: components["schemas"]["SearchNodePayload"] & {
      children?: components["schemas"]["SearchNodePayload"][];
    } & {
      children: unknown;
    };
    AutomationPayload: {
      id: number;
      facilityId: number;
      /** Short human-readable name of this automation. */
      name: string;
      /** Human-readable description of this automation. */
      description?: string;
      /** Client-defined configuration data for this automation. */
      configuration?: { [key: string]: unknown };
    };
    AutomationTriggerRequestPayload: {
      /** For automations that are triggered by changes to timeseries values, the value that triggered the automation. */
      timeseriesValue?: number;
      /** Default message to publish if the automation type isn't yet supported by the server. */
      message?: string;
    };
    /** Coordinate reference system used for X and Y coordinates in this geometry. By default, coordinates are in WGS 84, with longitude and latitude in degrees. In that case, this element is not present. Otherwise, it specifies which coordinate system to use. */
    CRS: {
      type: "name";
      properties: components["schemas"]["CRSProperties"];
    };
    CRSProperties: {
      /** Name of the coordinate reference system. This must be in the form EPSG:nnnn where nnnn is the numeric identifier of a coordinate system in the EPSG dataset. The default is Longitude/Latitude EPSG:4326, which is the coordinate system +for GeoJSON. */
      name: string;
    };
    ConnectDeviceManagerRequestPayload: {
      facilityId: number;
    };
    CreateAccessionRequestPayload: {
      bagNumbers?: string[];
      collectedDate?: string;
      deviceInfo?: components["schemas"]["DeviceInfoPayload"];
      endangered?: "No" | "Yes" | "Unsure";
      environmentalNotes?: string;
      facilityId?: number;
      family?: string;
      fieldNotes?: string;
      founderId?: string;
      geolocations?: components["schemas"]["Geolocation"][];
      landowner?: string;
      numberOfTrees?: number;
      primaryCollector?: string;
      rare?: "No" | "Yes" | "Unsure";
      receivedDate?: string;
      secondaryCollectors?: string[];
      siteLocation?: string;
      sourcePlantOrigin?: "Wild" | "Outplant";
      species?: string;
      viabilityTestTypes?: ("Lab" | "Nursery")[];
    };
    CreateAccessionResponsePayload: {
      accession: components["schemas"]["AccessionPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    CreateAutomationRequestPayload: {
      facilityId: number;
      type: string;
      name: string;
      description?: string;
      deviceId?: number;
      timeseriesName?: string;
      verbosity?: number;
      lowerThreshold?: number;
      upperThreshold?: number;
      settings?: { [key: string]: { [key: string]: unknown } };
    };
    CreateAutomationResponsePayload: {
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateDeviceRequestPayload: {
      /** Identifier of facility where this device is located. */
      facilityId: number;
      /** Name of this device. */
      name: string;
      /** High-level type of the device. Device manager may use this in conjunction with the make and model to determine which metrics to report. */
      type: string;
      /** Name of device manufacturer. */
      make: string;
      /** Model number or model name of the device. */
      model: string;
      /** Device manager protocol name. */
      protocol?: string;
      /** Protocol-specific address of device, e.g., an IP address or a Bluetooth device ID. */
      address?: string;
      /** Port number if relevant for the protocol. */
      port?: number;
      /** Protocol- and device-specific custom settings. This is an arbitrary JSON object; the exact settings depend on the device type. */
      settings?: { [key: string]: unknown };
      /** Level of diagnostic information to log. */
      verbosity?: number;
      /** ID of parent device such as a hub or gateway, if any. The parent device must exist. */
      parentId?: number;
    };
    CreateFacilityRequestPayload: {
      description?: string;
      /** Which organization this facility belongs to. */
      organizationId: number;
      name: string;
      type: "Seed Bank" | "Desalination" | "Reverse Osmosis";
    };
    CreateFacilityResponsePayload: {
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateOrganizationRequestPayload: {
      /** ISO 3166 alpha-2 code of organization's country. */
      countryCode?: string;
      /** ISO 3166-2 code of organization's country subdivision (state, province, region, etc.) This is the full ISO 3166-2 code including the country prefix. If this is set, countryCode must also be set. */
      countrySubdivisionCode?: string;
      description?: string;
      name: string;
    };
    CreateOrganizationUserResponsePayload: {
      /** The ID of the newly-added user. */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateSpeciesResponsePayload: {
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    CreateTimeseriesEntry: {
      /** ID of device that produces this timeseries. */
      deviceId: number;
      /** Name of this timeseries. Duplicate timeseries names for the same device aren't allowed, but different devices can have timeseries with the same name. */
      timeseriesName: string;
      type: "Numeric" | "Text";
      /** Number of significant fractional digits (after the decimal point), if this is a timeseries with non-integer numeric values. */
      decimalPlaces?: number;
      /** Units of measure for values in this timeseries. */
      units?: string;
    };
    CreateTimeseriesRequestPayload: {
      timeseries: components["schemas"]["CreateTimeseriesEntry"][];
    };
    DeviceConfig: {
      /** Unique identifier of this device. */
      id: number;
      /** Identifier of facility where this device is located. */
      facilityId: number;
      /** Name of this device. */
      name: string;
      /** High-level type of the device. Device manager may use this in conjunction with the make and model to determine which metrics to report. */
      type: string;
      /** Name of device manufacturer. */
      make: string;
      /** Model number or model name of the device. */
      model: string;
      /** Device manager protocol name. */
      protocol?: string;
      /** Protocol-specific address of device, e.g., an IP address or a Bluetooth device ID. */
      address?: string;
      /** Port number if relevant for the protocol. */
      port?: number;
      /** Protocol- and device-specific custom settings. This is an arbitrary JSON object; the exact settings depend on the device type. */
      settings?: { [key: string]: unknown };
      /** Level of diagnostic information to log. */
      verbosity?: number;
      /** ID of parent device such as a hub or gateway, if any. */
      parentId?: number;
    };
    /** Details about the device and the application that created the accession. All these values are optional and most of them are platform-dependent. */
    DeviceInfoPayload: {
      /** Build number of application that is submitting the accession, e.g., from React Native getBuildId() */
      appBuild?: string;
      /** Name of application */
      appName?: string;
      /** Brand of device, e.g., from React Native getBrand(). */
      brand?: string;
      /** Model of device hardware, e.g., from React Native getDeviceId(). */
      model?: string;
      /** Name the user has assigned to the device, e.g., from React Native getDeviceName(). */
      name?: string;
      /** Type of operating system, e.g., from React Native getSystemName(). */
      osType?: string;
      /** Version of operating system, e.g., from React Native getSystemVersion(). */
      osVersion?: string;
      /** Unique identifier of the hardware device, e.g., from React Native getUniqueId(). */
      uniqueId?: string;
    };
    DeviceManagerPayload: {
      id: number;
      sensorKitId: string;
      /** If true, this device manager is available to connect to a facility. */
      available: boolean;
      /** The facility this device manager is connected to, or null if it is not connected. */
      facilityId?: number;
      /** If true, this device manager is currently online. */
      isOnline: boolean;
      /** When the device manager's isOnline value changed most recently. In other words, if isOnline is true, the device manager has been online since this time; if isOnline is false, the device manager has been offline since this time. This may be null if the device manager has not come online for the first time yet. */
      onlineChangedTime?: string;
      /** If an update is being downloaded or installed, its progress as a percentage. Not present if no update is in progress. */
      updateProgress?: number;
    };
    DeviceTemplatePayload: {
      id: number;
      category: "PV" | "Seed Bank Default";
      name: string;
      type: string;
      make: string;
      model: string;
      protocol?: string;
      address?: string;
      port?: number;
      settings?: { [key: string]: { [key: string]: unknown } };
      verbosity?: number;
    };
    DeviceUnresponsiveRequestPayload: {
      /** When the device most recently responded. Null or absent if the device has never responded. */
      lastRespondedTime?: string;
      /** The expected amount of time between updates from the device. Null or absent if there is no fixed update interval. */
      expectedIntervalSecs?: number;
    };
    ErrorDetails: {
      message: string;
    };
    ExportAccessionsRequestPayload: {
      facilityId: number;
      fields: string[];
      sortOrder?: components["schemas"]["SearchSortOrderElement"][];
      search?:
        | components["schemas"]["AndNodePayload"]
        | components["schemas"]["FieldNodePayload"]
        | components["schemas"]["NotNodePayload"]
        | components["schemas"]["OrNodePayload"];
    };
    /** This organization's facilities. Only included if depth is "Facility". */
    FacilityPayload: {
      connectionState: "Not Connected" | "Connected" | "Configured";
      createdTime: string;
      description?: string;
      id: number;
      name: string;
      organizationId: number;
      type: "Seed Bank" | "Desalination" | "Reverse Osmosis";
    };
    FieldNodePayload: components["schemas"]["SearchNodePayload"] & {
      field?: string;
      /** List of values to match. For exact and fuzzy searches, a list of at least one value to search for; the list may include null to match accessions where the field does not have a value. For range searches, the list must contain exactly two values, the minimum and maximum; one of the values may be null to search for all values above a minimum or below a maximum. */
      values?: (string | null)[];
      type?: "Exact" | "Fuzzy" | "Range";
    } & {
      field: unknown;
      type: unknown;
      values: unknown;
    };
    FieldValuesPayload: {
      /** List of values in the matching accessions. If there are accessions where the field has no value, this list will contain null (an actual null value, not the string "null"). */
      values: (string | null)[];
      /** If true, the list of values is too long to return in its entirety and "values" is a partial list. */
      partial: boolean;
    };
    Geolocation: {
      latitude: number;
      longitude: number;
      accuracy?: number;
    };
    /** GEOMETRY-FIX-TYPE-ON-CLIENT-SIDE */
    Geometry: {
      type:
        | "Point"
        | "LineString"
        | "Polygon"
        | "MultiPoint"
        | "MultiLineString"
        | "MultiPolygon"
        | "GeometryCollection";
      coordinates: number[];
      crs?: components["schemas"]["CRS"];
    };
    GeometryCollection: components["schemas"]["Geometry"] & {
      geometries?: components["schemas"]["Geometry"][];
    } & {
      geometries: unknown;
    };
    GetAccessionResponsePayload: {
      accession: components["schemas"]["AccessionPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetAutomationResponsePayload: {
      automation: components["schemas"]["AutomationPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetCurrentTimeResponsePayload: {
      currentTime: string;
      status: components["schemas"]["SuccessOrError"];
    };
    GetDeviceManagerResponsePayload: {
      manager: components["schemas"]["DeviceManagerPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetDeviceManagersResponsePayload: {
      /** List of device managers that match the conditions in the request. Empty if there were no matches, e.g., the requested short code didn't exist. */
      managers: components["schemas"]["DeviceManagerPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetDeviceResponsePayload: {
      device: components["schemas"]["DeviceConfig"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetFacilityResponse: {
      facility: components["schemas"]["FacilityPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetNotificationResponsePayload: {
      notification: components["schemas"]["NotificationPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetNotificationsCountResponsePayload: {
      notifications: components["schemas"]["NotificationCountPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetNotificationsResponsePayload: {
      notifications: components["schemas"]["NotificationPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    GetOrganizationResponsePayload: {
      organization: components["schemas"]["OrganizationPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetOrganizationUserResponsePayload: {
      user: components["schemas"]["OrganizationUserPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetSpeciesProblemResponsePayload: {
      problem: components["schemas"]["SpeciesProblemElement"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetSpeciesResponsePayload: {
      species: components["schemas"]["SpeciesResponseElement"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetSpeciesUploadStatusDetailsPayload: {
      id: number;
      status:
        | "Receiving"
        | "Validating"
        | "Processing"
        | "Completed"
        | "Processing Failed"
        | "Invalid"
        | "Receiving Failed"
        | "Awaiting Validation"
        | "Awaiting User Action"
        | "Awaiting Processing";
      errors?: components["schemas"]["SpeciesUploadProblemPayload"][];
      warnings?: components["schemas"]["SpeciesUploadProblemPayload"][];
      /** True if the server is finished processing the file, either successfully or not. */
      finished: boolean;
    };
    GetSpeciesUploadStatusResponsePayload: {
      details: components["schemas"]["GetSpeciesUploadStatusDetailsPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    GetTimeseriesHistoryRequestPayload: {
      /** Start of time range to query. If this is non-null, endTime must also be specified, and seconds must be null or absent. */
      startTime?: string;
      /** End of time range to query. If this is non-null, startTime must also be specified, and seconds must be null or absent. */
      endTime?: string;
      /** Number of seconds in the past to start the time range. If this is non-null, startTime and endTime must be null or absent. */
      seconds?: number;
      /** Number of values to return. The time range is divided into this many equal intervals, and a value is returned from each interval if available. */
      count: number;
      /** Timeseries to query. May be from different devices. */
      timeseries: components["schemas"]["TimeseriesIdPayload"][];
    };
    GetTimeseriesHistoryResponsePayload: {
      values: components["schemas"]["TimeseriesValuesPayload"][];
    };
    GetUserResponsePayload: {
      user: components["schemas"]["UserProfilePayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    LineString: components["schemas"]["Geometry"] & {
      coordinates?: number[][];
    } & {
      coordinates: unknown;
    };
    ListAllFieldValuesRequestPayload: {
      facilityId?: number;
      fields: string[];
      organizationId?: number;
    };
    ListAllFieldValuesResponsePayload: {
      results: {
        [key: string]: components["schemas"]["AllFieldValuesPayload"];
      };
      status: components["schemas"]["SuccessOrError"];
    };
    ListAutomationsResponsePayload: {
      automations: components["schemas"]["AutomationPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListDeviceConfigsResponse: {
      devices: components["schemas"]["DeviceConfig"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListDeviceTemplatesResponsePayload: {
      templates: components["schemas"]["DeviceTemplatePayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListFacilitiesResponse: {
      facilities: components["schemas"]["FacilityPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListFieldValuesRequestPayload: {
      facilityId?: number;
      fields: string[];
      organizationId?: number;
      search?:
        | components["schemas"]["AndNodePayload"]
        | components["schemas"]["FieldNodePayload"]
        | components["schemas"]["NotNodePayload"]
        | components["schemas"]["OrNodePayload"];
    };
    ListFieldValuesResponsePayload: {
      results: { [key: string]: components["schemas"]["FieldValuesPayload"] };
      status: components["schemas"]["SuccessOrError"];
    };
    ListOrganizationRolesResponsePayload: {
      roles: components["schemas"]["OrganizationRolePayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListOrganizationUsersResponsePayload: {
      users: components["schemas"]["OrganizationUserPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListOrganizationsResponsePayload: {
      organizations: components["schemas"]["OrganizationPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListPhotosResponseElement: {
      filename: string;
      size: number;
      capturedTime: string;
      /** @deprecated Use location field instead. */
      latitude?: number;
      /** @deprecated Use location field instead. */
      longitude?: number;
      location?: components["schemas"]["Point"];
      /** GPS accuracy in meters. */
      gpsAccuracy?: number;
    };
    ListPhotosResponsePayload: {
      photos: components["schemas"]["ListPhotosResponseElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListSpeciesResponsePayload: {
      species: components["schemas"]["SpeciesResponseElement"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ListTimeseriesResponsePayload: {
      timeseries: components["schemas"]["TimeseriesPayload"][];
      status: components["schemas"]["SuccessOrError"];
    };
    ModifyAutomationRequestPayload: {
      name: string;
      description?: string;
      configuration?: { [key: string]: unknown };
      settings?: { [key: string]: { [key: string]: unknown } };
      type: string;
      timeseriesName?: string;
      deviceId?: number;
      lowerThreshold?: number;
      upperThreshold?: number;
      verbosity: number;
    };
    MultiLineString: components["schemas"]["Geometry"] & {
      coordinates?: number[][][];
    } & {
      coordinates: unknown;
    };
    MultiPoint: components["schemas"]["Geometry"] & {
      coordinates?: number[][];
    } & {
      coordinates: unknown;
    };
    MultiPolygon: components["schemas"]["Geometry"] & {
      coordinates?: number[][][][];
    } & {
      coordinates: unknown;
    };
    /** Search criterion that matches results that do not match a set of search criteria. */
    NotNodePayload: components["schemas"]["SearchNodePayload"] & {
      child?: components["schemas"]["SearchNodePayload"];
    } & {
      child: unknown;
    };
    NotificationCountPayload: {
      organizationId?: number;
      unread: number;
    };
    NotificationPayload: {
      id: number;
      notificationCriticality: "Info" | "Warning" | "Error" | "Success";
      organizationId?: number;
      title: string;
      body: string;
      localUrl: string;
      createdTime: string;
      isRead: boolean;
    };
    /** Search criterion that matches results that meet any of a set of other search criteria. That is, if the list of children is x, y, and z, this will require x OR y OR z. */
    OrNodePayload: components["schemas"]["SearchNodePayload"];
    OrganizationPayload: {
      /** ISO 3166 alpha-2 code of organization's country. */
      countryCode?: string;
      /** ISO 3166-2 code of organization's country subdivision (state, province, region, etc.) This is the full ISO 3166-2 code including the country prefix. If this is set, countryCode will also be set. */
      countrySubdivisionCode?: string;
      createdTime: string;
      description?: string;
      /** This organization's facilities. Only included if depth is "Facility". */
      facilities?: components["schemas"]["FacilityPayload"][];
      id: number;
      name: string;
      /** The current user's role in the organization. */
      role: "Contributor" | "Manager" | "Admin" | "Owner";
      /** The total number of users in the organization, including the current user. */
      totalUsers: number;
    };
    OrganizationRolePayload: {
      role: "Contributor" | "Manager" | "Admin" | "Owner";
      /** Total number of users in the organization with this role. */
      totalUsers: number;
    };
    OrganizationUserPayload: {
      /** Date and time the user was added to the organization. */
      addedTime: string;
      email: string;
      id: number;
      /** The user's first name. Not present if the user has been added to the organization but has not signed up for an account yet. */
      firstName?: string;
      /** The user's last name. Not present if the user has been added to the organization but has not signed up for an account yet. */
      lastName?: string;
      role: "Contributor" | "Manager" | "Admin" | "Owner";
    };
    Point: components["schemas"]["Geometry"] & {
      /** A single position. In the terraware-server API, positions must always include 3 dimensions. The X and Y dimensions use the coordinate system specified by the crs field, and the Z dimension is in meters. */
      coordinates?: number[];
    } & {
      coordinates: unknown;
    };
    Polygon: components["schemas"]["Geometry"] & {
      coordinates?: number[][][];
    } & {
      coordinates: unknown;
    };
    RecordTimeseriesValuesRequestPayload: {
      timeseries: components["schemas"]["TimeseriesValuesPayload"][];
    };
    /** Results of a request to record timeseries values. */
    RecordTimeseriesValuesResponsePayload: {
      /** List of values that the server failed to record. Will not be included if all the values were recorded successfully. */
      failures?: components["schemas"]["TimeseriesValuesErrorPayload"][];
      status: components["schemas"]["SuccessOrError"];
      error?: components["schemas"]["ErrorDetails"];
    };
    ResolveSpeciesUploadRequestPayload: {
      /** If true, the data for entries that already exist will be overwritten with the values in the uploaded file. If false, only entries that don't already exist will be imported. */
      overwriteExisting: boolean;
    };
    SearchAccessionsRequestPayload: {
      facilityId: number;
      fields: string[];
      sortOrder?: components["schemas"]["SearchSortOrderElement"][];
      search?:
        | components["schemas"]["AndNodePayload"]
        | components["schemas"]["FieldNodePayload"]
        | components["schemas"]["NotNodePayload"]
        | components["schemas"]["OrNodePayload"];
      cursor?: string;
      count: number;
    };
    /** A search criterion. The search will return results that match this criterion. The criterion can be composed of other search criteria to form arbitrary Boolean search expressions. TYPESCRIPT-OVERRIDE-TYPE-WITH-ANY */
    SearchNodePayload: any;
    SearchRequestPayload: {
      /** Prefix for field names. This determines how field names are interpreted, and also how results are structured. Each element in the "results" array in the response will be an instance of whatever entity the prefix points to. Always evaluated starting from the "organizations" level. If not present, the search will return a list of organizations. */
      prefix?: string;
      /** List of fields to return. Field names should be relative to the prefix. They may navigate the data hierarchy using '.' or '_' as delimiters. */
      fields: string[];
      /** How to sort the search results. This controls both the order of the top-level results and the order of any lists of child objects. */
      sortOrder?: components["schemas"]["SearchSortOrderElement"][];
      search?:
        | components["schemas"]["AndNodePayload"]
        | components["schemas"]["FieldNodePayload"]
        | components["schemas"]["NotNodePayload"]
        | components["schemas"]["OrNodePayload"];
      /** Maximum number of top-level search results to return. The system may impose a limit on this value. A separate system-imposed limit may also be applied to lists of child objects inside the top-level results. Use a value of 0 to return the maximum number of allowed results. */
      count: number;
      /** Starting point for search results. If present, a previous search will be continued from where it left off. This should be the value of the cursor that was returned in the response to a previous search. */
      cursor?: string;
    };
    SearchResponsePayload: {
      results: { [key: string]: unknown }[];
      cursor?: string;
    };
    SearchSortOrderElement: {
      field: string;
      direction?: "Ascending" | "Descending";
    };
    /** Represents a quantity of seeds, measured either in individual seeds or by weight. */
    SeedQuantityPayload: {
      /** Number of units of seeds. If "units" is "Seeds", this is the number of seeds and must be an integer. Otherwise it is a measurement in the weight units specified in the "units" field, and may have a fractional part. */
      quantity: number;
      units:
        | "Seeds"
        | "Grams"
        | "Milligrams"
        | "Kilograms"
        | "Ounces"
        | "Pounds";
      /** If this quantity is a weight measurement, the weight in grams. This is not set if the "units" field is "Seeds". This is always calculated on the server side and is ignored on input. */
      grams?: number;
    };
    SendFacilityAlertRequestPayload: {
      subject: string;
      /** Alert body in plain text. HTML alerts are not supported yet. */
      body: string;
    };
    SimpleErrorResponsePayload: {
      error: components["schemas"]["ErrorDetails"];
      status: components["schemas"]["SuccessOrError"];
    };
    SimpleSuccessResponsePayload: {
      status: components["schemas"]["SuccessOrError"];
    };
    SpeciesLookupCommonNamePayload: {
      name: string;
      /** ISO 639-1 two-letter language code indicating the name's language. Some common names in the server's taxonomic database are not tagged with languages; this value will not be present for those names. */
      language?: string;
    };
    SpeciesLookupDetailsResponsePayload: {
      scientificName: string;
      /** List of known common names for the species, if any. */
      commonNames?: components["schemas"]["SpeciesLookupCommonNamePayload"][];
      familyName: string;
      /** True if the species is known to be endangered, false if the species is known to not be endangered. This value will not be present if the server's taxonomic database doesn't indicate whether or not the species is endangered. */
      endangered?: boolean;
      /** If this is not the accepted name for the species, the type of problem the name has. Currently, this will always be "Name Is Synonym". */
      problemType?: "Name Misspelled" | "Name Not Found" | "Name Is Synonym";
      /** If this is not the accepted name for the species, the name to suggest as an alternative. */
      suggestedScientificName?: string;
    };
    SpeciesLookupNamesResponsePayload: {
      names: string[];
      /** True if there were more matching names than could be included in the response. */
      partial: boolean;
      status: components["schemas"]["SuccessOrError"];
    };
    SpeciesProblemElement: {
      id: number;
      field: "Scientific Name";
      type: "Name Misspelled" | "Name Not Found" | "Name Is Synonym";
      /** Value for the field in question that would correct the problem. Absent if the system is unable to calculate a corrected value. */
      suggestedValue?: string;
    };
    SpeciesRequestPayload: {
      commonName?: string;
      endangered?: boolean;
      familyName?: string;
      growthForm?: "Tree" | "Shrub" | "Forb" | "Graminoid" | "Fern";
      /** Which organization's species list to update. */
      organizationId: number;
      rare?: boolean;
      scientificName: string;
      seedStorageBehavior?:
        | "Orthodox"
        | "Recalcitrant"
        | "Intermediate"
        | "Unknown";
    };
    SpeciesResponseElement: {
      commonName?: string;
      endangered?: boolean;
      familyName?: string;
      growthForm?: "Tree" | "Shrub" | "Forb" | "Graminoid" | "Fern";
      id: number;
      problems?: components["schemas"]["SpeciesProblemElement"][];
      rare?: boolean;
      scientificName: string;
      seedStorageBehavior?:
        | "Orthodox"
        | "Recalcitrant"
        | "Intermediate"
        | "Unknown";
    };
    /** List of conditions that might cause the user to want to cancel the upload but that can be automatically resolved if desired. */
    SpeciesUploadProblemPayload: {
      /** Name of the field with the problem. Absent if the problem isn't specific to a single field. */
      fieldName?: string;
      /** Human-readable description of the problem. */
      message?: string;
      /** Position (row number) of the record with the problem. */
      position?: number;
      type:
        | "Unrecognized Value"
        | "Missing Required Value"
        | "Duplicate Value"
        | "Malformed Value";
      /** The value that caused the problem. Absent if the problem wasn't caused by a specific field value. */
      value?: string;
    };
    StorageLocationDetails: {
      storageLocation: string;
      storageCondition: "Refrigerator" | "Freezer";
    };
    StorageLocationsResponsePayload: {
      locations: components["schemas"]["StorageLocationDetails"][];
      status: components["schemas"]["SuccessOrError"];
    };
    /** Indicates of success or failure of the requested operation. */
    SuccessOrError: "ok" | "error";
    /** Summary of important statistics about the seed bank for the Summary page. */
    SummaryResponse: {
      activeAccessions: components["schemas"]["SummaryStatistic"] | number;
      species: components["schemas"]["SummaryStatistic"] | number;
      /** Number of accessions in Pending state overdue for processing */
      overduePendingAccessions: number;
      /** Number of accessions in Processed state overdue for drying */
      overdueProcessedAccessions: number;
      /** Number of accessions in Dried state overdue for storage */
      overdueDriedAccessions: number;
      /** Number of accessions withdrawn so far this week */
      recentlyWithdrawnAccessions: number;
    };
    /** The current value and value as of last week for a summary statistic */
    SummaryStatistic: {
      current: number;
      lastWeek: number;
    };
    /** Timeseries to query. May be from different devices. */
    TimeseriesIdPayload: {
      deviceId: number;
      timeseriesName: string;
    };
    TimeseriesPayload: {
      /** ID of device that produces this timeseries. */
      deviceId: number;
      timeseriesName: string;
      type: "Numeric" | "Text";
      /** Number of significant fractional digits (after the decimal point), if this is a timeseries with non-integer numeric values. */
      decimalPlaces?: number;
      /** Units of measure for values in this timeseries. */
      units?: string;
      latestValue?: components["schemas"]["TimeseriesValuePayload"];
    };
    TimeseriesValuePayload: {
      timestamp: string;
      /** Value to record. If the timeseries is of type Numeric, this must be a decimal or integer value in string form. If the timeseries is of type Text, this can be an arbitrary string. */
      value: string;
    };
    /** List of values that the server failed to record. Will not be included if all the values were recorded successfully. */
    TimeseriesValuesErrorPayload: {
      /** Device ID as specified in the failing request. */
      deviceId: number;
      /** Name of timeseries as specified in the failing request. */
      timeseriesName: string;
      /** Values that the server was not able to successfully record. */
      values: components["schemas"]["TimeseriesValuePayload"][];
      /** Human-readable details about the failure. */
      message: string;
    };
    TimeseriesValuesPayload: {
      /** ID of device that produced this value. */
      deviceId: number;
      /** Name of timeseries. This must be the name of a timeseries that has already been created for the device. */
      timeseriesName: string;
      values: components["schemas"]["TimeseriesValuePayload"][];
    };
    UpdateAccessionRequestPayload: {
      bagNumbers?: string[];
      collectedDate?: string;
      cutTestSeedsCompromised?: number;
      cutTestSeedsEmpty?: number;
      cutTestSeedsFilled?: number;
      dryingEndDate?: string;
      dryingMoveDate?: string;
      dryingStartDate?: string;
      endangered?: "No" | "Yes" | "Unsure";
      environmentalNotes?: string;
      facilityId?: number;
      family?: string;
      fieldNotes?: string;
      founderId?: string;
      geolocations?: components["schemas"]["Geolocation"][];
      /** Initial size of accession. The units of this value must match the measurement type in "processingMethod". */
      initialQuantity?: components["schemas"]["SeedQuantityPayload"];
      landowner?: string;
      numberOfTrees?: number;
      nurseryStartDate?: string;
      primaryCollector?: string;
      processingMethod?: "Count" | "Weight";
      processingNotes?: string;
      processingStaffResponsible?: string;
      processingStartDate?: string;
      rare?: "No" | "Yes" | "Unsure";
      receivedDate?: string;
      secondaryCollectors?: string[];
      siteLocation?: string;
      sourcePlantOrigin?: "Wild" | "Outplant";
      species?: string;
      storageLocation?: string;
      storageNotes?: string;
      storagePackets?: number;
      storageStaffResponsible?: string;
      storageStartDate?: string;
      subsetCount?: number;
      /** Weight of subset of seeds. Units must be a weight measurement, not "Seeds". */
      subsetWeight?: components["schemas"]["SeedQuantityPayload"];
      targetStorageCondition?: "Refrigerator" | "Freezer";
      viabilityTests?: components["schemas"]["ViabilityTestPayload"][];
      viabilityTestTypes?: ("Lab" | "Nursery")[];
      withdrawals?: components["schemas"]["WithdrawalPayload"][];
    };
    UpdateAccessionResponsePayload: {
      accession: components["schemas"]["AccessionPayload"];
      status: components["schemas"]["SuccessOrError"];
    };
    UpdateAutomationRequestPayload: {
      type: string;
      name: string;
      description?: string;
      deviceId?: number;
      timeseriesName?: string;
      verbosity?: number;
      lowerThreshold?: number;
      upperThreshold?: number;
      settings?: { [key: string]: { [key: string]: unknown } };
    };
    UpdateDeviceRequestPayload: {
      /** Name of this device. */
      name: string;
      /** High-level type of the device. Device manager may use this in conjunction with the make and model to determine which metrics to report. */
      type: string;
      /** Name of device manufacturer. */
      make: string;
      /** Model number or model name of the device. */
      model: string;
      /** Device manager protocol name. */
      protocol?: string;
      /** Protocol-specific address of device, e.g., an IP address or a Bluetooth device ID. */
      address?: string;
      /** Port number if relevant for the protocol. */
      port?: number;
      /** Protocol- and device-specific custom settings. This is an arbitrary JSON object; the exact settings depend on the device type. */
      settings?: { [key: string]: unknown };
      /** Level of diagnostic information to log. */
      verbosity?: number;
      /** ID of parent device such as a hub or gateway, if any. The parent device must exist. */
      parentId?: number;
    };
    UpdateFacilityRequestPayload: {
      description?: string;
      name: string;
    };
    UpdateNotificationRequestPayload: {
      read: boolean;
    };
    UpdateNotificationsRequestPayload: {
      read: boolean;
      organizationId?: number;
    };
    UpdateOrganizationRequestPayload: {
      /** ISO 3166 alpha-2 code of organization's country. */
      countryCode?: string;
      /** ISO 3166-2 code of organization's country subdivision (state, province, region, etc.) This is the full ISO 3166-2 code including the country prefix. If this is set, countryCode must also be set. */
      countrySubdivisionCode?: string;
      description?: string;
      name: string;
    };
    UpdateOrganizationUserRequestPayload: {
      role: "Contributor" | "Manager" | "Admin" | "Owner";
    };
    UpdateUserRequestPayload: {
      /** If true, the user wants to receive all the notifications for their organizations via email. This does not apply to certain kinds of notifications such as "You've been added to a new organization." If null, leave the existing value as-is. */
      emailNotificationsEnabled?: boolean;
      firstName: string;
      lastName: string;
    };
    UploadPhotoMetadataPayload: {
      capturedTime: string;
      /** @deprecated Use location field instead. */
      latitude?: number;
      /** @deprecated Use location field instead. */
      longitude?: number;
      location?: components["schemas"]["Point"];
      /** GPS accuracy in meters. */
      gpsAccuracy?: number;
    };
    UploadSpeciesListResponsePayload: {
      /** ID of uploaded file. This may be used to poll for the file's status. */
      id: number;
      status: components["schemas"]["SuccessOrError"];
    };
    UserProfilePayload: {
      /** User's unique ID. This should not be shown to the user, but is a required input to some API endpoints. */
      id: number;
      email: string;
      /** If true, the user wants to receive all the notifications for their organizations via email. This does not apply to certain kinds of notifications such as "You've been added to a new organization." */
      emailNotificationsEnabled: boolean;
      firstName?: string;
      lastName?: string;
    };
    ViabilityTestPayload: {
      /** Server-assigned unique ID of this viability test. Null when creating a new test. */
      id?: string;
      /** Which type of test is described. At most one of each test type is allowed. */
      testType: "Lab" | "Nursery";
      startDate?: string;
      endDate?: string;
      seedType?: "Fresh" | "Stored";
      substrate?:
        | "Nursery Media"
        | "Agar Petri Dish"
        | "Paper Petri Dish"
        | "Other";
      treatment?: "Soak" | "Scarify" | "GA3" | "Stratification" | "Other";
      notes?: string;
      /** Quantity of seeds remaining. For weight-based accessions, this is user input and is required. For count-based accessions, it is calculated by the server and ignored on input. */
      remainingQuantity?: components["schemas"]["SeedQuantityPayload"];
      staffResponsible?: string;
      seedsSown?: number;
      testResults?: components["schemas"]["ViabilityTestResultPayload"][];
      totalPercentGerminated?: number;
      totalSeedsGerminated?: number;
    };
    ViabilityTestResultPayload: {
      recordingDate: string;
      seedsGerminated: number;
    };
    WithdrawalPayload: {
      /** Server-assigned unique ID of this withdrawal, its ID. Omit when creating a new withdrawal. */
      id?: number;
      date: string;
      purpose:
        | "Propagation"
        | "Outreach or Education"
        | "Research"
        | "Broadcast"
        | "Share with Another Site"
        | "Other"
        | "Viability Testing";
      destination?: string;
      notes?: string;
      /** Quantity of seeds remaining. For weight-based accessions, this is user input and is required. For count-based accessions, it is calculated by the server and ignored on input. */
      remainingQuantity?: components["schemas"]["SeedQuantityPayload"];
      staffResponsible?: string;
      /** If this withdrawal is of purpose "Germination Testing", the ID of the test it is associated with. This is always set by the server and cannot be modified. */
      viabilityTestId?: number;
      /** For weight-based accessions, the difference between the weight remaining before this withdrawal and the weight remaining after it. This is a server-calculated value and is ignored on input. */
      weightDifference?: components["schemas"]["SeedQuantityPayload"];
      /** Quantity of seeds withdrawn. For viability testing withdrawals, this is always the same as the test's "seedsSown" value, if that value is present. Otherwise, it is a user-supplied value. For count-based accessions, the units must always be "Seeds". For weight-based accessions, the units may either be a weight measurement or "Seeds". */
      withdrawnQuantity?: components["schemas"]["SeedQuantityPayload"];
      /** The best estimate of the number of seeds withdrawn. This is the same as "withdrawnQuantity" if that is present, or else the same as "weightDifference" if this is a weight-based accession. If this is a count-based accession and "withdrawnQuantity" does not have a value, this field will not be present. This is a server-calculated value and is ignored on input. */
      estimatedQuantity?: components["schemas"]["SeedQuantityPayload"];
    };
  };
}

export interface operations {
  listAutomations_2: {
    parameters: {
      query: {
        deviceId?: number;
        facilityId?: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListAutomationsResponsePayload"];
        };
      };
    };
  };
  createAutomation_2: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateAutomationResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateAutomationRequestPayload"];
      };
    };
  };
  getAutomation_2: {
    parameters: {
      path: {
        automationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetAutomationResponsePayload"];
        };
      };
    };
  };
  updateAutomation_2: {
    parameters: {
      path: {
        automationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateAutomationRequestPayload"];
      };
    };
  };
  deleteAutomation_2: {
    parameters: {
      path: {
        automationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  postAutomationTrigger: {
    parameters: {
      path: {
        automationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AutomationTriggerRequestPayload"];
      };
    };
  };
  createDevice: {
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateDeviceRequestPayload"];
      };
    };
  };
  getDeviceManagers: {
    parameters: {
      query: {
        sensorKitId?: string;
        facilityId?: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetDeviceManagersResponsePayload"];
        };
      };
    };
  };
  getDeviceManager: {
    parameters: {
      path: {
        deviceManagerId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetDeviceManagerResponsePayload"];
        };
      };
    };
  };
  connectDeviceManager: {
    parameters: {
      path: {
        deviceManagerId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectDeviceManagerRequestPayload"];
      };
    };
  };
  listDeviceTemplates: {
    parameters: {
      query: {
        category?: "PV" | "Seed Bank Default";
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListDeviceTemplatesResponsePayload"];
        };
      };
    };
  };
  getDevice: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** Device configuration retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["GetDeviceResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  updateDevice: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** Device configuration updated. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateDeviceRequestPayload"];
      };
    };
  };
  /** Notifies the appropriate users so they can troubleshoot the problem. */
  deviceUnresponsive: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeviceUnresponsiveRequestPayload"];
      };
    };
  };
  listAllFacilities_1: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListFacilitiesResponse"];
        };
      };
    };
  };
  createFacility_1: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateFacilityResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateFacilityRequestPayload"];
      };
    };
  };
  getFacility: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetFacilityResponse"];
        };
      };
    };
  };
  updateFacility: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateFacilityRequestPayload"];
      };
    };
  };
  sendFacilityAlert: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The request was received, but the user is still configuring or placing sensors, so no notification has been generated. */
      202: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SendFacilityAlertRequestPayload"];
      };
    };
  };
  listAutomations_1: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ListAutomationsResponsePayload"];
        };
      };
      /** The facility does not exist or is not accessible. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  createAutomation_1: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["CreateAutomationResponsePayload"];
        };
      };
      /** The facility does not exist or is not accessible. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ModifyAutomationRequestPayload"];
      };
    };
  };
  getAutomation_1: {
    parameters: {
      path: {
        facilityId: number;
        automationId: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetAutomationResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  updateAutomation_1: {
    parameters: {
      path: {
        facilityId: number;
        automationId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ModifyAutomationRequestPayload"];
      };
    };
  };
  deleteAutomation_1: {
    parameters: {
      path: {
        facilityId: number;
        automationId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** After connecting a device manager and finishing any necessary configuration of the facility's devices, send this request to enable processing of timeseries values and alerts from the device manager. Only valid if the facility's connection state is `Connected`. */
  postConfigured_1: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The facility's device manager was not in the process of being configured. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listFacilityDevices: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** Successfully listed the facility's devices. */
      200: {
        content: {
          "application/json": components["schemas"]["ListDeviceConfigsResponse"];
        };
      };
      /** The facility does not exist or is not accessible by the current user. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listAllFacilities: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListFacilitiesResponse"];
        };
      };
    };
  };
  createFacility: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateFacilityResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateFacilityRequestPayload"];
      };
    };
  };
  getFacility_1: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetFacilityResponse"];
        };
      };
    };
  };
  updateFacility_1: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateFacilityRequestPayload"];
      };
    };
  };
  sendFacilityAlert_1: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The request was received, but the user is still configuring or placing sensors, so no notification has been generated. */
      202: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SendFacilityAlertRequestPayload"];
      };
    };
  };
  listAutomations: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["ListAutomationsResponsePayload"];
        };
      };
      /** The facility does not exist or is not accessible. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  createAutomation: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["CreateAutomationResponsePayload"];
        };
      };
      /** The facility does not exist or is not accessible. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ModifyAutomationRequestPayload"];
      };
    };
  };
  getAutomation: {
    parameters: {
      path: {
        facilityId: number;
        automationId: number;
      };
    };
    responses: {
      /** Success */
      200: {
        content: {
          "application/json": components["schemas"]["GetAutomationResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  updateAutomation: {
    parameters: {
      path: {
        facilityId: number;
        automationId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ModifyAutomationRequestPayload"];
      };
    };
  };
  deleteAutomation: {
    parameters: {
      path: {
        facilityId: number;
        automationId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** After connecting a device manager and finishing any necessary configuration of the facility's devices, send this request to enable processing of timeseries values and alerts from the device manager. Only valid if the facility's connection state is `Connected`. */
  postConfigured: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The facility's device manager was not in the process of being configured. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listFacilityDevices_1: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** Successfully listed the facility's devices. */
      200: {
        content: {
          "application/json": components["schemas"]["ListDeviceConfigsResponse"];
        };
      };
      /** The facility does not exist or is not accessible by the current user. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** For interactive web applications, this can be used to redirect the user to a login page to allow the application to make other API requests. The login process will set a cookie that will authenticate to the API, and will then redirect back to the application. One approach is to use this in error response handlers: if an API request returns HTTP 401 Unauthorized, set location.href to this endpoint and set "redirect" to the URL of the page the user was on so they'll return there after logging in. */
  login: {
    parameters: {
      query: {
        redirect: string;
      };
    };
    responses: {
      /** Redirects to a login page. After login, the user will be redirected back to the URL specified in the "redirect" parameter. */
      302: never;
    };
  };
  readAll: {
    parameters: {
      query: {
        organizationId?: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNotificationsResponsePayload"];
        };
      };
    };
  };
  markAllRead: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateNotificationsRequestPayload"];
      };
    };
  };
  count: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNotificationsCountResponsePayload"];
        };
      };
    };
  };
  read_2: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetNotificationResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  markRead: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateNotificationRequestPayload"];
      };
    };
  };
  /** Lists all organizations the user can access. */
  listOrganizations: {
    parameters: {
      query: {
        depth?: "Organization" | "Facility";
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListOrganizationsResponsePayload"];
        };
      };
    };
  };
  createOrganization: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetOrganizationResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateOrganizationRequestPayload"];
      };
    };
  };
  getOrganization: {
    parameters: {
      path: {
        organizationId: number;
      };
      query: {
        depth?: "Organization" | "Facility";
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetOrganizationResponsePayload"];
        };
      };
    };
  };
  updateOrganization: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateOrganizationRequestPayload"];
      };
    };
  };
  /** Organizations can only be deleted if they have no members other than the current user. */
  deleteOrganization: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** The organization has other members and cannot be deleted. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listOrganizationRoles: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListOrganizationRolesResponsePayload"];
        };
      };
    };
  };
  listOrganizationUsers: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListOrganizationUsersResponsePayload"];
        };
      };
    };
  };
  addOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["CreateOrganizationUserResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["AddOrganizationUserRequestPayload"];
      };
    };
  };
  getOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
        userId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetOrganizationUserResponsePayload"];
        };
      };
    };
  };
  /** Only includes organization-level information that can be modified by organization administrators. */
  updateOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
        userId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The user is not a member of the organization. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** An organization must have at least one owner; cannot change the role of an organization's only owner. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateOrganizationUserRequestPayload"];
      };
    };
  };
  /** Does not remove any data created by the user. */
  deleteOrganizationUser: {
    parameters: {
      path: {
        organizationId: number;
        userId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The user is not a member of the organization. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** The user is the organization's only owner and an organization must have at least one owner. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  search_1: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SearchResponsePayload"];
          "text/csv": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SearchRequestPayload"];
      };
    };
  };
  create_1: {
    responses: {
      /** The accession was created successfully. Response includes fields populated by the server, including the accession number and ID. */
      200: {
        content: {
          "application/json": components["schemas"]["CreateAccessionResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateAccessionRequestPayload"];
      };
    };
  };
  read_1: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetAccessionResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  update_1: {
    parameters: {
      path: {
        id: number;
      };
      query: {
        simulate?: boolean;
      };
    };
    responses: {
      /** The accession was updated successfully. Response includes fields populated or modified by the server as a result of the update. */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayload"];
        };
      };
      /** The specified accession doesn't exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateAccessionRequestPayload"];
      };
    };
  };
  checkIn_1: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listPhotos: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** The accession's photos are listed in the response. */
      200: {
        content: {
          "application/json": components["schemas"]["ListPhotosResponsePayload"];
        };
      };
      /** The accession does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio. */
  getPhoto_1: {
    parameters: {
      path: {
        id: number;
        photoFilename: string;
      };
      query: {
        maxWidth?: number;
        maxHeight?: number;
      };
    };
    responses: {
      /** The photo was successfully retrieved. */
      200: {
        content: {
          "image/jpeg": string;
        };
      };
      /** The accession does not exist, or does not have a photo with the requested filename. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  uploadPhoto_1: {
    parameters: {
      path: {
        id: number;
        photoFilename: string;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The specified accession does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** The requested photo already exists on the accession. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          file: string;
          metadata: components["schemas"]["UploadPhotoMetadataPayload"];
        };
      };
    };
  };
  create: {
    responses: {
      /** The accession was created successfully. Response includes fields populated by the server, including the accession number and ID. */
      200: {
        content: {
          "application/json": components["schemas"]["CreateAccessionResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateAccessionRequestPayload"];
      };
    };
  };
  read: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetAccessionResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  update: {
    parameters: {
      path: {
        id: number;
      };
      query: {
        simulate?: boolean;
      };
    };
    responses: {
      /** The accession was updated successfully. Response includes fields populated or modified by the server as a result of the update. */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayload"];
        };
      };
      /** The specified accession doesn't exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateAccessionRequestPayload"];
      };
    };
  };
  checkIn: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["UpdateAccessionResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  listPhotos_1: {
    parameters: {
      path: {
        id: number;
      };
    };
    responses: {
      /** The accession's photos are listed in the response. */
      200: {
        content: {
          "application/json": components["schemas"]["ListPhotosResponsePayload"];
        };
      };
      /** The accession does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Optional maxWidth and maxHeight parameters may be included to control the dimensions of the image; the server will scale the original down as needed. If neither parameter is specified, the original full-size image will be returned. The aspect ratio of the original image is maintained, so the returned image may be smaller than the requested width and height. If only maxWidth or only maxHeight is supplied, the other dimension will be computed based on the original image's aspect ratio. */
  getPhoto: {
    parameters: {
      path: {
        id: number;
        photoFilename: string;
      };
      query: {
        maxWidth?: number;
        maxHeight?: number;
      };
    };
    responses: {
      /** The photo was successfully retrieved. */
      200: {
        content: {
          "image/jpeg": string;
        };
      };
      /** The accession does not exist, or does not have a photo with the requested filename. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  uploadPhoto: {
    parameters: {
      path: {
        id: number;
        photoFilename: string;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The specified accession does not exist. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** The requested photo already exists on the accession. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          file: string;
          metadata: components["schemas"]["UploadPhotoMetadataPayload"];
        };
      };
    };
  };
  /** In test environments, the clock can be advanced artificially, which will cause it to differ from the real-world date and time. */
  getCurrentTime: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetCurrentTimeResponsePayload"];
        };
      };
    };
  };
  recordLogMessage: {
    parameters: {
      path: {
        tag: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
    };
    requestBody: {
      content: {
        "application/json": { [key: string]: { [key: string]: unknown } };
      };
    };
  };
  searchAccessions: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SearchResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SearchAccessionsRequestPayload"];
      };
    };
  };
  exportAccessions: {
    responses: {
      /** Export succeeded. */
      200: {
        content: {
          "text/csv": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ExportAccessionsRequestPayload"];
      };
    };
  };
  getSeedBankSummary: {
    parameters: {
      query: {
        organizationId?: number;
        facilityId?: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SummaryResponse"];
        };
      };
    };
  };
  getSummary: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SummaryResponse"];
        };
      };
    };
  };
  listFieldValues: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListFieldValuesResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ListFieldValuesRequestPayload"];
      };
    };
  };
  listAllFieldValues: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListAllFieldValuesResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ListAllFieldValuesRequestPayload"];
      };
    };
  };
  getStorageLocations: {
    parameters: {
      path: {
        facilityId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["StorageLocationsResponsePayload"];
        };
      };
    };
  };
  listSpecies: {
    parameters: {
      query: {
        organizationId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListSpeciesResponsePayload"];
        };
      };
    };
  };
  createSpecies: {
    responses: {
      /** Species created. */
      200: {
        content: {
          "application/json": components["schemas"]["CreateSpeciesResponsePayload"];
        };
      };
      /** A species with the requested name already exists. */
      409: {
        content: {
          "application/json": components["schemas"]["CreateSpeciesResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SpeciesRequestPayload"];
      };
    };
  };
  getSpeciesDetails: {
    parameters: {
      query: {
        scientificName: string;
        language?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SpeciesLookupDetailsResponsePayload"];
        };
      };
      /** The scientific name was not found in the server's taxonomic database. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Gets a list of known scientific names whose words begin with particular letters. */
  listSpeciesNames: {
    parameters: {
      query: {
        search: string;
        maxResults?: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SpeciesLookupNamesResponsePayload"];
        };
      };
    };
  };
  /** Returns details about a problem with a species. */
  getSpeciesProblem: {
    parameters: {
      path: {
        problemId: number;
      };
    };
    responses: {
      /** Problem retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesProblemResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** Only valid for problems that include suggested changes. */
  acceptProblemSuggestion: {
    parameters: {
      path: {
        problemId: number;
      };
    };
    responses: {
      /** Suggestion applied. Response contains the updated species information. */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** There is no suggested change for this problem. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  deleteProblem: {
    parameters: {
      path: {
        problemId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** The uploaded file must be in CSV format. A template with the correct headers may be downloaded from the `/api/v1/species/uploads/template` endpoint. */
  uploadSpeciesList: {
    parameters: {
      query: {
        organizationId: number;
      };
    };
    responses: {
      /** The file has been successfully received. It will be processed asynchronously; use the ID returned in the response payload to poll for its status using the `/api/v1/species/uploads/{uploadId}` GET endpoint. */
      200: {
        content: {
          "application/json": components["schemas"]["UploadSpeciesListResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          file: string;
        };
      };
    };
  };
  getSpeciesListUploadTemplate: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": string;
        };
      };
    };
  };
  /** Clients may poll this endpoint to monitor the progress of the file. */
  getSpeciesListUploadStatus: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesUploadStatusResponsePayload"];
        };
      };
    };
  };
  /** This may only be called if the status of the upload is "Awaiting User Action". */
  deleteSpeciesListUpload: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The upload was not awaiting user action. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  /** This may only be called if the status of the upload is "Awaiting User Action". */
  resolveSpeciesListUpload: {
    parameters: {
      path: {
        uploadId: number;
      };
    };
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The upload was not awaiting user action. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ResolveSpeciesUploadRequestPayload"];
      };
    };
  };
  getSpecies: {
    parameters: {
      path: {
        speciesId: number;
      };
      query: {
        organizationId: number;
      };
    };
    responses: {
      /** Species retrieved. */
      200: {
        content: {
          "application/json": components["schemas"]["GetSpeciesResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
  };
  updateSpecies: {
    parameters: {
      path: {
        speciesId: number;
      };
    };
    responses: {
      /** Species updated or merged with an existing species. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SpeciesRequestPayload"];
      };
    };
  };
  /** The species will no longer appear in the organization's list of species, but existing data (plants, seeds, etc.) that refer to the species will still refer to it. */
  deleteSpecies: {
    parameters: {
      path: {
        speciesId: number;
      };
      query: {
        organizationId: number;
      };
    };
    responses: {
      /** Species deleted. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
      /** The requested resource was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
      /** Cannot delete the species because it is currently in use. */
      409: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
  };
  listTimeseries: {
    parameters: {
      query: {
        deviceId: number[];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ListTimeseriesResponsePayload"];
        };
      };
    };
  };
  /** If there are existing timeseries with the same names, the old definitions will be overwritten. */
  createMultipleTimeseries: {
    responses: {
      /** The requested operation succeeded. */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateTimeseriesRequestPayload"];
      };
    };
  };
  getTimeseriesHistory: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetTimeseriesHistoryResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["GetTimeseriesHistoryRequestPayload"];
      };
    };
  };
  recordTimeseriesValues: {
    responses: {
      /** Successfully processed the request. Note that this status will be returned even if the server was unable to record some of the values. In that case, the failed values will be returned in the response payload. */
      200: {
        content: {
          "application/json": components["schemas"]["RecordTimeseriesValuesResponsePayload"];
        };
      };
      /** The request was valid, but the user is still configuring or placing sensors, so the timeseries values have not been recorded. */
      202: {
        content: {
          "application/json": components["schemas"]["RecordTimeseriesValuesResponsePayload"];
        };
      };
      /** The request had more than 1000 values. */
      413: {
        content: {
          "application/json": components["schemas"]["SimpleErrorResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["RecordTimeseriesValuesRequestPayload"];
      };
    };
  };
  getMyself: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["GetUserResponsePayload"];
        };
      };
    };
  };
  updateMyself: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SimpleSuccessResponsePayload"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateUserRequestPayload"];
      };
    };
  };
}

export interface external {}
